diff -r feb3d7883ff0 -r d73e73400732 Makefile
--- a/Makefile	Tue Dec 02 11:42:51 2008 +0100
+++ b/Makefile	Fri Mar 13 19:16:23 2009 +0100
@@ -39,7 +39,7 @@
 # Please also write a new version to:
 # gui/win32/Main/Frontend.rc (line 71, around "CAPTION [...]")
 # gui/win32/Inst/installer.nsi (line 57, around "MessageBox MB_YESNO [...]")
-VERS =		0.5.6-r3
+VERS =		pre-0.5.6-r4
 
 TOPDIR = .
 include Makefile.inc
@@ -148,7 +148,7 @@
 ifeq ($(OS),win32)
 SUBDIRS := dot_draw httpinfo mini pgraph secure txtinfo
 else
-SUBDIRS := bmf dot_draw dyn_gw dyn_gw_plain httpinfo mini nameservice pgraph secure txtinfo
+SUBDIRS := bmf dot_draw dyn_gw dyn_gw_plain httpinfo mdns mini nameservice pgraph secure txtinfo
 endif
 endif
 
@@ -214,6 +214,10 @@
 		$(MAKECMD) -C lib/bmf 
 		$(MAKECMD) -C lib/bmf DESTDIR=$(DESTDIR) install 
 
+mdns:
+		$(MAKECMD) -C lib/mdns clean
+		$(MAKECMD) -C lib/mdns 
+		$(MAKECMD) -C lib/mdns DESTDIR=$(DESTDIR) install 
 quagga:
 		$(MAKECMD) -C lib/quagga clean
 		$(MAKECMD) -C lib/quagga 
diff -r feb3d7883ff0 -r d73e73400732 Makefile.inc
--- a/Makefile.inc	Tue Dec 02 11:42:51 2008 +0100
+++ b/Makefile.inc	Fri Mar 13 19:16:23 2009 +0100
@@ -87,7 +87,8 @@
 #WARNINGS +=	-Wunreachable-code
 WARNINGS +=	-Winline
 WARNINGS +=	-Wdisabled-optimization
-WARNINGS +=	-Werror
+# Disable -Werror in stable branch
+#WARNINGS +=	-Werror
 WARNINGS +=	-finline-functions-called-once
 WARNINGS +=	-fearly-inlining
 ifeq ($(DEBUG),0)
diff -r feb3d7883ff0 -r d73e73400732 files/olsrd.conf.default.lq
--- a/files/olsrd.conf.default.lq	Tue Dec 02 11:42:51 2008 +0100
+++ b/files/olsrd.conf.default.lq	Fri Mar 13 19:16:23 2009 +0100
@@ -128,7 +128,8 @@
 LinkQualityLevel	2
 
 # Link quality aging factor
-# Defaults to 0.1, smaller values mean faster reaction to changing links
+# Defaults to 0.1, larger values mean faster reaction to changing links but
+# more instable ETX values
 
 #LinkQualityAging 0.1 
 
diff -r feb3d7883ff0 -r d73e73400732 files/olsrd.conf.default.lq-fisheye
--- a/files/olsrd.conf.default.lq-fisheye	Tue Dec 02 11:42:51 2008 +0100
+++ b/files/olsrd.conf.default.lq-fisheye	Fri Mar 13 19:16:23 2009 +0100
@@ -138,7 +138,8 @@
 LinkQualityLevel	2
 
 # Link quality aging factor
-# Defaults to 0.1, smaller values mean faster reaction to changing links
+# Defaults to 0.1, larger values mean faster reaction to changing links but
+# more instable ETX values
 
 #LinkQualityAging 0.1 
 
diff -r feb3d7883ff0 -r d73e73400732 gui/linux-gtk/README
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/gui/linux-gtk/README	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,11 @@
+To compile this you need libgtk installed. This is
+from my system, which compiles fine:
+
+dpkg -l "*gtk2*"|grep ^ii>>README
+ii  gtk2-engines-pixbuf                        2.12.9-3ubuntu5                                      Pixbuf-based theme for GTK+ 2.x
+ii  libgtk2.0-0                                2.12.9-3ubuntu5                                      The GTK+ graphical user interface library
+ii  libgtk2.0-common                           2.12.9-3ubuntu5                                      Common files for the GTK+ graphical user int
+ii  libgtk2.0-dev                              2.12.9-3ubuntu5                                      Development files for the GTK+ library
+ii  libwxgtk2.6-0                              2.6.3.2.2-2ubuntu4                                   wxWidgets Cross-platform C++ GUI toolkit (GT
+ii  python-gtk2                                2.12.1-0ubuntu1                                      Python bindings for the GTK+ widget set
+ii  python-gtk2-dev                            2.12.1-0ubuntu1                                      GTK+ bindings: devel files
diff -r feb3d7883ff0 -r d73e73400732 gui/win32/Inst/installer.nsi
--- a/gui/win32/Inst/installer.nsi	Tue Dec 02 11:42:51 2008 +0100
+++ b/gui/win32/Inst/installer.nsi	Fri Mar 13 19:16:23 2009 +0100
@@ -54,7 +54,7 @@
 UninstPage instfiles
 
 Function .onInit
-        MessageBox MB_YESNO "This will install olsr.org pre-0.5.6-r3 on your computer. Continue?" IDYES NoAbort
+        MessageBox MB_YESNO "This will install olsr.org pre-0.5.6-r4 on your computer. Continue?" IDYES NoAbort
         Abort
 NoAbort:
 FunctionEnd
diff -r feb3d7883ff0 -r d73e73400732 gui/win32/Main/Frontend.rc
--- a/gui/win32/Main/Frontend.rc	Tue Dec 02 11:42:51 2008 +0100
+++ b/gui/win32/Main/Frontend.rc	Fri Mar 13 19:16:23 2009 +0100
@@ -68,7 +68,7 @@
 STYLE DS_MODALFRAME | WS_MINIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
     WS_SYSMENU
 EXSTYLE WS_EX_APPWINDOW
-CAPTION "olsr.org Switch pre-0.5.6-r3"
+CAPTION "olsr.org Switch pre-0.5.6-r4"
 FONT 8, "MS Sans Serif", 0, 0, 0x1
 BEGIN
     CONTROL         "Tab1",IDC_TAB1,"SysTabControl32",0x0,7,7,383,256
diff -r feb3d7883ff0 -r d73e73400732 gui/win32/Main/MyDialog2.cpp
--- a/gui/win32/Main/MyDialog2.cpp	Tue Dec 02 11:42:51 2008 +0100
+++ b/gui/win32/Main/MyDialog2.cpp	Fri Mar 13 19:16:23 2009 +0100
@@ -392,7 +392,7 @@
 	::lstrcpy(Int->name, Name);
 
 	Int->config = NULL;
-	Int->configured = OLSR_FALSE;
+	Int->configured = false;
 	Int->interf = NULL;
 
 	Int->cnf = get_default_if_config();
@@ -523,7 +523,7 @@
 	m_MprCov.GetWindowText(Conv);
 	Conf->mpr_coverage = (unsigned char)atoi(Conv);
 
-	Conf->use_hysteresis = m_HystCheck.GetCheck() ? OLSR_TRUE : OLSR_FALSE;
+	Conf->use_hysteresis = m_HystCheck.GetCheck() ? true : false;
 
 	m_HystScaling.GetWindowText(Conv);
 	Conf->hysteresis_param.scaling = (float)atof(Conv);
@@ -619,7 +619,7 @@
 		}
 
 		IpcHost->net.prefix = Local;
-		IpcHost->net.prefix_len = (olsr_u8_t)Conf->ipsize;
+		IpcHost->net.prefix_len = (uint8_t)Conf->ipsize;
 
 		IpcHost->next = Conf->ipc_nets;
 		Conf->ipc_nets = IpcHost;
diff -r feb3d7883ff0 -r d73e73400732 gui/win32/Main/TrayIcon.h
--- a/gui/win32/Main/TrayIcon.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/gui/win32/Main/TrayIcon.h	Fri Mar 13 19:16:23 2009 +0100
@@ -12,7 +12,8 @@
 
   static TrayIcon *getInstance() {
     return instance;
-  } enum status { CONNECTED, ON, OFF };
+  }
+  enum status { CONNECTED, ON, OFF };
 
   void setStatus(status con_status, const char *message);
 
diff -r feb3d7883ff0 -r d73e73400732 lib/bmf/src/NetworkInterfaces.c
--- a/lib/bmf/src/NetworkInterfaces.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/bmf/src/NetworkInterfaces.c	Fri Mar 13 19:16:23 2009 +0100
@@ -700,7 +700,7 @@
 #endif
           OLSR_PRINTF(9, "%s: ----> Not forwarding to %s: \"%s\" gives a better link to this neighbor, costing %s\n",
                       PLUGIN_NAME_SHORT, olsr_ip_to_string(&buf, &walker->neighbor_iface_addr), bestIntf->int_name,
-                      get_linkcost_text(bestLinkToNeighbor->linkcost, OLSR_FALSE, &lqbuffer));
+                      get_linkcost_text(bestLinkToNeighbor->linkcost, false, &lqbuffer));
         }
 
         continue;               /* for */
@@ -713,7 +713,7 @@
 #endif
         OLSR_PRINTF(9, "%s: ----> 2-hop path from %s via me to %s will cost ETX %s\n", PLUGIN_NAME_SHORT,
                     olsr_ip_to_string(&forwardedByBuf, forwardedBy), olsr_ip_to_string(&niaBuf, &walker->neighbor_iface_addr),
-                    get_linkcost_text(previousLinkEtx + currEtx, OLSR_TRUE, &lqbuffer));
+                    get_linkcost_text(previousLinkEtx + currEtx, true, &lqbuffer));
       }
 
       /* Check the topology table whether the 'forwardedBy' node is itself a direct
@@ -741,7 +741,7 @@
 #endif
               OLSR_PRINTF(9, "%s: ----> Not forwarding to %s: I am not an MPR between %s and %s, direct link costs %s\n",
                           PLUGIN_NAME_SHORT, neighbor_iface_buf.buf, olsr_ip_to_string(&forw_buf, forwardedBy),
-                          neighbor_iface_buf.buf, get_linkcost_text(tcEtx, OLSR_FALSE, &lqbuffer));
+                          neighbor_iface_buf.buf, get_linkcost_text(tcEtx, false, &lqbuffer));
 
               continue;         /* for */
             }                   /* if */
diff -r feb3d7883ff0 -r d73e73400732 lib/bmf/src/olsrd_plugin.c
--- a/lib/bmf/src/olsrd_plugin.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/bmf/src/olsrd_plugin.c	Fri Mar 13 19:16:23 2009 +0100
@@ -45,7 +45,7 @@
 /* OLSRD includes */
 #include "olsrd_plugin.h"
 #include "plugin_util.h"
-#include "defs.h"               /* olsr_u8_t, olsr_cnf */
+#include "defs.h"               /* uint8_t, olsr_cnf */
 #include "scheduler.h"          /* olsr_start_timer() */
 
 /* BMF includes */
diff -r feb3d7883ff0 -r d73e73400732 lib/dot_draw/src/olsrd_dot_draw.c
--- a/lib/dot_draw/src/olsrd_dot_draw.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/dot_draw/src/olsrd_dot_draw.c	Fri Mar 13 19:16:23 2009 +0100
@@ -105,7 +105,7 @@
 
 static void ipc_print_tc_link(const struct tc_entry *, const struct tc_edge_entry *);
 
-static void ipc_print_net(const union olsr_ip_addr *, const union olsr_ip_addr *, olsr_u8_t);
+static void ipc_print_net(const union olsr_ip_addr *, const union olsr_ip_addr *, uint8_t);
 
 static void ipc_send(const char *, int);
 
@@ -179,7 +179,7 @@
   }
 
   ipc_send_fmt("\"%s\" -> \"%s\"[label=\"%s\", style=%s];\n", adr, olsr_ip_to_string(&strbuf, &neighbor->neighbor_main_addr),
-               get_linkcost_text(etx, OLSR_FALSE, &lqbuffer), style);
+               get_linkcost_text(etx, false, &lqbuffer), style);
 
   if (neighbor->is_mpr) {
     ipc_send_fmt("\"%s\"[shape=box];\n", adr);
@@ -190,7 +190,7 @@
 plugin_ipc_init(void)
 {
   struct sockaddr_in sin;
-  olsr_u32_t yes = 1;
+  uint32_t yes = 1;
 
   if (ipc_socket != -1) {
     close(ipc_socket);
@@ -342,11 +342,11 @@
   struct lqtextbuffer lqbuffer;
 
   ipc_send_fmt("\"%s\" -> \"%s\"[label=\"%s\"];\n", olsr_ip_to_string(&strbuf1, &entry->addr),
-               olsr_ip_to_string(&strbuf2, &dst_entry->T_dest_addr), get_linkcost_text(dst_entry->cost, OLSR_FALSE, &lqbuffer));
+               olsr_ip_to_string(&strbuf2, &dst_entry->T_dest_addr), get_linkcost_text(dst_entry->cost, false, &lqbuffer));
 }
 
 static void
-ipc_print_net(const union olsr_ip_addr *gw, const union olsr_ip_addr *net, olsr_u8_t prefixlen)
+ipc_print_net(const union olsr_ip_addr *gw, const union olsr_ip_addr *net, uint8_t prefixlen)
 {
   struct ipaddr_str gwbuf, netbuf;
 
diff -r feb3d7883ff0 -r d73e73400732 lib/dyn_gw/src/olsrd_dyn_gw.c
--- a/lib/dyn_gw/src/olsrd_dyn_gw.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/dyn_gw/src/olsrd_dyn_gw.c	Fri Mar 13 19:16:23 2009 +0100
@@ -101,20 +101,20 @@
 
 struct hna_list {
   union olsr_ip_addr hna_net;
-  olsr_u8_t hna_prefixlen;
+  uint8_t hna_prefixlen;
   struct ping_list *ping_hosts;
   int hna_added;
   int probe_ok;
   struct hna_list *next;
 };
 
-static struct hna_list *add_to_hna_list(struct hna_list *, union olsr_ip_addr *hna_net, olsr_u8_t hna_prefixlen);
+static struct hna_list *add_to_hna_list(struct hna_list *, union olsr_ip_addr *hna_net, uint8_t hna_prefixlen);
 
 struct hna_list *the_hna_list = NULL;
 
 static void looped_checks(void *) __attribute__ ((noreturn));
 
-static int check_gw(union olsr_ip_addr *, olsr_u8_t, struct ping_list *);
+static int check_gw(union olsr_ip_addr *, uint8_t, struct ping_list *);
 
 static int ping_is_possible(struct ping_list *);
 
@@ -157,7 +157,7 @@
   char s_mask[128];
 
   //192.168.1.0  255.255.255.0
-  int i = sscanf(value, "%128s %128s", s_netaddr, s_mask);
+  int i = sscanf(value, "%127s %127s", s_netaddr, s_mask);
   if (i != 2) {
     OLSR_PRINTF(0, "Cannot get IP address and netmask from \"%s\"", value);
     return 1;
@@ -289,10 +289,10 @@
 }
 
 static int
-check_gw(union olsr_ip_addr *net, olsr_u8_t prefixlen, struct ping_list *the_ping_list)
+check_gw(union olsr_ip_addr *net, uint8_t prefixlen, struct ping_list *the_ping_list)
 {
   char buf[1024], iface[16];
-  olsr_u32_t gate_addr, dest_addr, netmask;
+  uint32_t gate_addr, dest_addr, netmask;
   unsigned int iflags;
   int metric, refcnt, use;
   int retval = 0;
@@ -386,7 +386,7 @@
 }
 
 static struct hna_list *
-add_to_hna_list(struct hna_list *list_root, union olsr_ip_addr *hna_net, olsr_u8_t hna_prefixlen)
+add_to_hna_list(struct hna_list *list_root, union olsr_ip_addr *hna_net, uint8_t hna_prefixlen)
 {
   struct hna_list *new = malloc(sizeof(struct hna_list));
   if (new == NULL) {
diff -r feb3d7883ff0 -r d73e73400732 lib/dyn_gw_plain/src/olsrd_dyn_gw_plain.c
--- a/lib/dyn_gw_plain/src/olsrd_dyn_gw_plain.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/dyn_gw_plain/src/olsrd_dyn_gw_plain.c	Fri Mar 13 19:16:23 2009 +0100
@@ -105,8 +105,8 @@
 int
 check_gw(union olsr_ip_addr *net, union olsr_ip_addr *mask)
 {
-  char buff[1024], iface[16];
-  olsr_u32_t gate_addr, dest_addr, netmask;
+  char buff[1024], iface[17];
+  uint32_t gate_addr, dest_addr, netmask;
   unsigned int iflags;
   int num, metric, refcnt, use;
   int retval = 0;
diff -r feb3d7883ff0 -r d73e73400732 lib/httpinfo/src/admin_interface.c
--- a/lib/httpinfo/src/admin_interface.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/httpinfo/src/admin_interface.c	Fri Mar 13 19:16:23 2009 +0100
@@ -85,7 +85,7 @@
   "</table>\n<br>\n" "<center><input type=\"submit\" value=\"Delete selected\" class=\"input_button\"></center>\n" "</form>\n";
 
 int
-build_admin_body(char *buf, olsr_u32_t bufsize __attribute__ ((unused)))
+build_admin_body(char *buf, uint32_t bufsize __attribute__ ((unused)))
 {
   int size = 0;
   size += snprintf(&buf[size], bufsize - size, admin_frame_prolog);
@@ -155,7 +155,7 @@
 process_param(char *key, char *value)
 {
   static union olsr_ip_addr curr_hna_net;
-  static olsr_bool curr_hna_ok = OLSR_FALSE;
+  static bool curr_hna_ok = false;
 
   if (!strcmp(key, "debug_level")) {
     int ival = atoi(value);
@@ -266,24 +266,24 @@
       fprintf(stderr, "Failed converting new HNA net %s\n", value);
       return -1;
     }
-    curr_hna_ok = OLSR_TRUE;
+    curr_hna_ok = true;
     return 1;
   }
 
   if (!strcmp(key, "hna_new_netmask")) {
     struct in_addr in;
-    olsr_u8_t prefixlen;
+    uint8_t prefixlen;
 
     if (!curr_hna_ok)
       return -1;
 
-    curr_hna_ok = OLSR_FALSE;
+    curr_hna_ok = false;
 
     if (inet_aton(value, &in) == 0) {
       fprintf(stderr, "Failed converting new HNA netmask %s\n", value);
       return -1;
     }
-    prefixlen = netmask_to_prefix((olsr_u8_t *) & in, olsr_cnf->ipsize);
+    prefixlen = netmask_to_prefix((uint8_t *) & in, olsr_cnf->ipsize);
     if (prefixlen == UCHAR_MAX) {
       fprintf(stderr, "Failed converting new HNA netmask %s\n", value);
       return -1;
@@ -296,7 +296,7 @@
     struct in_addr net, mask;
     char ip_net[16], ip_mask[16];
     int seperator = 0;
-    olsr_u8_t prefixlen;
+    uint8_t prefixlen;
 
     while (key[7 + seperator] != '*') {
       seperator++;
@@ -315,7 +315,7 @@
       fprintf(stderr, "Failed converting HNA netmask %s for deletion\n", ip_mask);
       return -1;
     }
-    prefixlen = netmask_to_prefix((olsr_u8_t *) & mask, olsr_cnf->ipsize);
+    prefixlen = netmask_to_prefix((uint8_t *) & mask, olsr_cnf->ipsize);
     if (prefixlen == UCHAR_MAX) {
       fprintf(stderr, "Failed converting new HNA netmask %s\n", value);
       return -1;
@@ -333,11 +333,11 @@
 }
 
 int
-process_set_values(char *data, olsr_u32_t data_size, char *buf, olsr_u32_t bufsize __attribute__ ((unused)))
+process_set_values(char *data, uint32_t data_size, char *buf, uint32_t bufsize __attribute__ ((unused)))
 {
   int size = 0;
   int val_start, key_start;
-  olsr_u32_t i;
+  uint32_t i;
 
   size += sprintf(buf, "<html>\n<head><title>olsr.org httpinfo plugin</title></head>\n<body>\n");
 
diff -r feb3d7883ff0 -r d73e73400732 lib/httpinfo/src/admin_interface.h
--- a/lib/httpinfo/src/admin_interface.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/httpinfo/src/admin_interface.h	Fri Mar 13 19:16:23 2009 +0100
@@ -46,9 +46,9 @@
 #ifndef ADMIN_INTERFACE_H
 #define ADMIN_INTERFACE_H
 
-int build_admin_body(char *, olsr_u32_t);
+int build_admin_body(char *, uint32_t);
 
-int process_set_values(char *, olsr_u32_t, char *, olsr_u32_t);
+int process_set_values(char *, uint32_t, char *, uint32_t);
 
 int process_param(char *, char *);
 
diff -r feb3d7883ff0 -r d73e73400732 lib/httpinfo/src/olsrd_httpinfo.c
--- a/lib/httpinfo/src/olsrd_httpinfo.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/httpinfo/src/olsrd_httpinfo.c	Fri Mar 13 19:16:23 2009 +0100
@@ -130,13 +130,13 @@
   "text-align: center;\nwidth: 120px;\npadding: 0px;\ncolor: #000000;\n"
   "text-decoration: none;\nfont-family: verdana;\nfont-size: 12px;\n" "border: 1px solid #000;\n}\n";
 
-typedef int (*build_body_callback) (char *, olsr_u32_t);
+typedef int (*build_body_callback) (char *, uint32_t);
 
 struct tab_entry {
   const char *tab_label;
   const char *filename;
   build_body_callback build_body_cb;
-  olsr_bool display_tab;
+  bool display_tab;
 };
 
 struct static_bin_file_entry {
@@ -152,45 +152,44 @@
 
 struct dynamic_file_entry {
   const char *filename;
-  int (*process_data_cb) (char *, olsr_u32_t, char *, olsr_u32_t);
+  int (*process_data_cb) (char *, uint32_t, char *, uint32_t);
 };
 
 static int get_http_socket(int);
 
-static int build_tabs(char *, olsr_u32_t, int);
+static int build_tabs(char *, uint32_t, int);
 
 static void parse_http_request(int);
 
-static int build_http_header(http_header_type, olsr_bool, olsr_u32_t, char *, olsr_u32_t);
+static int build_http_header(http_header_type, bool, uint32_t, char *, uint32_t);
 
-static int build_frame(char *, olsr_u32_t, const char *, const char *, int, build_body_callback frame_body_cb);
+static int build_frame(char *, uint32_t, const char *, const char *, int, build_body_callback frame_body_cb);
 
-static int build_routes_body(char *, olsr_u32_t);
+static int build_routes_body(char *, uint32_t);
 
-static int build_config_body(char *, olsr_u32_t);
+static int build_config_body(char *, uint32_t);
 
-static int build_neigh_body(char *, olsr_u32_t);
+static int build_neigh_body(char *, uint32_t);
 
-static int build_topo_body(char *, olsr_u32_t);
+static int build_topo_body(char *, uint32_t);
 
-static int build_mid_body(char *, olsr_u32_t);
+static int build_mid_body(char *, uint32_t);
 
-static int build_nodes_body(char *, olsr_u32_t);
+static int build_nodes_body(char *, uint32_t);
 
-static int build_all_body(char *, olsr_u32_t);
+static int build_all_body(char *, uint32_t);
 
-static int build_about_body(char *, olsr_u32_t);
+static int build_about_body(char *, uint32_t);
 
-static int build_cfgfile_body(char *, olsr_u32_t);
+static int build_cfgfile_body(char *, uint32_t);
 
 static int check_allowed_ip(const struct allowed_net *const allowed_nets, const union olsr_ip_addr *const addr);
 
-static int build_ip_txt(char *buf, const olsr_u32_t bufsize, const olsr_bool want_link, const char *const ipaddrstr,
-                        const int prefix_len);
+static int build_ip_txt(char *buf, const uint32_t bufsize, const bool want_link, const char *const ipaddrstr, const int prefix_len);
 
-static int build_ipaddr_link(char *buf, const olsr_u32_t bufsize, const olsr_bool want_link, const union olsr_ip_addr *const ipaddr,
+static int build_ipaddr_link(char *buf, const uint32_t bufsize, const bool want_link, const union olsr_ip_addr *const ipaddr,
                              const int prefix_len);
-static int section_title(char *buf, olsr_u32_t bufsize, const char *title);
+static int section_title(char *buf, uint32_t bufsize, const char *title);
 
 static ssize_t writen(int fd, const void *buf, size_t count);
 
@@ -209,16 +208,16 @@
 #endif
 
 static const struct tab_entry tab_entries[] = {
-  {"Configuration", "config", build_config_body, OLSR_TRUE},
-  {"Routes", "routes", build_routes_body, OLSR_TRUE},
-  {"Links/Topology", "nodes", build_nodes_body, OLSR_TRUE},
-  {"All", "all", build_all_body, OLSR_TRUE},
+  {"Configuration", "config", build_config_body, true},
+  {"Routes", "routes", build_routes_body, true},
+  {"Links/Topology", "nodes", build_nodes_body, true},
+  {"All", "all", build_all_body, true},
 #ifdef ADMIN_INTERFACE
-  {"Admin", "admin", build_admin_body, OLSR_TRUE},
+  {"Admin", "admin", build_admin_body, true},
 #endif
-  {"About", "about", build_about_body, OLSR_TRUE},
-  {"FOO", "cfgfile", build_cfgfile_body, OLSR_FALSE},
-  {NULL, NULL, NULL, OLSR_FALSE}
+  {"About", "about", build_about_body, true},
+  {"FOO", "cfgfile", build_cfgfile_body, false},
+  {NULL, NULL, NULL, false}
 };
 
 static const struct static_bin_file_entry static_bin_files[] = {
@@ -247,7 +246,7 @@
 get_http_socket(int port)
 {
   struct sockaddr_in sin;
-  olsr_u32_t yes = 1;
+  uint32_t yes = 1;
 
   /* Init ipc socket */
   int s = socket(AF_INET, SOCK_STREAM, 0);
@@ -384,7 +383,7 @@
     while (dynamic_files[i].filename) {
       printf("POST checking %s\n", dynamic_files[i].filename);
       if (FILENREQ_MATCH(filename, dynamic_files[i].filename)) {
-        olsr_u32_t param_size;
+        uint32_t param_size;
 
         stats.ok_hits++;
 
@@ -395,7 +394,7 @@
 
         //memcpy(body, dynamic_files[i].data, static_bin_files[i].data_size);
         size += dynamic_files[i].process_data_cb(req, param_size, &body[size], sizeof(body) - size);
-        c = build_http_header(HTTP_OK, OLSR_TRUE, size, req, sizeof(req));
+        c = build_http_header(HTTP_OK, true, size, req, sizeof(req));
         goto send_http_data;
       }
       i++;
@@ -404,7 +403,7 @@
     /* We only support GET */
     strscpy(body, HTTP_400_MSG, sizeof(body));
     stats.ill_hits++;
-    c = build_http_header(HTTP_BAD_REQ, OLSR_TRUE, strlen(body), req, sizeof(req));
+    c = build_http_header(HTTP_BAD_REQ, true, strlen(body), req, sizeof(req));
   } else if (!strcmp(req_type, "GET")) {
     int i = 0;
 
@@ -418,7 +417,7 @@
       stats.ok_hits++;
       memcpy(body, static_bin_files[i].data, static_bin_files[i].data_size);
       size = static_bin_files[i].data_size;
-      c = build_http_header(HTTP_OK, OLSR_FALSE, size, req, sizeof(req));
+      c = build_http_header(HTTP_OK, false, size, req, sizeof(req));
       goto send_http_data;
     }
 
@@ -433,7 +432,7 @@
     if (static_txt_files[i].filename) {
       stats.ok_hits++;
       size += snprintf(&body[size], sizeof(body) - size, "%s", static_txt_files[i].data);
-      c = build_http_header(HTTP_OK, OLSR_FALSE, size, req, sizeof(req));
+      c = build_http_header(HTTP_OK, false, size, req, sizeof(req));
       goto send_http_data;
     }
 
@@ -449,7 +448,7 @@
 
     if (tab_entries[i].filename) {
 #ifdef NETDIRECT
-      c = build_http_header(HTTP_OK, OLSR_TRUE, size, req, sizeof(req));
+      c = build_http_header(HTTP_OK, true, size, req, sizeof(req));
       r = send(client_sockets[curr_clients], req, c, 0);
       if (r < 0) {
         olsr_printf(1, "(HTTPINFO) Failed sending data to client!\n");
@@ -466,10 +465,10 @@
                  "<link rel=\"shortcut icon\" href=\"favicon.ico\" type=\"image/x-icon\">\n"
                  "<link rel=\"stylesheet\" type=\"text/css\" href=\"httpinfo.css\">\n" "</head>\n"
                  "<body bgcolor=\"#ffffff\" text=\"#000000\">\n"
-                 "<table align=\"center\" border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"%d\">\n"
+                 "<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" width=\"%d\">\n"
                  "<tbody><tr bgcolor=\"#ffffff\">\n" "<td align=\"left\" height=\"69\" valign=\"middle\" width=\"80%%\">\n"
                  "<font color=\"black\" face=\"timesroman\" size=\"6\">&nbsp;&nbsp;&nbsp;<a href=\"http://www.olsr.org/\">olsr.org OLSR daemon</a></font></td>\n"
-                 "<td align=\"right\" height=\"69\" valign=\"middle\" width=\"20%%\">\n"
+                 "<td height=\"69\" valign=\"middle\" width=\"20%%\">\n"
                  "<a href=\"http://www.olsr.org/\"><img border=\"0\" src=\"/logo.gif\" alt=\"olsrd logo\"></a></td>\n" "</tr>\n"
                  "</tbody>\n" "</table>\n", FRAMEWIDTH);
 
@@ -487,19 +486,19 @@
       netsprintf_direct = 1;
       goto close_connection;
 #else
-      c = build_http_header(HTTP_OK, OLSR_TRUE, size, req, sizeof(req));
+      c = build_http_header(HTTP_OK, true, size, req, sizeof(req));
       goto send_http_data;
 #endif
     }
 
     stats.ill_hits++;
     strscpy(body, HTTP_404_MSG, sizeof(body));
-    c = build_http_header(HTTP_BAD_FILE, OLSR_TRUE, strlen(body), req, sizeof(req));
+    c = build_http_header(HTTP_BAD_FILE, true, strlen(body), req, sizeof(req));
   } else {
     /* We only support GET */
     strscpy(body, HTTP_400_MSG, sizeof(body));
     stats.ill_hits++;
-    c = build_http_header(HTTP_BAD_REQ, OLSR_TRUE, strlen(body), req, sizeof(req));
+    c = build_http_header(HTTP_BAD_REQ, true, strlen(body), req, sizeof(req));
   }
 
 send_http_data:
@@ -523,7 +522,7 @@
 }
 
 int
-build_http_header(http_header_type type, olsr_bool is_html, olsr_u32_t msgsize, char *buf, olsr_u32_t bufsize)
+build_http_header(http_header_type type, bool is_html, uint32_t msgsize, char *buf, uint32_t bufsize)
 {
   time_t currtime;
   const char *h;
@@ -578,7 +577,7 @@
 }
 
 static int
-build_tabs(char *buf, const olsr_u32_t bufsize, int active)
+build_tabs(char *buf, const uint32_t bufsize, int active)
 {
   int size = 0, tabs = 0;
 
@@ -610,7 +609,7 @@
 }
 
 static int
-section_title(char *buf, olsr_u32_t bufsize, const char *title)
+section_title(char *buf, uint32_t bufsize, const char *title)
 {
   return snprintf(buf, bufsize,
                   "<h2>%s</h2>\n" "<table width=\"100%%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" align=\"center\">\n",
@@ -618,7 +617,7 @@
 }
 
 static int
-build_frame(char *buf, olsr_u32_t bufsize, const char *title __attribute__ ((unused)), const char *link
+build_frame(char *buf, uint32_t bufsize, const char *title __attribute__ ((unused)), const char *link
             __attribute__ ((unused)), int width __attribute__ ((unused)), build_body_callback frame_body_cb)
 {
   int size = 0;
@@ -629,13 +628,13 @@
 }
 
 static int
-fmt_href(char *buf, const olsr_u32_t bufsize, const char *const ipaddr)
+fmt_href(char *buf, const uint32_t bufsize, const char *const ipaddr)
 {
   return snprintf(buf, bufsize, "<a href=\"http://%s:%d/all\">", ipaddr, http_port);
 }
 
 static int
-build_ip_txt(char *buf, const olsr_u32_t bufsize, const olsr_bool print_link, const char *const ipaddrstr, const int prefix_len)
+build_ip_txt(char *buf, const uint32_t bufsize, const bool print_link, const char *const ipaddrstr, const int prefix_len)
 {
   int size = 0;
 
@@ -656,7 +655,7 @@
 }
 
 static int
-build_ipaddr_link(char *buf, const olsr_u32_t bufsize, const olsr_bool want_link, const union olsr_ip_addr *const ipaddr,
+build_ipaddr_link(char *buf, const uint32_t bufsize, const bool want_link, const union olsr_ip_addr *const ipaddr,
                   const int prefix_len)
 {
   int size = 0;
@@ -694,12 +693,12 @@
 }
 
 #define build_ipaddr_with_link(buf, bufsize, ipaddr, plen) \
-          build_ipaddr_link((buf), (bufsize), OLSR_TRUE, (ipaddr), (plen))
+          build_ipaddr_link((buf), (bufsize), true, (ipaddr), (plen))
 #define build_ipaddr_no_link(buf, bufsize, ipaddr, plen) \
-          build_ipaddr_link((buf), (bufsize), OLSR_FALSE, (ipaddr), (plen))
+          build_ipaddr_link((buf), (bufsize), false, (ipaddr), (plen))
 
 static int
-build_route(char *buf, olsr_u32_t bufsize, const struct rt_entry *rt)
+build_route(char *buf, uint32_t bufsize, const struct rt_entry *rt)
 {
   int size = 0;
   struct lqtextbuffer lqbuffer;
@@ -708,18 +707,18 @@
   size += build_ipaddr_with_link(&buf[size], bufsize - size, &rt->rt_dst.prefix, rt->rt_dst.prefix_len);
   size += build_ipaddr_with_link(&buf[size], bufsize - size, &rt->rt_best->rtp_nexthop.gateway, -1);
 
-  size += snprintf(&buf[size], bufsize - size, "<td align=\"center\">%d</td>", rt->rt_best->rtp_metric.hops);
+  size += snprintf(&buf[size], bufsize - size, "<td>%d</td>", rt->rt_best->rtp_metric.hops);
   size +=
-    snprintf(&buf[size], bufsize - size, "<td align=\"right\">%s</td>",
-             get_linkcost_text(rt->rt_best->rtp_metric.cost, OLSR_TRUE, &lqbuffer));
+    snprintf(&buf[size], bufsize - size, "<td>%s</td>",
+             get_linkcost_text(rt->rt_best->rtp_metric.cost, true, &lqbuffer));
   size +=
-    snprintf(&buf[size], bufsize - size, "<td align=\"center\">%s</td></tr>\n",
+    snprintf(&buf[size], bufsize - size, "<td>%s</td></tr>\n",
              if_ifwithindex_name(rt->rt_best->rtp_nexthop.iif_index));
   return size;
 }
 
 static int
-build_routes_body(char *buf, olsr_u32_t bufsize)
+build_routes_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
   struct rt_entry *rt;
@@ -727,7 +726,7 @@
   size += section_title(&buf[size], bufsize - size, "OLSR Routes in Kernel");
   size +=
     snprintf(&buf[size], bufsize - size,
-             "<tr><th align=\"center\"%s>Destination</th><th align=\"center\"%s>Gateway</th><th>Metric</th><th align=\"right\">ETX</th><th>Interface</th></tr>\n",
+             "<tr><th%s>Destination</th><th%s>Gateway</th><th>Metric</th><th>ETX</th><th>Interface</th></tr>\n",
              colspan, colspan);
 
   /* Walk the route table */
@@ -741,7 +740,7 @@
 }
 
 static int
-build_config_body(char *buf, olsr_u32_t bufsize)
+build_config_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
   const struct olsr_if *ifs;
@@ -910,7 +909,7 @@
 }
 
 static int
-build_neigh_body(char *buf, olsr_u32_t bufsize)
+build_neigh_body(char *buf, uint32_t bufsize)
 {
   struct neighbor_entry *neigh;
   struct link_entry *link = NULL;
@@ -921,10 +920,10 @@
 
   size +=
     snprintf(&buf[size], bufsize - size,
-             "<tr><th align=\"center\"%s>Local IP</th><th align=\"center\"%s>Remote IP</th><th align=\"right\">Hysteresis</th>",
+             "<tr><th%s>Local IP</th><th%s>Remote IP</th><th>Hysteresis</th>",
              colspan, colspan);
   if (olsr_cnf->lq_level > 0) {
-    size += snprintf(&buf[size], bufsize - size, "<th align=\"right\">LinkCost</th>");
+    size += snprintf(&buf[size], bufsize - size, "<th>LinkCost</th>");
   }
   size += snprintf(&buf[size], bufsize - size, "</tr>\n");
 
@@ -933,12 +932,12 @@
     size += snprintf(&buf[size], bufsize - size, "<tr>");
     size += build_ipaddr_with_link(&buf[size], bufsize, &link->local_iface_addr, -1);
     size += build_ipaddr_with_link(&buf[size], bufsize, &link->neighbor_iface_addr, -1);
-    size += snprintf(&buf[size], bufsize - size, "<td align=\"right\">%0.2f</td>", link->L_link_quality);
+    size += snprintf(&buf[size], bufsize - size, "<td>%0.2f</td>", link->L_link_quality);
     if (olsr_cnf->lq_level > 0) {
       struct lqtextbuffer lqbuffer1, lqbuffer2;
       size +=
-        snprintf(&buf[size], bufsize - size, "<td align=\"right\">(%s) %s</td>", get_link_entry_text(link, '/', &lqbuffer1),
-                 get_linkcost_text(link->linkcost, OLSR_FALSE, &lqbuffer2));
+        snprintf(&buf[size], bufsize - size, "<td>(%s) %s</td>", get_link_entry_text(link, '/', &lqbuffer1),
+                 get_linkcost_text(link->linkcost, false, &lqbuffer2));
     }
     size += snprintf(&buf[size], bufsize - size, "</tr>\n");
   } OLSR_FOR_ALL_LINK_ENTRIES_END(link);
@@ -948,7 +947,7 @@
   size += section_title(&buf[size], bufsize - size, "Neighbors");
   size +=
     snprintf(&buf[size], bufsize - size,
-             "<tr><th align=\"center\"%s>IP Address</th><th align=\"center\">SYM</th><th align=\"center\">MPR</th><th align=\"center\">MPRS</th><th align=\"center\">Willingness</th><th>2 Hop Neighbors</th></tr>\n",
+             "<tr><th%s>IP Address</th><th>SYM</th><th>MPR</th><th>MPRS</th><th>Willingness</th><th>2 Hop Neighbors</th></tr>\n",
              colspan);
   /* Neighbors */
   OLSR_FOR_ALL_NBR_ENTRIES(neigh) {
@@ -959,8 +958,8 @@
     size += build_ipaddr_with_link(&buf[size], bufsize, &neigh->neighbor_main_addr, -1);
     size +=
       snprintf(&buf[size], bufsize - size,
-               "<td align=\"center\">%s</td>" "<td align=\"center\">%s</td>" "<td align=\"center\">%s</td>"
-               "<td align=\"center\">%d</td>", (neigh->status == SYM) ? "YES" : "NO", neigh->is_mpr ? "YES" : "NO",
+               "<td>%s</td>" "<td>%s</td>" "<td>%s</td>"
+               "<td>%d</td>", (neigh->status == SYM) ? "YES" : "NO", neigh->is_mpr ? "YES" : "NO",
                olsr_lookup_mprs_set(&neigh->neighbor_main_addr) ? "YES" : "NO", neigh->willingness);
 
     size += snprintf(&buf[size], bufsize - size, "<td><select>\n" "<option>IP ADDRESS</option>\n");
@@ -979,7 +978,7 @@
 }
 
 static int
-build_topo_body(char *buf, olsr_u32_t bufsize)
+build_topo_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
   struct tc_entry *tc;
@@ -987,10 +986,10 @@
 
   size += section_title(&buf[size], bufsize - size, "Topology Entries");
   size +=
-    snprintf(&buf[size], bufsize - size, "<tr><th align=\"center\"%s>Destination IP</th><th align=\"center\"%s>Last Hop IP</th>",
+    snprintf(&buf[size], bufsize - size, "<tr><th%s>Destination IP</th><th%s>Last Hop IP</th>",
              colspan, colspan);
   if (olsr_cnf->lq_level > 0) {
-    size += snprintf(&buf[size], bufsize - size, "<th align=\"right\">Linkcost</th>");
+    size += snprintf(&buf[size], bufsize - size, "<th>Linkcost</th>");
   }
   size += snprintf(&buf[size], bufsize - size, "</tr>\n");
 
@@ -1004,8 +1003,8 @@
         if (olsr_cnf->lq_level > 0) {
           struct lqtextbuffer lqbuffer1, lqbuffer2;
           size +=
-            snprintf(&buf[size], bufsize - size, "<td align=\"right\">(%s) %s</td>\n",
-                     get_tc_edge_entry_text(tc_edge, '/', &lqbuffer1), get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer2));
+            snprintf(&buf[size], bufsize - size, "<td>(%s) %s</td>\n",
+                     get_tc_edge_entry_text(tc_edge, '/', &lqbuffer1), get_linkcost_text(tc_edge->cost, false, &lqbuffer2));
         }
         size += snprintf(&buf[size], bufsize - size, "</tr>\n");
       }
@@ -1018,14 +1017,14 @@
 }
 
 static int
-build_mid_body(char *buf, olsr_u32_t bufsize)
+build_mid_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
   int idx;
   const char *colspan = resolve_ip_addresses ? " colspan=\"2\"" : "";
 
   size += section_title(&buf[size], bufsize - size, "MID Entries");
-  size += snprintf(&buf[size], bufsize - size, "<tr><th align=\"center\"%s>Main Address</th><th>Aliases</th></tr>\n", colspan);
+  size += snprintf(&buf[size], bufsize - size, "<tr><th%s>Main Address</th><th>Aliases</th></tr>\n", colspan);
 
   /* MID */
   for (idx = 0; idx < HASHSIZE; idx++) {
@@ -1050,7 +1049,7 @@
 }
 
 static int
-build_nodes_body(char *buf, olsr_u32_t bufsize)
+build_nodes_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
 
@@ -1062,7 +1061,7 @@
 }
 
 static int
-build_all_body(char *buf, olsr_u32_t bufsize)
+build_all_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
 
@@ -1076,7 +1075,7 @@
 }
 
 static int
-build_about_body(char *buf, olsr_u32_t bufsize)
+build_about_body(char *buf, uint32_t bufsize)
 {
   return snprintf(buf, bufsize,
                   "<strong>" PLUGIN_NAME " version " PLUGIN_VERSION "</strong><br/>\n" "by Andreas T&oslash;nnesen (C)2005.<br/>\n"
@@ -1117,7 +1116,7 @@
 }
 
 static int
-build_cfgfile_body(char *buf, olsr_u32_t bufsize)
+build_cfgfile_body(char *buf, uint32_t bufsize)
 {
   int size = 0;
 
diff -r feb3d7883ff0 -r d73e73400732 lib/httpinfo/src/olsrd_httpinfo.h
--- a/lib/httpinfo/src/olsrd_httpinfo.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/httpinfo/src/olsrd_httpinfo.h	Fri Mar 13 19:16:23 2009 +0100
@@ -66,10 +66,10 @@
 } http_header_type;
 
 struct http_stats {
-  olsr_u32_t ok_hits;
-  olsr_u32_t dyn_hits;
-  olsr_u32_t err_hits;
-  olsr_u32_t ill_hits;
+  uint32_t ok_hits;
+  uint32_t dyn_hits;
+  uint32_t err_hits;
+  uint32_t ill_hits;
 };
 
 extern struct olsrd_config *olsr_cfg;
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/Makefile
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/Makefile	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,66 @@
+#
+# OLSR Basic Multicast Forwarding (BMF) plugin.
+# Copyright (c) 2005, 2006, Thales Communications, Huizen, The Netherlands.
+# Written by Erik Tromp.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# * Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+# * Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in
+#   the documentation and/or other materials provided with the
+#   distribution.
+# * Neither the name of Thales, BMF nor the names of its
+#   contributors may be used to endorse or promote products derived
+#   from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+# POSSIBILITY OF SUCH DAMAGE.
+#
+
+OLSRD_PLUGIN =	true
+PLUGIN_NAME =	olsrd_mdns
+PLUGIN_VER =	1.0.0
+
+TOPDIR = ../..
+include $(TOPDIR)/Makefile.inc
+
+LIBS +=	$(OS_LIB_PTHREAD)
+
+# Must be specified along with -lpthread on linux
+CPPFLAGS += $(OS_CFLAG_PTHREAD)
+
+ifneq ($(OS),linux)
+
+default_target install clean:
+	@echo "*** BMF Plugin only supported on Linux, sorry!"
+
+else
+
+default_target: $(PLUGIN_FULLNAME)
+
+$(PLUGIN_FULLNAME): $(OBJS) version-script.txt
+		$(CC) $(LDFLAGS) -o $(PLUGIN_FULLNAME) $(OBJS) $(LIBS)
+
+install:	$(PLUGIN_FULLNAME)
+		$(STRIP) $(PLUGIN_FULLNAME)
+		$(INSTALL_LIB)
+
+clean:
+		rm -f $(OBJS) $(SRCS:%.c=%.d) $(PLUGIN_FULLNAME)
+
+endif
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/Address.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/Address.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,164 @@
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : Address.c
+ * Description: IP packet characterization functions
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "Address.h"
+
+/* System includes */
+#include <stddef.h> /* NULL */
+#include <string.h> /* strcmp */
+#include <assert.h> /* assert() */
+#include <netinet/ip.h> /* struct ip */
+#include <netinet/udp.h> /* struct udphdr */
+
+/* OLSRD includes */
+#include "defs.h" /* ipequal */
+#include "olsr_protocol.h" /* OLSRPORT */
+
+/* Plugin includes */
+#include "mdns.h" /* BMF_ENCAP_PORT */
+#include "NetworkInterfaces.h" /* TBmfInterface */
+
+/* Whether or not to flood local broadcast packets (e.g. packets with IP
+ * destination 192.168.1.255). May be overruled by setting the plugin
+ * parameter "DoLocalBroadcast" to "no" */
+int EnableLocalBroadcast = 1;
+
+/* -------------------------------------------------------------------------
+ * Function   : DoLocalBroadcast
+ * Description: Overrule the default setting, enabling or disabling the
+ *              flooding of local broadcast packets
+ * Input      : enable - either "yes" or "no"
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int DoLocalBroadcast(
+  const char* enable,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+  if (strcmp(enable, "yes") == 0)
+  {
+    EnableLocalBroadcast = 1;
+    return 0;
+  }
+  else if (strcmp(enable, "no") == 0)
+  {
+    EnableLocalBroadcast = 0;
+    return 0;
+  }
+
+  /* Value not recognized */
+  return 1;
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : IsMulticast
+ * Description: Check if an IP address is a multicast address
+ * Input      : ipAddress
+ * Output     : none
+ * Return     : true (1) or false (0)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int IsMulticast(union olsr_ip_addr* ipAddress)
+{
+  assert(ipAddress != NULL);
+
+  return (ntohl(ipAddress->v4.s_addr) & 0xF0000000) == 0xE0000000;
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : IsOlsrOrBmfPacket
+ * Description: Check if an IP packet is either an OLSR packet or a BMF packet
+ * Input      : ipPacket
+ * Output     : none
+ * Return     : true (1) or false (0)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+//int IsOlsrOrBmfPacket(unsigned char* ipPacket)
+//{//MODIFICATA
+//  struct ip* ipHeader;
+//  unsigned int ipHeaderLen;
+//  struct udphdr* udpHeader;
+//  u_int16_t destPort;
+//
+//  assert(ipPacket != NULL);
+//
+//  /* OLSR packets are UDP - port 698
+//   * OLSR-BMF packets are UDP - port 50698
+//   * OLSR-Autodetect probe packets are UDP - port 51698 */
+//
+//  /* Check if UDP */
+//  ipHeader = (struct ip*) ipPacket;
+//  if (ipHeader->ip_p != SOL_UDP)
+//  {
+//    /* Not UDP */
+//    return 0;
+//  }
+//
+//  /* The total length must be at least large enough to store the UDP header */
+//  ipHeaderLen = GetIpHeaderLength(ipPacket);
+//  if (GetIpTotalLength(ipPacket) < ipHeaderLen + sizeof(struct udphdr))
+//  {
+//    /* Not long enough */
+//    return 0;
+//  }
+//
+//  /* Go into the UDP header and check port number */
+//  udpHeader = (struct udphdr*) (ipPacket + ipHeaderLen);
+//  destPort = ntohs(udpHeader->dest);
+//
+//  //if (destPort == OLSRPORT || destPort == BMF_ENCAP_PORT || destPort == 51698)
+//  if (destPort == 5353)
+//      /* TODO: #define for 51698 */
+//  {
+//    return 1;
+//  }
+//
+//  return 0;
+//}
+//
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/Address.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/Address.h	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,62 @@
+#ifndef _BMF_ADDRESS_H
+#define _BMF_ADDRESS_H
+
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : Address.h
+ * Description: IP packet characterization functions
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "olsr_types.h" /* olsr_ip_addr */
+#include "olsrd_plugin.h"     /* union set_plugin_parameter_addon */
+#include "interfaces.h" /* struct interface */
+
+struct TBmfInterface;
+
+extern int EnableLocalBroadcast;
+
+int DoLocalBroadcast(const char* enable, void* data, set_plugin_parameter_addon addon);
+int IsMulticast(union olsr_ip_addr* ipAddress);
+int IsOlsrOrBmfPacket(unsigned char* ipPacket);
+
+#endif /* _BMF_ADDRESS_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/NetworkInterfaces.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/NetworkInterfaces.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,1703 @@
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : NetworkInterfaces.c
+ * Description: Functions to open and close sockets
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "NetworkInterfaces.h"
+
+/* System includes */
+#include <stddef.h> /* NULL */
+#include <syslog.h> /* syslog() */
+#include <string.h> /* strerror(), strchr(), strcmp() */
+#include <errno.h> /* errno */
+#include <unistd.h> /* close() */
+#include <sys/ioctl.h> /* ioctl() */
+#include <fcntl.h> /* fcntl() */
+#include <assert.h> /* assert() */
+#include <net/if.h> /* socket(), ifreq, if_indextoname(), if_nametoindex() */
+#include <netinet/in.h> /* htons() */
+#include <linux/if_ether.h> /* ETH_P_IP */
+#include <linux/if_packet.h> /* packet_mreq, PACKET_MR_PROMISC, PACKET_ADD_MEMBERSHIP */
+#include <linux/if_tun.h> /* IFF_TAP */
+#include <netinet/ip.h> /* struct ip */
+#include <netinet/udp.h> /* SOL_UDP */
+#include <stdlib.h> /* atoi, malloc */
+
+/* OLSRD includes */
+#include "olsr.h" /* OLSR_PRINTF() */
+#include "ipcalc.h"
+#include "defs.h" /* olsr_cnf */
+#include "link_set.h" /* get_link_set() */
+#include "tc_set.h" /* olsr_lookup_tc_entry(), olsr_lookup_tc_edge() */
+#include "net_olsr.h" /* ipequal */
+#include "lq_plugin.h"
+
+
+/* Plugin includes */
+#include "Packet.h" /* IFHWADDRLEN */
+#include "mdns.h" /* PLUGIN_NAME, MainAddressOf() */
+#include "Address.h" /* IsMulticast() */
+
+/* List of network interface objects used by BMF plugin */
+struct TBmfInterface* BmfInterfaces = NULL;
+struct TBmfInterface* LastBmfInterface = NULL;
+
+/* Highest-numbered open socket file descriptor. To be used as first
+ * parameter in calls to select(...). */
+int HighestSkfd = -1;
+
+/* Set of socket file descriptors */
+fd_set InputSet;
+
+/* File descriptor of EtherTunTap interface */
+int EtherTunTapFd = -1;
+
+/* Network interface name of EtherTunTap interface. May be overruled by
+ * setting the plugin parameter "BmfInterface". */
+char EtherTunTapIfName[IFNAMSIZ] = "bmf0";
+
+/* The underlying mechanism to forward multicast packets. Either:
+ * - BM_BROADCAST: BMF uses the IP local broadcast as destination address
+ * - BM_UNICAST_PROMISCUOUS: BMF uses the IP address of the best neighbor as
+ *   destination address. The other neighbors listen promiscuously. */
+enum TBmfMechanism BmfMechanism = BM_BROADCAST;
+
+#define ETHERTUNTAPIPNOTSET 0
+
+/* The IP address of the BMF network interface in host byte order.
+ * May be overruled by setting the plugin parameter "BmfInterfaceIp". */
+u_int32_t EtherTunTapIp = ETHERTUNTAPIPNOTSET;
+
+/* 255.255.255.255 in host byte order. May be overruled by
+ * setting the plugin parameter "BmfInterfaceIp". */
+u_int32_t EtherTunTapIpMask = 0xFFFFFFFF;
+
+/* The IP broadcast address of the BMF network interface in host byte order.
+ * May be overruled by setting the plugin parameter "BmfinterfaceIp". */
+u_int32_t EtherTunTapIpBroadcast = ETHERTUNTAPIPNOTSET;
+
+/* Whether or not the configuration has overruled the default IP
+ * configuration of the EtherTunTap interface */
+int TunTapIpOverruled = 0;
+
+/* Whether or not to capture packets on the OLSR-enabled
+ * interfaces (in promiscuous mode). May be overruled by setting the plugin
+ * parameter "CapturePacketsOnOlsrInterfaces" to "yes". */
+int CapturePacketsOnOlsrInterfaces = 0;
+
+/* -------------------------------------------------------------------------
+ * Function   : SetBmfInterfaceName
+ * Description: Overrule the default network interface name ("bmf0") of the
+ *              EtherTunTap interface
+ * Input      : ifname - network interface name (e.g. "mybmf0")
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : EtherTunTapIfName
+ * ------------------------------------------------------------------------- */
+int SetBmfInterfaceName(
+  const char* ifname,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+  strncpy(EtherTunTapIfName, ifname, IFNAMSIZ - 1);
+  EtherTunTapIfName[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+  return 0;
+} /* SetBmfInterfaceName */
+
+/* -------------------------------------------------------------------------
+ * Function   : SetBmfInterfaceIp
+ * Description: Overrule the default IP address and prefix length
+ *              ("10.255.255.253/30") of the EtherTunTap interface
+ * Input      : ip - IP address string, followed by '/' and prefix length
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : EtherTunTapIp, EtherTunTapIpMask, EtherTunTapIpBroadcast,
+ *              TunTapIpOverruled
+ * ------------------------------------------------------------------------- */
+int SetBmfInterfaceIp(
+  const char* ip,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+#define IPV4_MAX_ADDRLEN 16
+#define IPV4_MAX_PREFIXLEN 32
+  char* slashAt;
+  char ipAddr[IPV4_MAX_ADDRLEN];
+  struct in_addr sinaddr;
+  int prefixLen;
+  int i;
+
+  /* Inspired by function str2prefix_ipv4 as found in Quagga source
+   * file lib/prefix.c */
+
+  /* Find slash inside string. */
+  slashAt = strchr(ip, '/');
+
+  /* String doesn't contain slash. */
+  if (slashAt == NULL || slashAt - ip >= IPV4_MAX_ADDRLEN)
+  {
+    /* No prefix length specified, or IP address too long */
+    return 1;
+  }
+
+  strncpy(ipAddr, ip, slashAt - ip);
+  *(ipAddr + (slashAt - ip)) = '\0';
+  if (inet_aton(ipAddr, &sinaddr) == 0)
+  {
+    /* Invalid address passed */
+    return 1;
+  }
+
+  EtherTunTapIp = ntohl(sinaddr.s_addr);
+
+  /* Get prefix length. */
+  prefixLen = atoi(++slashAt);
+  if (prefixLen <= 0 || prefixLen > IPV4_MAX_PREFIXLEN)
+  {
+    return 1;
+  }
+
+  /* Compose IP subnet mask in host byte order */
+  EtherTunTapIpMask = 0;
+  for (i = 0; i < prefixLen; i++)
+  {
+    EtherTunTapIpMask |= (1 << (IPV4_MAX_PREFIXLEN - 1 - i));
+  }
+
+  /* Compose IP broadcast address in host byte order */
+  EtherTunTapIpBroadcast = EtherTunTapIp;
+  for (i = prefixLen; i < IPV4_MAX_PREFIXLEN; i++)
+  {
+    EtherTunTapIpBroadcast |= (1 << (IPV4_MAX_PREFIXLEN - 1 - i));
+  }
+
+  TunTapIpOverruled = 1;
+
+  return 0;
+} /* SetBmfInterfaceIp */
+
+/* -------------------------------------------------------------------------
+ * Function   : SetCapturePacketsOnOlsrInterfaces
+ * Description: Overrule the default setting, enabling or disabling the
+ *              capturing of packets on OLSR-enabled interfaces.
+ * Input      : enable - either "yes" or "no"
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int SetCapturePacketsOnOlsrInterfaces(
+  const char* enable,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+  if (strcmp(enable, "yes") == 0)
+  {
+    CapturePacketsOnOlsrInterfaces = 1;
+    return 0;
+  }
+  else if (strcmp(enable, "no") == 0)
+  {
+    CapturePacketsOnOlsrInterfaces = 0;
+    return 0;
+  }
+
+  /* Value not recognized */
+  return 1;
+} /* SetCapturePacketsOnOlsrInterfaces */
+
+/* -------------------------------------------------------------------------
+ * Function   : SetBmfMechanism
+ * Description: Overrule the default BMF mechanism to either BM_BROADCAST or
+ *              BM_UNICAST_PROMISCUOUS.
+ * Input      : mechanism - either "Broadcast" or "UnicastPromiscuous"
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int SetBmfMechanism(
+  const char* mechanism,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+  if (strcmp(mechanism, "Broadcast") == 0)
+  {
+    BmfMechanism = BM_BROADCAST;
+    return 0;
+  }
+  else if (strcmp(mechanism, "UnicastPromiscuous") == 0)
+  {
+    BmfMechanism = BM_UNICAST_PROMISCUOUS;
+    return 0;
+  }
+
+  /* Value not recognized */
+  return 1;
+} /* SetBmfMechanism */
+
+/* -------------------------------------------------------------------------
+ * Function   : AddDescriptorToInputSet
+ * Description: Add a socket descriptor to the global set of socket file descriptors
+ * Input      : skfd - socket file descriptor
+ * Output     : none
+ * Return     : none
+ * Data Used  : HighestSkfd, InputSet
+ * Notes      : Keeps track of the highest-numbered descriptor
+ * ------------------------------------------------------------------------- */
+static void AddDescriptorToInputSet(int skfd)
+{
+  /* Keep the highest-numbered descriptor */
+  if (skfd > HighestSkfd)
+  {
+    HighestSkfd = skfd;
+  }
+
+  /* Add descriptor to input set */
+  FD_SET(skfd, &InputSet);
+} /* AddDescriptorToInputSet */
+
+/* To save the state of the IP spoof filter for the EtherTunTap interface */
+static char EthTapSpoofState = '1';
+
+/* -------------------------------------------------------------------------
+ * Function   : DeactivateSpoofFilter
+ * Description: Deactivates the Linux anti-spoofing filter for the tuntap
+ *              interface
+ * Input      : none
+ * Output     : none
+ * Return     : fail (0) or success (1)
+ * Data Used  : EtherTunTapIfName, EthTapSpoofState
+ * Notes      : Saves the current filter state for later restoring
+ * ------------------------------------------------------------------------- */
+int DeactivateSpoofFilter(void)
+{
+  FILE* procSpoof;
+  char procFile[FILENAME_MAX];
+
+  /* Generate the procfile name */
+  sprintf(procFile, "/proc/sys/net/ipv4/conf/%s/rp_filter", EtherTunTapIfName);
+
+  /* Open procfile for reading */
+  procSpoof = fopen(procFile, "r");
+  if (procSpoof == NULL)
+  {
+    fprintf(
+      stderr,
+      "WARNING! Could not open the %s file to check/disable the IP spoof filter!\n"
+      "Are you using the procfile filesystem?\n"
+      "Does your system support IPv4?\n"
+      "I will continue (in 3 sec) - but you should manually ensure that IP spoof\n"
+      "filtering is disabled!\n\n",
+      procFile);
+
+    sleep(3);
+    return 0;
+  }
+
+  EthTapSpoofState = fgetc(procSpoof);
+  fclose(procSpoof);
+
+  /* Open procfile for writing */
+  procSpoof = fopen(procFile, "w");
+  if (procSpoof == NULL)
+  {
+    fprintf(stderr, "Could not open %s for writing!\n", procFile);
+    fprintf(
+      stderr,
+      "I will continue (in 3 sec) - but you should manually ensure that IP"
+      " spoof filtering is disabled!\n\n");
+    sleep(3);
+    return 0;
+  }
+
+  syslog(LOG_INFO, "Writing \"0\" to %s", procFile);
+  fputs("0", procSpoof);
+
+  fclose(procSpoof);
+
+  return 1;
+} /* DeactivateSpoofFilter */
+
+/* -------------------------------------------------------------------------
+ * Function   : RestoreSpoofFilter
+ * Description: Restores the Linux anti-spoofing filter setting for the tuntap
+ *              interface
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : EtherTunTapIfName, EthTapSpoofState
+ * ------------------------------------------------------------------------- */
+void RestoreSpoofFilter(void)
+{
+  FILE* procSpoof;
+  char procFile[FILENAME_MAX];
+
+  /* Generate the procfile name */
+  sprintf(procFile, "/proc/sys/net/ipv4/conf/%s/rp_filter", EtherTunTapIfName);
+
+  /* Open procfile for writing */
+  procSpoof = fopen(procFile, "w");
+  if (procSpoof == NULL)
+  {
+    fprintf(stderr, "Could not open %s for writing!\nSettings not restored!\n", procFile);
+  }
+  else
+  {
+    syslog(LOG_INFO, "Resetting %s to %c\n", procFile, EthTapSpoofState);
+
+    fputc(EthTapSpoofState, procSpoof);
+    fclose(procSpoof);
+  }
+} /* RestoreSpoofFilter */
+
+/* -------------------------------------------------------------------------
+ * Function   : FindNeighbors
+ * Description: Find the neighbors on a network interface to forward a BMF
+ *              packet to
+ * Input      : intf - the network interface
+ *              source - the source IP address of the BMF packet
+ *              forwardedBy - the IP address of the node that forwarded the BMF
+ *                packet
+ *              forwardedTo - the IP address of the node to which the BMF packet
+ *                was directed
+ * Output     : neighbors - list of (up to a number of 'FanOutLimit') neighbors.
+ *              bestNeighbor - the best neighbor (in terms of lowest cost or ETX
+ *                value)
+ *              nPossibleNeighbors - number of found possible neighbors
+ * Data Used  : FanOutLimit
+ * ------------------------------------------------------------------------- */
+//void FindNeighbors(
+//  struct TBestNeighbors* neighbors,
+//  struct link_entry** bestNeighbor,
+//  struct TBmfInterface* intf,
+//  union olsr_ip_addr* source,
+//  union olsr_ip_addr* forwardedBy,
+//  union olsr_ip_addr* forwardedTo,
+//  int* nPossibleNeighbors)
+//{
+//  struct link_entry* walker;
+//  olsr_linkcost previousLinkEtx = LINK_COST_BROKEN;
+//  olsr_linkcost bestEtx = LINK_COST_BROKEN;
+//
+//  int i;
+//
+//  /* Initialize */
+//  *bestNeighbor = NULL;
+//  for (i = 0; i < MAX_UNICAST_NEIGHBORS; i++)
+//  {
+//    neighbors->links[i] = NULL;
+//  }
+//  *nPossibleNeighbors = 0;
+//
+//  if (forwardedBy != NULL)
+//  {
+//    /* Retrieve the cost of the link from 'forwardedBy' to myself */
+//    struct link_entry* bestLinkFromForwarder = get_best_link_to_neighbor(forwardedBy);
+//    if (bestLinkFromForwarder != NULL)
+//    {
+//      previousLinkEtx = bestLinkFromForwarder->linkcost;
+//    }
+//  }
+//
+//  OLSR_FOR_ALL_LINK_ENTRIES(walker) {
+//    struct ipaddr_str buf;
+//    union olsr_ip_addr* neighborMainIp;
+//    struct link_entry* bestLinkToNeighbor;
+//    struct tc_entry* tcLastHop;
+//    float currEtx;
+//
+//    /* Consider only links from the specified interface */
+//    if (! olsr_ipequal(&intf->intAddr, &walker->local_iface_addr))
+//    {
+//      continue; /* for */
+//    }
+//
+//    OLSR_PRINTF(
+//      9,
+//      "%s: ----> Considering forwarding pkt on \"%s\" to %s\n",
+//      PLUGIN_NAME_SHORT,
+//      intf->ifName,
+//      olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//
+//    neighborMainIp = MainAddressOf(&walker->neighbor_iface_addr);
+//
+//    /* Consider only neighbors with an IP address that differs from the
+//     * passed IP addresses (if passed). Rely on short-circuit boolean evaluation. */
+//    if (source != NULL && olsr_ipequal(neighborMainIp, MainAddressOf(source)))
+//    {
+//      OLSR_PRINTF(
+//        9,
+//        "%s: ----> Not forwarding to %s: is source of pkt\n",
+//        PLUGIN_NAME_SHORT,
+//        olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//
+//      continue; /* for */
+//    }
+//
+//    /* Rely on short-circuit boolean evaluation */
+//    if (forwardedBy != NULL && olsr_ipequal(neighborMainIp, MainAddressOf(forwardedBy)))
+//    {
+//      OLSR_PRINTF(
+//        9,
+//        "%s: ----> Not forwarding to %s: is the node that forwarded the pkt\n",
+//        PLUGIN_NAME_SHORT,
+//        olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//
+//      continue; /* for */
+//    }
+//
+//    /* Rely on short-circuit boolean evaluation */
+//    if (forwardedTo != NULL && olsr_ipequal(neighborMainIp, MainAddressOf(forwardedTo)))
+//    {
+//      OLSR_PRINTF(
+//        9,
+//        "%s: ----> Not forwarding to %s: is the node to which the pkt was forwarded\n",
+//        PLUGIN_NAME_SHORT,
+//        olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//
+//      continue; /* for */
+//    }
+//
+//    /* Found a candidate neighbor to direct our packet to */
+//
+//    /* Calculate the link quality (ETX) of the link to the found neighbor */
+//    currEtx = walker->linkcost;
+//
+//    if (currEtx >= LINK_COST_BROKEN)
+//    {
+//      OLSR_PRINTF(
+//        9,
+//        "%s: ----> Not forwarding to %s: link is timing out\n",
+//        PLUGIN_NAME_SHORT,
+//        olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//
+//      continue; /* for */
+//    }
+//
+//    /* Compare costs to check if the candidate neighbor is best reached via 'intf' */
+//    OLSR_PRINTF(
+//      9,
+//      "%s: ----> Forwarding pkt to %s will cost ETX %5.2f\n",
+//      PLUGIN_NAME_SHORT,
+//      olsr_ip_to_string(&buf, &walker->neighbor_iface_addr),
+//      currEtx);
+//
+//    /*
+//     * If the candidate neighbor is best reached via another interface, then skip
+//     * the candidate neighbor; the candidate neighbor has been / will be selected via that
+//     * other interface.
+//     */
+//    bestLinkToNeighbor = get_best_link_to_neighbor(&walker->neighbor_iface_addr);
+//
+//    if (walker != bestLinkToNeighbor)
+//    {
+//      if (bestLinkToNeighbor == NULL)
+//      {
+//        OLSR_PRINTF(
+//          9,
+//          "%s: ----> Not forwarding to %s: no link found\n",
+//          PLUGIN_NAME_SHORT,
+//          olsr_ip_to_string(&buf, &walker->neighbor_iface_addr));
+//      }
+//      else
+//      {
+//#ifndef NODEBUG
+//        struct interface* bestIntf = if_ifwithaddr(&bestLinkToNeighbor->local_iface_addr);
+//        struct lqtextbuffer lqbuffer;
+//#endif
+//        OLSR_PRINTF(
+//          9,
+//          "%s: ----> Not forwarding to %s: \"%s\" gives a better link to this neighbor, costing %s\n",
+//          PLUGIN_NAME_SHORT,
+//          olsr_ip_to_string(&buf, &walker->neighbor_iface_addr),
+//          bestIntf->int_name,
+//          get_linkcost_text(bestLinkToNeighbor->linkcost, 0, &lqbuffer));
+//      }
+//
+//      continue; /* for */
+//    }
+//
+//    if (forwardedBy != NULL)
+//    {
+//#ifndef NODEBUG
+//      struct ipaddr_str forwardedByBuf, niaBuf;
+//      struct lqtextbuffer lqbuffer;
+//#endif
+//      OLSR_PRINTF(
+//        9,
+//        "%s: ----> 2-hop path from %s via me to %s will cost ETX %s\n",
+//        PLUGIN_NAME_SHORT,
+//        olsr_ip_to_string(&forwardedByBuf, forwardedBy),
+//        olsr_ip_to_string(&niaBuf, &walker->neighbor_iface_addr),
+//        get_linkcost_text(previousLinkEtx + currEtx, 1, &lqbuffer));
+//    }
+//
+//    /* Check the topology table whether the 'forwardedBy' node is itself a direct
+//     * neighbor of the candidate neighbor, at a lower cost than the 2-hop route
+//     * via myself. If so, we do not need to forward the BMF packet to the candidate
+//     * neighbor, because the 'forwardedBy' node will forward the packet. */
+//    if (forwardedBy != NULL)
+//    {
+//      tcLastHop = olsr_lookup_tc_entry(MainAddressOf(forwardedBy));
+//      if (tcLastHop != NULL)
+//      {
+//        struct tc_edge_entry* tc_edge;
+//
+//        tc_edge = olsr_lookup_tc_edge(tcLastHop, MainAddressOf(&walker->neighbor_iface_addr));
+//
+//        /* We are not interested in dead-end edges. */
+//        if (tc_edge) {
+//          olsr_linkcost tcEtx = tc_edge->cost;
+//
+//          if (previousLinkEtx + currEtx > tcEtx)
+//          {
+//#ifndef NODEBUG
+//            struct ipaddr_str neighbor_iface_buf, forw_buf;
+//            struct lqtextbuffer lqbuffer;
+//            olsr_ip_to_string(&neighbor_iface_buf, &walker->neighbor_iface_addr);
+//#endif
+//            OLSR_PRINTF(
+//              9,
+//              "%s: ----> Not forwarding to %s: I am not an MPR between %s and %s, direct link costs %s\n",
+//              PLUGIN_NAME_SHORT,
+//              neighbor_iface_buf.buf,
+//              olsr_ip_to_string(&forw_buf, forwardedBy),
+//              neighbor_iface_buf.buf,
+//              get_linkcost_text(tcEtx, 0, &lqbuffer));
+//
+//            continue; /* for */
+//          } /* if */
+//        } /* if */
+//      } /* if */
+//    } /* if */
+//
+//    /* Remember the best neighbor. If all are very bad, remember none. */
+//    if (currEtx < bestEtx)
+//    {
+//      *bestNeighbor = walker;
+//      bestEtx = currEtx;
+//    }
+//
+//    /* Fill the list with up to 'FanOutLimit' neighbors. If there
+//     * are more neighbors, broadcast is used instead of unicast. In that
+//     * case we do not need the list of neighbors. */
+//    if (*nPossibleNeighbors < FanOutLimit)
+//    {
+//      neighbors->links[*nPossibleNeighbors] = walker;
+//    }
+//
+//    *nPossibleNeighbors += 1;
+//  } OLSR_FOR_ALL_LINK_ENTRIES_END(walker);
+//
+//  /* Display the result of the neighbor search */
+//  if (*nPossibleNeighbors == 0)
+//  {
+//    OLSR_PRINTF(
+//      9,
+//      "%s: ----> No suitable neighbor found to forward to on \"%s\"\n",
+//      PLUGIN_NAME_SHORT,
+//      intf->ifName);
+//  }
+//  else
+//  {
+//    struct ipaddr_str buf;
+//    OLSR_PRINTF(
+//      9,
+//      "%s: ----> %d neighbors found on \"%s\"; best neighbor to forward to: %s\n",
+//      PLUGIN_NAME_SHORT,
+//      *nPossibleNeighbors,
+//      intf->ifName,
+//      olsr_ip_to_string(&buf, &(*bestNeighbor)->neighbor_iface_addr));
+//  } /* if */
+//
+//} /* FindNeighbors */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateCaptureSocket
+ * Description: Create socket for promiscuously capturing multicast IP traffic
+ * Input      : ifname - network interface (e.g. "eth0")
+ * Output     : none
+ * Return     : the socket descriptor ( >= 0), or -1 if an error occurred
+ * Data Used  : none
+ * Notes      : The socket is a cooked IP packet socket, bound to the specified
+ *              network interface
+ * ------------------------------------------------------------------------- */
+static int CreateCaptureSocket(const char* ifName)
+{
+  int ifIndex = if_nametoindex(ifName);
+  struct packet_mreq mreq;
+  struct ifreq req;
+  struct sockaddr_ll bindTo;
+  int skfd = 0;
+  /* Open cooked IP packet socket */
+  if (olsr_cnf->ip_version == AF_INET){
+  skfd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));
+  }
+  else {
+  skfd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IPV6));
+  }
+  if (skfd < 0)
+  {
+    BmfPError("socket(PF_PACKET) error");
+    return -1;
+  }
+
+  /* Set interface to promiscuous mode */
+  memset(&mreq, 0, sizeof(struct packet_mreq));
+  mreq.mr_ifindex = ifIndex;
+  mreq.mr_type = PACKET_MR_PROMISC;
+  if (setsockopt(skfd, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
+  {
+    BmfPError("setsockopt(PACKET_MR_PROMISC) error");
+    close(skfd);
+    return -1;
+  }
+
+  /* Get hardware (MAC) address */
+  memset(&req, 0, sizeof(struct ifreq));
+  strncpy(req.ifr_name, ifName, IFNAMSIZ - 1);
+  req.ifr_name[IFNAMSIZ-1] = '\0'; /* Ensures null termination */
+  if (ioctl(skfd, SIOCGIFHWADDR, &req) < 0)
+  {
+    BmfPError("error retrieving MAC address");
+    close(skfd);
+    return -1;
+  }
+
+  /* Bind the socket to the specified interface */
+  memset(&bindTo, 0, sizeof(bindTo));
+  bindTo.sll_family = AF_PACKET;
+  if (olsr_cnf->ip_version == AF_INET){
+  bindTo.sll_protocol = htons(ETH_P_IP);
+  }
+  else{
+  bindTo.sll_protocol = htons(ETH_P_IPV6);
+  }
+  bindTo.sll_ifindex = ifIndex;
+  memcpy(bindTo.sll_addr, req.ifr_hwaddr.sa_data, IFHWADDRLEN);
+  bindTo.sll_halen = IFHWADDRLEN;
+
+  if (bind(skfd, (struct sockaddr*)&bindTo, sizeof(bindTo)) < 0)
+  {
+    BmfPError("bind() error");
+    close(skfd);
+    return -1;
+  }
+
+  /* Set socket to blocking operation */
+  if (fcntl(skfd, F_SETFL, fcntl(skfd, F_GETFL, 0) & ~O_NONBLOCK) < 0)
+  {
+    BmfPError("fcntl() error");
+    close(skfd);
+    return -1;
+  }
+
+  AddDescriptorToInputSet(skfd);
+  add_olsr_socket(skfd,&DoMDNS);
+
+  return skfd;
+} /* CreateCaptureSocket */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateListeningSocket
+ * Description: Create socket for promiscuously listening to BMF packets.
+ *              Used only when 'BmfMechanism' is BM_UNICAST_PROMISCUOUS
+ * Input      : ifname - network interface (e.g. "eth0")
+ * Output     : none
+ * Return     : the socket descriptor ( >= 0), or -1 if an error occurred
+ * Data Used  : none
+ * Notes      : The socket is a cooked IP packet socket, bound to the specified
+ *              network interface
+ * ------------------------------------------------------------------------- */
+//static int CreateListeningSocket(const char* ifName)
+//{
+//  int ifIndex = if_nametoindex(ifName);
+//  struct packet_mreq mreq;
+//  struct ifreq req;
+//  struct sockaddr_ll bindTo;
+//
+//  /* Open cooked IP packet socket */
+//  int skfd = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_IP));
+//  if (skfd < 0)
+//  {
+//    BmfPError("socket(PF_PACKET) error");
+//    return -1;
+//  }
+//
+//  /* Set interface to promiscuous mode */
+//  memset(&mreq, 0, sizeof(struct packet_mreq));
+//  mreq.mr_ifindex = ifIndex;
+//  mreq.mr_type = PACKET_MR_PROMISC;
+//  if (setsockopt(skfd, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) < 0)
+//  {
+//    BmfPError("setsockopt(PACKET_MR_PROMISC) error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Get hardware (MAC) address */
+//  memset(&req, 0, sizeof(struct ifreq));
+//  strncpy(req.ifr_name, ifName, IFNAMSIZ - 1);
+//  req.ifr_name[IFNAMSIZ-1] = '\0'; /* Ensures null termination */
+//  if (ioctl(skfd, SIOCGIFHWADDR, &req) < 0)
+//  {
+//    BmfPError("error retrieving MAC address");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Bind the socket to the specified interface */
+//  memset(&bindTo, 0, sizeof(bindTo));
+//  bindTo.sll_family = AF_PACKET;
+//  bindTo.sll_protocol = htons(ETH_P_IP);
+//  bindTo.sll_ifindex = ifIndex;
+//  memcpy(bindTo.sll_addr, req.ifr_hwaddr.sa_data, IFHWADDRLEN);
+//  bindTo.sll_halen = IFHWADDRLEN;
+//
+//  if (bind(skfd, (struct sockaddr*)&bindTo, sizeof(bindTo)) < 0)
+//  {
+//    BmfPError("bind() error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Set socket to blocking operation */
+//  if (fcntl(skfd, F_SETFL, fcntl(skfd, F_GETFL, 0) & ~O_NONBLOCK) < 0)
+//  {
+//    BmfPError("fcntl() error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  AddDescriptorToInputSet(skfd);
+//
+//  return skfd;
+//} /* CreateListeningSocket */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateEncapsulateSocket
+ * Description: Create a socket for sending and receiving encapsulated
+ *              multicast packets
+ * Input      : ifname - network interface (e.g. "eth0")
+ * Output     : none
+ * Return     : the socket descriptor ( >= 0), or -1 if an error occurred
+ * Data Used  : none
+ * Notes      : The socket is an UDP (datagram) over IP socket, bound to the
+ *              specified network interface
+ * ------------------------------------------------------------------------- */
+//static int CreateEncapsulateSocket(const char* ifName)
+//{
+//  int on = 1;
+//  struct sockaddr_in bindTo;
+//
+//  /* Open UDP-IP socket */
+//  int skfd = socket(PF_INET, SOCK_DGRAM, 0);
+//  if (skfd < 0)
+//  {
+//    BmfPError("socket(PF_INET) error");
+//    return -1;
+//  }
+//
+//  /* Enable sending to broadcast addresses */
+//  if (setsockopt(skfd, SOL_SOCKET, SO_BROADCAST, &on, sizeof(on)) < 0)
+//  {
+//    BmfPError("setsockopt(SO_BROADCAST) error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Bind to the specific network interfaces indicated by ifName. */
+//  /* When using Kernel 2.6 this must happer prior to the port binding! */
+//  if (setsockopt(skfd, SOL_SOCKET, SO_BINDTODEVICE, ifName, strlen(ifName) + 1) < 0)
+//  {
+//    BmfPError("setsockopt(SO_BINDTODEVICE) error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Bind to BMF port */
+//  memset(&bindTo, 0, sizeof(bindTo));
+//  bindTo.sin_family = AF_INET;
+//  bindTo.sin_port = htons(BMF_ENCAP_PORT);
+//  bindTo.sin_addr.s_addr = htonl(INADDR_ANY);
+//
+//  if (bind(skfd, (struct sockaddr*)&bindTo, sizeof(bindTo)) < 0)
+//  {
+//    BmfPError("bind() error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  /* Set socket to blocking operation */
+//  if (fcntl(skfd, F_SETFL, fcntl(skfd, F_GETFL, 0) & ~O_NONBLOCK) < 0)
+//  {
+//    BmfPError("fcntl() error");
+//    close(skfd);
+//    return -1;
+//  }
+//
+//  AddDescriptorToInputSet(skfd);
+//
+//  return skfd;
+//} /* CreateEncapsulateSocket */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateLocalEtherTunTap
+ * Description: Creates and brings up an EtherTunTap interface
+ * Input      : none
+ * Output     : none
+ * Return     : the socket file descriptor (>= 0), or -1 in case of failure
+ * Data Used  : EtherTunTapIfName - name used for the tuntap interface (e.g.
+ *                "bmf0")
+ *              EtherTunTapIp
+ *              EtherTunTapIpMask
+ *              EtherTunTapIpBroadcast
+ *              BmfInterfaces
+ * Note       : Order dependency: call this function only if BmfInterfaces
+ *              is filled with a list of network interfaces.
+ * ------------------------------------------------------------------------- */
+//static int CreateLocalEtherTunTap(void)
+//{
+//  static const char deviceName[] = "/dev/net/tun";
+//  struct ifreq ifreq;
+//  int etfd;
+//  int ioctlSkfd;
+//  int ioctlres;
+//
+//  etfd = open(deviceName, O_RDWR | O_NONBLOCK);
+//  if (etfd < 0)
+//  {
+//    BmfPError("error opening %s", deviceName);
+//    return -1;
+//  }
+//
+//  memset(&ifreq, 0, sizeof(ifreq));
+//  strncpy(ifreq.ifr_name, EtherTunTapIfName, IFNAMSIZ - 1);
+//  ifreq.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+//
+//  /* Specify the IFF_TUN flag for IP packets.
+//   * Specify IFF_NO_PI for not receiving extra meta packet information. */
+//  ifreq.ifr_flags = IFF_TUN;
+//  ifreq.ifr_flags |= IFF_NO_PI;
+//
+//  if (ioctl(etfd, TUNSETIFF, (void *)&ifreq) < 0)
+//  {
+//    BmfPError("ioctl(TUNSETIFF) error on %s", deviceName);
+//    close(etfd);
+//    return -1;
+//  }
+//
+//  memset(&ifreq, 0, sizeof(ifreq));
+//  strncpy(ifreq.ifr_name, EtherTunTapIfName, IFNAMSIZ - 1);
+//  ifreq.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+//  ifreq.ifr_addr.sa_family = AF_INET;
+//
+//  ioctlSkfd = socket(PF_INET, SOCK_DGRAM, 0);
+//  if (ioctlSkfd < 0)
+//  {
+//    BmfPError("socket(PF_INET) error on %s", deviceName);
+//    close(etfd);
+//    return -1;
+//  }
+//
+//  /* Give the EtherTunTap interface an IP address.
+//   * The default IP address is the address of the first OLSR interface;
+//   * the default netmask is 255.255.255.255 . Having an all-ones netmask prevents
+//   * automatic entry of the BMF network interface in the routing table. */
+//  if (EtherTunTapIp == ETHERTUNTAPIPNOTSET)
+//  {
+//    struct TBmfInterface* nextBmfIf = BmfInterfaces;
+//    while (nextBmfIf != NULL)
+//    {
+//      struct TBmfInterface* bmfIf = nextBmfIf;
+//      nextBmfIf = bmfIf->next;
+//
+//      if (bmfIf->olsrIntf != NULL)
+//      {
+//        EtherTunTapIp = ntohl(bmfIf->intAddr.v4.s_addr);
+//        EtherTunTapIpBroadcast = EtherTunTapIp;
+//      }
+//    }
+//  }
+//
+//  if (EtherTunTapIp == ETHERTUNTAPIPNOTSET)
+//  {
+//    /* No IP address configured for BMF network interface, and no OLSR interface found to
+//     * copy IP address from. Fall back to default: 10.255.255.253 . */
+//    EtherTunTapIp = ETHERTUNTAPDEFAULTIP;
+//  }
+//
+//  ((struct sockaddr_in*)&ifreq.ifr_addr)->sin_addr.s_addr = htonl(EtherTunTapIp);
+//  ioctlres = ioctl(ioctlSkfd, SIOCSIFADDR, &ifreq);
+//  if (ioctlres >= 0)
+//  {
+//    /* Set net mask */
+//    ((struct sockaddr_in*)&ifreq.ifr_netmask)->sin_addr.s_addr = htonl(EtherTunTapIpMask);
+//    ioctlres = ioctl(ioctlSkfd, SIOCSIFNETMASK, &ifreq);
+//    if (ioctlres >= 0)
+//    {
+//      /* Set broadcast IP */
+//      ((struct sockaddr_in*)&ifreq.ifr_broadaddr)->sin_addr.s_addr = htonl(EtherTunTapIpBroadcast);
+//      ioctlres = ioctl(ioctlSkfd, SIOCSIFBRDADDR, &ifreq);
+//      if (ioctlres >= 0)
+//      {
+//        /* Bring EtherTunTap interface up (if not already) */
+//        ioctlres = ioctl(ioctlSkfd, SIOCGIFFLAGS, &ifreq);
+//        if (ioctlres >= 0)
+//        {
+//          ifreq.ifr_flags |= (IFF_UP | IFF_RUNNING | IFF_BROADCAST);
+//          ioctlres = ioctl(ioctlSkfd, SIOCSIFFLAGS, &ifreq);
+//        }
+//      }
+//    }
+//  }
+//
+//  if (ioctlres < 0)
+//  {
+//    /* Any of the above ioctl() calls failed */
+//    BmfPError("error bringing up EtherTunTap interface \"%s\"", EtherTunTapIfName);
+//
+//    close(etfd);
+//    close(ioctlSkfd);
+//    return -1;
+//  } /* if (ioctlres < 0) */
+//
+//  /* Set the multicast flag on the interface */
+//  memset(&ifreq, 0, sizeof(ifreq));
+//  strncpy(ifreq.ifr_name, EtherTunTapIfName, IFNAMSIZ - 1);
+//  ifreq.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+//
+//  ioctlres = ioctl(ioctlSkfd, SIOCGIFFLAGS, &ifreq);
+//  if (ioctlres >= 0)
+//  {
+//    ifreq.ifr_flags |= IFF_MULTICAST;
+//    ioctlres = ioctl(ioctlSkfd, SIOCSIFFLAGS, &ifreq);
+//  }
+//  if (ioctlres < 0)
+//  {
+//    /* Any of the two above ioctl() calls failed */
+//    BmfPError("error setting multicast flag on EtherTunTap interface \"%s\"", EtherTunTapIfName);
+//
+//    /* Continue anyway */
+//  }
+//
+//  /* Use ioctl to make the tuntap persistent. Otherwise it will disappear
+//   * when this program exits. That is not desirable, since a multicast
+//   * daemon (e.g. mrouted) may be using the tuntap interface. */
+//  if (ioctl(etfd, TUNSETPERSIST, (void *)&ifreq) < 0)
+//  {
+//    BmfPError("error making EtherTunTap interface \"%s\" persistent", EtherTunTapIfName);
+//
+//    /* Continue anyway */
+//  }
+//
+//  OLSR_PRINTF(8, "%s: opened 1 socket on \"%s\"\n", PLUGIN_NAME_SHORT, EtherTunTapIfName);
+//
+//  AddDescriptorToInputSet(etfd);
+//
+//  /* If the user configured a specific IP address for the BMF network interface,
+//   * help the user and advertise the IP address of the BMF network interface
+//   * on the OLSR network via HNA */
+//  if (TunTapIpOverruled != 0)
+//  {
+//    union olsr_ip_addr temp_net;
+//
+//    temp_net.v4.s_addr = htonl(EtherTunTapIp);
+//    ip_prefix_list_add(&olsr_cnf->hna_entries, &temp_net, 32);
+//  }
+//
+//  close(ioctlSkfd);
+//
+//  return etfd;
+//} /* CreateLocalEtherTunTap */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateInterface
+ * Description: Create a new TBmfInterface object and adds it to the global
+ *              BmfInterfaces list
+ * Input      : ifName - name of the network interface (e.g. "eth0")
+ *            : olsrIntf - OLSR interface object of the network interface, or
+ *                NULL if the network interface is not OLSR-enabled
+ * Output     : none
+ * Return     : the number of opened sockets
+ * Data Used  : BmfInterfaces, LastBmfInterface
+ * ------------------------------------------------------------------------- */
+
+//FOR MDNS IS ALWAYS CALLED WITH NULL AS SECOND ARG
+
+static int CreateInterface(
+  const char* ifName,
+  struct interface* olsrIntf)
+{
+  int capturingSkfd = -1;
+  int encapsulatingSkfd = -1;
+  int listeningSkfd = -1;
+  int ioctlSkfd;
+  struct ifreq ifr;
+  int nOpened = 0;
+  struct TBmfInterface* newIf = malloc(sizeof(struct TBmfInterface));
+
+  assert(ifName != NULL);
+
+  if (newIf == NULL)
+  {
+    return 0;
+  }
+
+//TODO: assert interface is not talking OLSR
+
+//  if (olsrIntf != NULL)
+//  {
+//    /* On OLSR-enabled interfaces, create socket for encapsulating and forwarding
+//     * multicast packets */
+//    encapsulatingSkfd = CreateEncapsulateSocket(ifName);
+//    if (encapsulatingSkfd < 0)
+//    {
+//      free(newIf);
+//      return 0;
+//    }
+//    nOpened++;
+//  }
+
+  /* Create socket for capturing and sending of multicast packets on
+   * non-OLSR interfaces, and on OLSR-interfaces if configured. */
+  if ((olsrIntf == NULL) || (CapturePacketsOnOlsrInterfaces != 0))
+  {
+    capturingSkfd = CreateCaptureSocket(ifName);
+    if (capturingSkfd < 0)
+    {
+      close(encapsulatingSkfd);
+      free(newIf);
+      return 0;
+    }
+
+    nOpened++;
+  }
+
+//  /* Create promiscuous mode listening interface if BMF uses IP unicast
+//   * as underlying forwarding mechanism */
+//  if (BmfMechanism == BM_UNICAST_PROMISCUOUS)
+//  {
+//    listeningSkfd = CreateListeningSocket(ifName);
+//    if (listeningSkfd < 0)
+//    {
+//      close(listeningSkfd);
+//      close(encapsulatingSkfd); /* no problem if 'encapsulatingSkfd' is -1 */
+//      free(newIf);
+//      return 0;
+//    }
+//
+//    nOpened++;
+//  }
+
+  /* For ioctl operations on the network interface, use either capturingSkfd
+   * or encapsulatingSkfd, whichever is available */
+  ioctlSkfd = (capturingSkfd >= 0) ? capturingSkfd : encapsulatingSkfd;
+
+  /* Retrieve the MAC address of the interface. */
+  memset(&ifr, 0, sizeof(struct ifreq));
+  strncpy(ifr.ifr_name, ifName, IFNAMSIZ - 1);
+  ifr.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+  if (ioctl(ioctlSkfd, SIOCGIFHWADDR, &ifr) < 0)
+  {
+    BmfPError("ioctl(SIOCGIFHWADDR) error for interface \"%s\"", ifName);
+    close(capturingSkfd);
+    close(encapsulatingSkfd);
+    free(newIf);
+    return 0;
+  }
+
+  /* Copy data into TBmfInterface object */
+  newIf->capturingSkfd = capturingSkfd;
+  newIf->encapsulatingSkfd = encapsulatingSkfd;
+  newIf->listeningSkfd = listeningSkfd;
+  memcpy(newIf->macAddr, ifr.ifr_hwaddr.sa_data, IFHWADDRLEN);
+  memcpy(newIf->ifName, ifName, IFNAMSIZ);
+  newIf->olsrIntf = olsrIntf;
+  if (olsrIntf != NULL)
+  {
+    /* For an OLSR-interface, copy the interface address and broadcast
+     * address from the OLSR interface object. Downcast to correct sockaddr
+     * subtype. */
+    newIf->intAddr.v4 = olsrIntf->int_addr.sin_addr;
+    newIf->broadAddr.v4 = olsrIntf->int_broadaddr.sin_addr;
+  }
+  else
+  {
+    /* For a non-OLSR interface, retrieve the IP address ourselves */
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifName, IFNAMSIZ - 1);
+    ifr.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+    if (ioctl(ioctlSkfd, SIOCGIFADDR, &ifr) < 0)
+    {
+      BmfPError("ioctl(SIOCGIFADDR) error for interface \"%s\"", ifName);
+
+      newIf->intAddr.v4.s_addr = inet_addr("0.0.0.0");
+    }
+    else
+    {
+      /* Downcast to correct sockaddr subtype */
+      newIf->intAddr.v4 = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
+    }
+
+    /* For a non-OLSR interface, retrieve the IP broadcast address ourselves */
+    memset(&ifr, 0, sizeof(struct ifreq));
+    strncpy(ifr.ifr_name, ifName, IFNAMSIZ - 1);
+    ifr.ifr_name[IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+    if (ioctl(ioctlSkfd, SIOCGIFBRDADDR, &ifr) < 0)
+    {
+      BmfPError("ioctl(SIOCGIFBRDADDR) error for interface \"%s\"", ifName);
+
+      newIf->broadAddr.v4.s_addr = inet_addr("0.0.0.0");
+    }
+    else
+    {
+      /* Downcast to correct sockaddr subtype */
+      newIf->broadAddr.v4 = ((struct sockaddr_in *)&ifr.ifr_broadaddr)->sin_addr;
+    }
+  }
+
+  /* Initialize fragment history table */
+  //memset(&newIf->fragmentHistory, 0, sizeof(newIf->fragmentHistory));
+  //newIf->nextFragmentHistoryEntry = 0;
+
+  /* Reset counters */
+  //newIf->nBmfPacketsRx = 0;
+  //newIf->nBmfPacketsRxDup = 0;
+  //newIf->nBmfPacketsTx = 0;
+
+  /* Add new TBmfInterface object to global list. OLSR interfaces are
+   * added at the front of the list, non-OLSR interfaces at the back. */
+  if (BmfInterfaces == NULL)
+  {
+    /* First TBmfInterface object in list */
+    BmfInterfaces = newIf;
+    LastBmfInterface = newIf;
+  }
+  else if (olsrIntf != NULL)
+  {
+    /* Add new TBmfInterface object at front of list */
+    newIf->next = BmfInterfaces;
+    BmfInterfaces = newIf;
+  }
+  else
+  {
+    /* Add new TBmfInterface object at back of list */
+    newIf->next = NULL;
+    LastBmfInterface->next= newIf;
+    LastBmfInterface = newIf;
+  }
+
+  OLSR_PRINTF(
+    8,
+    "%s: opened %d socket%s on %s interface \"%s\"\n",
+    PLUGIN_NAME_SHORT,
+    nOpened,
+    nOpened == 1 ? "" : "s",
+    olsrIntf != NULL ? "OLSR" : "non-OLSR",
+    ifName);
+
+  return nOpened;
+} /* CreateInterface */
+
+/* -------------------------------------------------------------------------
+ * Function   : CreateBmfNetworkInterfaces
+ * Description: Create a list of TBmfInterface objects, one for each network
+ *              interface on which BMF runs
+ * Input      : skipThisIntf - network interface to skip, if seen
+ * Output     : none
+ * Return     : fail (-1) or success (0)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int CreateBmfNetworkInterfaces(struct interface* skipThisIntf)
+{
+  int skfd;
+  struct ifconf ifc;
+  int numreqs = 30;
+  struct ifreq* ifr;
+  int n;
+  int nOpenedSockets = 0;
+
+  /* Clear input descriptor set */
+  FD_ZERO(&InputSet);
+
+  skfd = socket(PF_INET, SOCK_DGRAM, 0);
+  if (skfd < 0)
+  {
+    BmfPError("no inet socket available to retrieve interface list");
+    return -1;
+  }
+
+  /* Retrieve the network interface configuration list */
+  ifc.ifc_buf = NULL;
+  for (;;)
+  {
+    ifc.ifc_len = sizeof(struct ifreq) * numreqs;
+    ifc.ifc_buf = realloc(ifc.ifc_buf, ifc.ifc_len);
+
+    if (ioctl(skfd, SIOCGIFCONF, &ifc) < 0)
+    {
+      BmfPError("ioctl(SIOCGIFCONF) error");
+
+      close(skfd);
+      free(ifc.ifc_buf);
+      return -1;
+    }
+    if ((unsigned)ifc.ifc_len == sizeof(struct ifreq) * numreqs)
+    {
+      /* Assume it overflowed; double the space and try again */
+      numreqs *= 2;
+      assert(numreqs < 1024);
+      continue; /* for (;;) */
+    }
+    break; /* for (;;) */
+  } /* for (;;) */
+
+  close(skfd);
+
+  /* For each item in the interface configuration list... */
+  ifr = ifc.ifc_req;
+  for (n = ifc.ifc_len / sizeof(struct ifreq); --n >= 0; ifr++)
+  {
+    struct interface* olsrIntf;
+    union olsr_ip_addr ipAddr;
+
+    /* Skip the BMF network interface itself */
+    //if (strncmp(ifr->ifr_name, EtherTunTapIfName, IFNAMSIZ) == 0)
+    //{
+    //  continue; /* for (n = ...) */
+    //}
+
+    /* ...find the OLSR interface structure, if any */
+    ipAddr.v4 =  ((struct sockaddr_in*)&ifr->ifr_addr)->sin_addr;
+    olsrIntf = if_ifwithaddr(&ipAddr);
+
+    if (skipThisIntf != NULL && olsrIntf == skipThisIntf)
+    {
+      continue; /* for (n = ...) */
+    }
+
+    if (olsrIntf == NULL && ! IsNonOlsrBmfIf(ifr->ifr_name))
+    {
+      /* Interface is neither OLSR interface, nor specified as non-OLSR BMF
+       * interface in the BMF plugin parameter list */
+      continue; /* for (n = ...) */
+    }
+	
+    if (! IsNonOlsrBmfIf(ifr->ifr_name))
+    {
+      	//If the interface is not specified in the configuration file then go ahead
+	continue; /* for (n = ...) */
+    }
+   //TODO: asser if->ifr_name is not talking OLSR
+    //nOpenedSockets += CreateInterface(ifr->ifr_name, olsrIntf);
+    nOpenedSockets += CreateInterface(ifr->ifr_name, NULL);
+
+  } /* for (n = ...) */
+
+  free(ifc.ifc_buf);
+
+  /* Create the BMF network interface */
+  //EtherTunTapFd = CreateLocalEtherTunTap();
+  //if (EtherTunTapFd >= 0)
+  //{
+  //  nOpenedSockets++;
+  //}
+
+  if (BmfInterfaces == NULL)
+  {
+    OLSR_PRINTF(1, "%s: could not initialize any network interface\n", PLUGIN_NAME);
+  }
+  else
+  {
+    OLSR_PRINTF(1, "%s: opened %d sockets\n", PLUGIN_NAME, nOpenedSockets);
+  }
+  return 0;
+} /* CreateBmfNetworkInterfaces */
+
+/* -------------------------------------------------------------------------
+ * Function   : AddInterface
+ * Description: Add an OLSR-enabled network interface to the list of BMF-enabled
+ *              network interfaces
+ * Input      : newIntf - network interface to add
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+void AddInterface(struct interface* newIntf)
+{
+  int nOpened;
+
+  assert(newIntf != NULL);
+
+  nOpened = CreateInterface(newIntf->int_name, newIntf);
+
+  OLSR_PRINTF(1, "%s: opened %d sockets\n", PLUGIN_NAME, nOpened);
+} /* AddInterface */
+
+/* -------------------------------------------------------------------------
+ * Function   : CloseBmfNetworkInterfaces
+ * Description: Closes every socket on each network interface used by BMF
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : Closes
+ *              - the local EtherTunTap interface (e.g. "tun0" or "tap0")
+ *              - for each BMF-enabled interface, the socket used for
+ *                capturing multicast packets
+ *              - for each OLSR-enabled interface, the socket used for
+ *                encapsulating packets
+ *              Also restores the network state to the situation before BMF
+ *              was started.
+ * ------------------------------------------------------------------------- */
+void CloseBmfNetworkInterfaces(void)
+{
+  int nClosed = 0;
+  u_int32_t totalOlsrBmfPacketsRx = 0;
+  u_int32_t totalOlsrBmfPacketsRxDup = 0;
+  u_int32_t totalOlsrBmfPacketsTx = 0;
+  u_int32_t totalNonOlsrBmfPacketsRx = 0;
+  u_int32_t totalNonOlsrBmfPacketsRxDup = 0;
+  u_int32_t totalNonOlsrBmfPacketsTx = 0;
+
+  /* Close all opened sockets */
+  struct TBmfInterface* nextBmfIf = BmfInterfaces;
+  while (nextBmfIf != NULL)
+  {
+    struct TBmfInterface* bmfIf = nextBmfIf;
+    nextBmfIf = bmfIf->next;
+
+    if (bmfIf->capturingSkfd >= 0)
+    {
+      close(bmfIf->capturingSkfd);
+      nClosed++;
+    }
+    if (bmfIf->encapsulatingSkfd >= 0)
+    {
+      close(bmfIf->encapsulatingSkfd);
+      nClosed++;
+    }
+
+    OLSR_PRINTF(
+      7,
+      "%s: %s interface \"%s\": RX pkts %u (%u dups); TX pkts %u\n",
+      PLUGIN_NAME_SHORT,
+      bmfIf->olsrIntf != NULL ? "OLSR" : "non-OLSR",
+      bmfIf->ifName,
+      bmfIf->nBmfPacketsRx,
+      bmfIf->nBmfPacketsRxDup,
+      bmfIf->nBmfPacketsTx);
+
+    OLSR_PRINTF(
+      1,
+      "%s: closed %s interface \"%s\"\n",
+      PLUGIN_NAME_SHORT,
+      bmfIf->olsrIntf != NULL ? "OLSR" : "non-OLSR",
+      bmfIf->ifName);
+
+    /* Add totals */
+    if (bmfIf->olsrIntf != NULL)
+    {
+      totalOlsrBmfPacketsRx += bmfIf->nBmfPacketsRx;
+      totalOlsrBmfPacketsRxDup += bmfIf->nBmfPacketsRxDup;
+      totalOlsrBmfPacketsTx += bmfIf->nBmfPacketsTx;
+    }
+    else
+    {
+      totalNonOlsrBmfPacketsRx += bmfIf->nBmfPacketsRx;
+      totalNonOlsrBmfPacketsRxDup += bmfIf->nBmfPacketsRxDup;
+      totalNonOlsrBmfPacketsTx += bmfIf->nBmfPacketsTx;
+    }
+
+    free(bmfIf);
+  } /* while */
+
+  if (EtherTunTapFd >= 0)
+  {
+    close(EtherTunTapFd);
+    nClosed++;
+
+    OLSR_PRINTF(7, "%s: closed \"%s\"\n", PLUGIN_NAME_SHORT, EtherTunTapIfName);
+  }
+
+  BmfInterfaces = NULL;
+
+  OLSR_PRINTF(1, "%s: closed %d sockets\n", PLUGIN_NAME_SHORT, nClosed);
+
+  OLSR_PRINTF(
+    7,
+    "%s: Total all OLSR interfaces    : RX pkts %u (%u dups); TX pkts %u\n",
+    PLUGIN_NAME_SHORT,
+    totalOlsrBmfPacketsRx,
+    totalOlsrBmfPacketsRxDup,
+    totalOlsrBmfPacketsTx);
+  OLSR_PRINTF(
+    7,
+    "%s: Total all non-OLSR interfaces: RX pkts %u (%u dups); TX pkts %u\n",
+    PLUGIN_NAME_SHORT,
+    totalNonOlsrBmfPacketsRx,
+    totalNonOlsrBmfPacketsRxDup,
+    totalNonOlsrBmfPacketsTx);
+} /* CloseBmfNetworkInterfaces */
+
+#define MAX_NON_OLSR_IFS 32
+static char NonOlsrIfNames[MAX_NON_OLSR_IFS][IFNAMSIZ];
+static int nNonOlsrIfs = 0;
+
+/* -------------------------------------------------------------------------
+ * Function   : AddNonOlsrBmfIf
+ * Description: Add an non-OLSR enabled network interface to the list of BMF-enabled
+ *              network interfaces
+ * Input      : ifName - network interface (e.g. "eth0")
+ *              data - not used
+ *              addon - not used
+ * Output     : none
+ * Return     : success (0) or fail (1)
+ * Data Used  : NonOlsrIfNames
+ * ------------------------------------------------------------------------- */
+int AddNonOlsrBmfIf(
+  const char* ifName,
+  void* data __attribute__((unused)),
+  set_plugin_parameter_addon addon __attribute__((unused)))
+{
+  assert(ifName != NULL);
+
+  if (nNonOlsrIfs >= MAX_NON_OLSR_IFS)
+  {
+    OLSR_PRINTF(
+      1,
+      "%s: too many non-OLSR interfaces specified, maximum is %d\n",
+      PLUGIN_NAME,
+      MAX_NON_OLSR_IFS);
+    return 1;
+  }
+
+  strncpy(NonOlsrIfNames[nNonOlsrIfs], ifName, IFNAMSIZ - 1);
+  NonOlsrIfNames[nNonOlsrIfs][IFNAMSIZ - 1] = '\0'; /* Ensures null termination */
+  nNonOlsrIfs++;
+  return 0;
+} /* AddNonOlsrBmfIf */
+
+/* -------------------------------------------------------------------------
+ * Function   : IsNonOlsrBmfIf
+ * Description: Checks if a network interface is OLSR-enabled
+ * Input      : ifName - network interface (e.g. "eth0")
+ * Output     : none
+ * Return     : true (1) or false (0)
+ * Data Used  : NonOlsrIfNames
+ * ------------------------------------------------------------------------- */
+int IsNonOlsrBmfIf(const char* ifName)
+{
+  int i;
+
+  assert(ifName != NULL);
+
+  for (i = 0; i < nNonOlsrIfs; i++)
+  {
+    if (strncmp(NonOlsrIfNames[i], ifName, IFNAMSIZ) == 0) return 1;
+  }
+  return 0;
+} /* IsNonOlsrBmfIf */
+
+/* -------------------------------------------------------------------------
+ * Function   : CheckAndUpdateLocalBroadcast
+ * Description: For an IP packet, check if the destination address is not a
+ *              multicast address. If it is not, the packet is assumed to be
+ *              a local broadcast packet. In that case, set the destination
+ *              address of the IP packet to the passed broadcast address.
+ * Input      : ipPacket - the IP packet
+ *              broadAddr - the broadcast address to fill in
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : See also RFC1141
+ * ------------------------------------------------------------------------- */
+void CheckAndUpdateLocalBroadcast(unsigned char* ipPacket, union olsr_ip_addr* broadAddr)
+{
+  struct iphdr* iph;
+  union olsr_ip_addr destIp;
+
+  assert(ipPacket != NULL && broadAddr != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  destIp.v4.s_addr = iph->daddr;
+  if (! IsMulticast(&destIp))
+  {
+    u_int32_t origDaddr, newDaddr;
+    u_int32_t check;
+
+    origDaddr = ntohl(iph->daddr);
+
+    iph->daddr = broadAddr->v4.s_addr;
+    newDaddr = ntohl(iph->daddr);
+
+    /* Re-calculate IP header checksum for new destination */
+    check = ntohs(iph->check);
+
+    check = ~ (~ check - ((origDaddr >> 16) & 0xFFFF) + ((newDaddr >> 16) & 0xFFFF));
+    check = ~ (~ check - (origDaddr & 0xFFFF) + (newDaddr & 0xFFFF));
+
+    /* Add carry */
+    check = check + (check >> 16);
+
+    iph->check = htons(check);
+
+    if (iph->protocol == SOL_UDP)
+    {
+      /* Re-calculate UDP/IP checksum for new destination */
+
+      int ipHeaderLen = GetIpHeaderLength(ipPacket);
+      struct udphdr* udph = (struct udphdr*) (ipPacket + ipHeaderLen);
+
+      /* RFC 1624, Eq. 3: HC' = ~(~HC - m + m') */
+
+      check = ntohs(udph->check);
+
+      check = ~ (~ check - ((origDaddr >> 16) & 0xFFFF) + ((newDaddr >> 16) & 0xFFFF));
+      check = ~ (~ check - (origDaddr & 0xFFFF) + (newDaddr & 0xFFFF));
+
+      /* Add carry */
+      check = check + (check >> 16);
+
+      udph->check = htons(check);
+     } /* if */
+  } /* if */
+} /* CheckAndUpdateLocalBroadcast */
+
+/* -------------------------------------------------------------------------
+ * Function   : AddMulticastRoute
+ * Description: Insert a route to all multicast addresses in the kernel
+ *              routing table. The route will be via the BMF network interface.
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+void AddMulticastRoute(void)
+{
+  struct rtentry kernel_route;
+  int ioctlSkfd = socket(PF_INET, SOCK_DGRAM, 0);
+  if (ioctlSkfd < 0)
+  {
+    BmfPError("socket(PF_INET) error");
+    return;
+  }
+
+  memset(&kernel_route, 0, sizeof(struct rtentry));
+
+  ((struct sockaddr_in*)&kernel_route.rt_dst)->sin_family = AF_INET;
+  ((struct sockaddr_in*)&kernel_route.rt_gateway)->sin_family = AF_INET;
+  ((struct sockaddr_in*)&kernel_route.rt_genmask)->sin_family = AF_INET;
+
+  /* 224.0.0.0/4 */
+  ((struct sockaddr_in *)&kernel_route.rt_dst)->sin_addr.s_addr = htonl(0xE0000000);
+  ((struct sockaddr_in *)&kernel_route.rt_genmask)->sin_addr.s_addr = htonl(0xF0000000);
+
+  kernel_route.rt_metric = 0;
+  kernel_route.rt_flags = RTF_UP;
+
+  kernel_route.rt_dev = EtherTunTapIfName;
+
+  if (ioctl(ioctlSkfd, SIOCADDRT, &kernel_route) < 0)
+  {
+    BmfPError("error setting multicast route via EtherTunTap interface \"%s\"", EtherTunTapIfName);
+
+    /* Continue anyway */
+  }
+  close(ioctlSkfd);
+} /* AddMulticastRoute */
+
+/* -------------------------------------------------------------------------
+ * Function   : DeleteMulticastRoute
+ * Description: Delete the route to all multicast addresses from the kernel
+ *              routing table
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+void DeleteMulticastRoute(void)
+{
+  if (EtherTunTapIp != ETHERTUNTAPDEFAULTIP)
+  {
+    struct rtentry kernel_route;
+    int ioctlSkfd = socket(PF_INET, SOCK_DGRAM, 0);
+    if (ioctlSkfd < 0)
+    {
+      BmfPError("socket(PF_INET) error");
+      return;
+    }
+
+    memset(&kernel_route, 0, sizeof(struct rtentry));
+
+    ((struct sockaddr_in*)&kernel_route.rt_dst)->sin_family = AF_INET;
+    ((struct sockaddr_in*)&kernel_route.rt_gateway)->sin_family = AF_INET;
+    ((struct sockaddr_in*)&kernel_route.rt_genmask)->sin_family = AF_INET;
+
+    /* 224.0.0.0/4 */
+    ((struct sockaddr_in *)&kernel_route.rt_dst)->sin_addr.s_addr = htonl(0xE0000000);
+    ((struct sockaddr_in *)&kernel_route.rt_genmask)->sin_addr.s_addr = htonl(0xF0000000);
+
+    kernel_route.rt_metric = 0;
+    kernel_route.rt_flags = RTF_UP;
+
+    kernel_route.rt_dev = EtherTunTapIfName;
+
+    if (ioctl(ioctlSkfd, SIOCDELRT, &kernel_route) < 0)
+    {
+      BmfPError("error deleting multicast route via EtherTunTap interface \"%s\"", EtherTunTapIfName);
+
+      /* Continue anyway */
+    }
+    close(ioctlSkfd);
+  } /* if */
+} /* DeleteMulticastRoute */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/NetworkInterfaces.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/NetworkInterfaces.h	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,162 @@
+#ifndef _BMF_NETWORKINTERFACES_H
+#define _BMF_NETWORKINTERFACES_H
+
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : NetworkInterfaces.h
+ * Description: Functions to open and close sockets
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+/* System includes */
+#include <netinet/in.h> /* struct in_addr */
+
+/* OLSR includes */
+#include "olsr_types.h" /* olsr_ip_addr */
+#include "olsrd_plugin.h" /* union set_plugin_parameter_addon */
+#include "socket_parser.h"
+/* Plugin includes */
+#include "Packet.h" /* IFHWADDRLEN */
+#include "mdns.h"
+/* Size of buffer in which packets are received */
+#define BMF_BUFFER_SIZE 2048
+
+struct TBmfInterface
+{
+  /* File descriptor of raw packet socket, used for capturing multicast packets */
+  int capturingSkfd;
+
+  /* File descriptor of UDP (datagram) socket for encapsulated multicast packets.
+   * Only used for OLSR-enabled interfaces; set to -1 if interface is not OLSR-enabled. */
+  int encapsulatingSkfd;
+
+  /* File descriptor of UDP packet socket, used for listening to encapsulation packets.
+   * Used only when PlParam "BmfMechanism" is set to "UnicastPromiscuous". */
+  int listeningSkfd;
+
+  unsigned char macAddr[IFHWADDRLEN];
+
+  char ifName[IFNAMSIZ];
+
+  /* OLSRs idea of this network interface. NULL if this interface is not
+   * OLSR-enabled. */
+  struct interface* olsrIntf;
+
+  /* IP address of this network interface */
+  union olsr_ip_addr intAddr;
+
+  /* Broadcast address of this network interface */
+  union olsr_ip_addr broadAddr;
+
+  #define FRAGMENT_HISTORY_SIZE 10
+  struct TFragmentHistory
+  {
+    u_int16_t ipId;
+    u_int8_t ipProto;
+    struct in_addr ipSrc;
+    struct in_addr ipDst;
+  } fragmentHistory [FRAGMENT_HISTORY_SIZE];
+
+  int nextFragmentHistoryEntry;
+
+  /* Number of received and transmitted BMF packets on this interface */
+  u_int32_t nBmfPacketsRx;
+  u_int32_t nBmfPacketsRxDup;
+  u_int32_t nBmfPacketsTx;
+
+  /* Next element in list */
+  struct TBmfInterface* next;
+};
+
+extern struct TBmfInterface* BmfInterfaces;
+
+extern int HighestSkfd;
+extern fd_set InputSet;
+
+extern int EtherTunTapFd;
+
+extern char EtherTunTapIfName[];
+
+/* 10.255.255.253 in host byte order */
+#define ETHERTUNTAPDEFAULTIP 0x0AFFFFFD
+
+extern u_int32_t EtherTunTapIp;
+extern u_int32_t EtherTunTapIpMask;
+extern u_int32_t EtherTunTapIpBroadcast;
+
+extern int CapturePacketsOnOlsrInterfaces;
+
+enum TBmfMechanism { BM_BROADCAST = 0, BM_UNICAST_PROMISCUOUS };
+extern enum TBmfMechanism BmfMechanism;
+
+int SetBmfInterfaceName(const char* ifname, void* data, set_plugin_parameter_addon addon);
+int SetBmfInterfaceIp(const char* ip, void* data, set_plugin_parameter_addon addon);
+int SetCapturePacketsOnOlsrInterfaces(const char* enable, void* data, set_plugin_parameter_addon addon);
+int SetBmfMechanism(const char* mechanism, void* data, set_plugin_parameter_addon addon);
+int DeactivateSpoofFilter(void);
+void RestoreSpoofFilter(void);
+
+#define MAX_UNICAST_NEIGHBORS 10
+struct TBestNeighbors
+{
+  struct link_entry* links[MAX_UNICAST_NEIGHBORS];
+};
+
+void FindNeighbors(
+  struct TBestNeighbors* neighbors,
+  struct link_entry** bestNeighbor,
+  struct TBmfInterface* intf,
+  union olsr_ip_addr* source,
+  union olsr_ip_addr* forwardedBy,
+  union olsr_ip_addr* forwardedTo,
+  int* nPossibleNeighbors);
+
+int CreateBmfNetworkInterfaces(struct interface* skipThisIntf);
+void AddInterface(struct interface* newIntf);
+void CloseBmfNetworkInterfaces(void);
+int AddNonOlsrBmfIf(const char* ifName, void* data, set_plugin_parameter_addon addon);
+int IsNonOlsrBmfIf(const char* ifName);
+void CheckAndUpdateLocalBroadcast(unsigned char* ipPacket, union olsr_ip_addr* broadAddr);
+void AddMulticastRoute(void);
+void DeleteMulticastRoute(void);
+
+#endif /* _BMF_NETWORKINTERFACES_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/Packet.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/Packet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,238 @@
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : Packet.c
+ * Description: IP packet and Ethernet frame processing functions
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "Packet.h"
+
+/* System includes */
+#include <stddef.h> /* NULL */
+#include <assert.h> /* assert() */
+#include <string.h> /* memcpy() */
+#include <sys/types.h> /* u_int8_t, u_int16_t, u_int32_t */
+#include <netinet/in.h> /* ntohs(), htons() */
+#include <netinet/ip.h> /* struct iphdr */
+
+/* -------------------------------------------------------------------------
+ * Function   : IsIpFragment
+ * Description: Check if an IP packet is an IP fragment
+ * Input      : ipPacket - the IP packet
+ * Output     : none
+ * Return     : true (1) or false (0)
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+int IsIpFragment(unsigned char* ipPacket)
+{
+  struct ip* iph;
+
+  assert(ipPacket != NULL);
+
+  iph = (struct ip*) ipPacket;
+  if ((ntohs(iph->ip_off) & IP_OFFMASK) != 0)
+  {
+    return 1;
+  }
+  return 0;
+} /* IsIpFragment */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetIpTotalLength
+ * Description: Retrieve the total length of the IP packet (in bytes) of
+ *              an IP packet
+ * Input      : ipPacket - the IP packet
+ * Output     : none
+ * Return     : IP packet length
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+u_int16_t GetIpTotalLength(unsigned char* ipPacket)
+{
+  struct iphdr* iph;
+
+  assert(ipPacket != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  return ntohs(iph->tot_len);
+} /* GetIpTotalLength */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetIpHeaderLength
+ * Description: Retrieve the IP header length (in bytes) of an IP packet
+ * Input      : ipPacket - the IP packet
+ * Output     : none
+ * Return     : IP header length
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+unsigned int GetIpHeaderLength(unsigned char* ipPacket)
+{
+  struct iphdr* iph;
+
+  assert(ipPacket != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  return iph->ihl << 2;
+} /* GetIpHeaderLength */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetTtl
+ * Description: Retrieve the TTL (Time To Live) value from the IP header of
+ *              an IP packet
+ * Input      : ipPacket - the IP packet
+ * Output     : none
+ * Return     : TTL value
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+u_int8_t GetTtl(unsigned char* ipPacket)
+{
+  struct iphdr* iph;
+
+  assert(ipPacket != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  return iph->ttl;
+} /* GetTtl */
+
+/* -------------------------------------------------------------------------
+ * Function   : SaveTtlAndChecksum
+ * Description: Save the TTL (Time To Live) value and IP checksum as found in
+ *              the IP header of an IP packet
+ * Input      : ipPacket - the IP packet
+ * Output     : sttl - the TTL and checksum values
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+void SaveTtlAndChecksum(unsigned char* ipPacket, struct TSaveTtl* sttl)
+{
+  struct iphdr* iph;
+
+  assert(ipPacket != NULL && sttl != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  sttl->ttl = iph->ttl;
+  sttl->check = ntohs(iph->check);
+} /* SaveTtlAndChecksum */
+
+/* -------------------------------------------------------------------------
+ * Function   : RestoreTtlAndChecksum
+ * Description: Restore the TTL (Time To Live) value and IP checksum in
+ *              the IP header of an IP packet
+ * Input      : ipPacket - the IP packet
+ *              sttl - the TTL and checksum values
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+void RestoreTtlAndChecksum(unsigned char* ipPacket, struct TSaveTtl* sttl)
+{
+  struct iphdr* iph;
+
+  assert(ipPacket != NULL && sttl != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+  iph->ttl = sttl->ttl;
+  iph->check = htons(sttl->check);
+} /* RestoreTtlAndChecksum */
+
+/* -------------------------------------------------------------------------
+ * Function   : DecreaseTtlAndUpdateHeaderChecksum
+ * Description: For an IP packet, decrement the TTL value and update the IP header
+ *              checksum accordingly.
+ * Input      : ipPacket - the IP packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : See also RFC1141
+ * ------------------------------------------------------------------------- */
+void DecreaseTtlAndUpdateHeaderChecksum(unsigned char* ipPacket)
+{
+  struct iphdr* iph;
+  u_int32_t sum;
+
+  assert(ipPacket != NULL);
+
+  iph = (struct iphdr*) ipPacket;
+
+  iph->ttl--; /* decrement ttl */
+  sum = ntohs(iph->check) + 0x100; /* increment checksum high byte */
+  iph->check = htons(sum + (sum>>16)); /* add carry */
+} /* DecreaseTtlAndUpdateHeaderChecksum */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetIpHeader
+ * Description: Retrieve the IP header from BMF encapsulation UDP data
+ * Input      : encapsulationUdpData - the encapsulation UDP data
+ * Output     : none
+ * Return     : IP header
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+struct ip* GetIpHeader(unsigned char* encapsulationUdpData)
+{
+  return (struct ip*)(encapsulationUdpData + ENCAP_HDR_LEN);
+} /* GetIpHeader */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetIpPacket
+ * Description: Retrieve the IP packet from BMF encapsulation UDP data
+ * Input      : encapsulationUdpData - the encapsulation UDP data
+ * Output     : none
+ * Return     : The IP packet
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+unsigned char* GetIpPacket(unsigned char* encapsulationUdpData)
+{
+  return encapsulationUdpData + ENCAP_HDR_LEN;
+} /* GetIpPacket */
+
+/* -------------------------------------------------------------------------
+ * Function   : GetEncapsulationUdpDataLength
+ * Description: Return the length of BMF encapsulation UDP data
+ * Input      : encapsulationUdpData - the encapsulation UDP data
+ * Output     : none
+ * Return     : The encapsulation data length
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+u_int16_t GetEncapsulationUdpDataLength(unsigned char* encapsulationUdpData)
+{
+  return GetIpTotalLength(GetIpPacket(encapsulationUdpData)) + ENCAP_HDR_LEN;
+} /* GetEncapsulationUdpDataLength */
+
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/Packet.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/Packet.h	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,88 @@
+#ifndef _BMF_PACKET_H
+#define _BMF_PACKET_H
+
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : Packet.h
+ * Description: BMF and IP packet processing functions
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+/* System includes */
+#include <net/if.h> /* IFNAMSIZ, IFHWADDRLEN */
+#include <sys/types.h> /* u_int8_t, u_int16_t */
+
+/* BMF-encapsulated packets are Ethernet-IP-UDP packets, which start
+ * with a 8-bytes BMF header (struct TEncapHeader), followed by the
+ * encapsulated Ethernet-IP packet itself */
+
+struct TEncapHeader
+{
+  /* Use a standard Type-Length-Value (TLV) element */
+  u_int8_t type;
+  u_int8_t len;
+  u_int16_t reserved; /* Always 0 */
+  u_int32_t crc32;
+} __attribute__((__packed__));
+
+#define ENCAP_HDR_LEN ((int)sizeof(struct TEncapHeader))
+#define BMF_ENCAP_TYPE 1
+#define BMF_ENCAP_LEN 6
+
+struct TSaveTtl
+{
+  u_int8_t ttl;
+  u_int16_t check;
+} __attribute__((__packed__));
+
+int IsIpFragment(unsigned char* ipPacket);
+u_int16_t GetIpTotalLength(unsigned char* ipPacket);
+unsigned int GetIpHeaderLength(unsigned char* ipPacket);
+u_int8_t GetTtl(unsigned char* ipPacket);
+void SaveTtlAndChecksum(unsigned char* ipPacket, struct TSaveTtl* sttl);
+void RestoreTtlAndChecksum(unsigned char* ipPacket, struct TSaveTtl* sttl);
+void DecreaseTtlAndUpdateHeaderChecksum(unsigned char* ipPacket);
+struct ip* GetIpHeader(unsigned char* encapsulationUdpData);
+unsigned char* GetIpPacket(unsigned char* encapsulationUdpData);
+u_int16_t GetEncapsulationUdpDataLength(unsigned char* encapsulationUdpData);
+
+#endif /* _BMF_PACKET_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/PacketHistory.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/PacketHistory.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,324 @@
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : PacketHistory.c
+ * Description: Functions for keeping and accessing the history of processed
+ *              multicast IP packets.
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "PacketHistory.h"
+
+/* System includes */
+#include <stddef.h> /* NULL */
+#include <assert.h> /* assert() */
+#include <string.h> /* memset */
+#include <sys/types.h> /* u_int16_t, u_int32_t */
+#include <netinet/ip.h> /* struct iphdr */
+#include <stdlib.h> /* atoi, malloc */
+
+/* OLSRD includes */
+#include "defs.h" /* GET_TIMESTAMP, TIMED_OUT */
+#include "olsr.h" /* OLSR_PRINTF */
+#include "scheduler.h" /* now_times */
+
+/* Plugin includes */
+#include "Packet.h"
+
+static struct TDupEntry* PacketHistory[HISTORY_HASH_SIZE];
+
+#define CRC_UPTO_NBYTES 256
+
+#if 0
+/* -------------------------------------------------------------------------
+ * Function   : CalcCrcCcitt
+ * Description: Calculate 16-bits CRC according to CRC-CCITT specification
+ * Input      : buffer - the bytes to calculate the CRC value over
+ *              len - the number of bytes to calculate the CRC value over
+ * Output     : none
+ * Return     : CRC-16 value
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+static u_int16_t CalcCrcCcitt(unsigned char* buffer, ssize_t len)
+{
+  /* Initial value of 0xFFFF should be 0x1D0F according to
+   * www.joegeluso.com/software/articles/ccitt.htm */
+  u_int16_t crc = 0xFFFF;
+  int i;
+
+  assert(buffer != NULL);
+
+  for (i = 0; i < len; i++)
+  {
+    crc  = (unsigned char)(crc >> 8) | (crc << 8);
+    crc ^= buffer[i];
+    crc ^= (unsigned char)(crc & 0xff) >> 4;
+    crc ^= (crc << 8) << 4;
+    crc ^= ((crc & 0xff) << 4) << 1;
+  }
+  return crc;
+} /* CalcCrcCcitt */
+#endif
+
+/* -------------------------------------------------------------------------
+ * Function   : GenerateCrc32Table
+ * Description: Generate the table of CRC remainders for all possible bytes,
+ *              according to CRC-32-IEEE 802.3
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+#define CRC32_POLYNOMIAL 0xedb88320UL /* bit-inverse of 0x04c11db7UL */
+
+static unsigned long CrcTable[256];
+
+static void GenerateCrc32Table(void)
+{
+  int i, j;
+  u_int32_t crc;
+  for (i = 0; i < 256; i++)
+  {
+    crc = (u_int32_t) i;
+    for (j = 0; j < 8; j++)
+    {
+      if (crc & 1)
+      {
+        crc = (crc >> 1) ^ CRC32_POLYNOMIAL;
+      }
+      else
+      {
+        crc = (crc >> 1);
+      }
+    }
+    CrcTable[i] = crc;
+  } /* for */
+} /* GenerateCrc32Table */
+
+/* -------------------------------------------------------------------------
+ * Function   : CalcCrc32
+ * Description: Calculate CRC-32 according to CRC-32-IEEE 802.3
+ * Input      : buffer - the bytes to calculate the CRC value over
+ *              len - the number of bytes to calculate the CRC value over
+ * Output     : none
+ * Return     : CRC-32 value
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+static u_int32_t CalcCrc32(unsigned char* buffer, ssize_t len)
+{
+  int i, j;
+  u_int32_t crc = 0xffffffffUL;
+  for (i = 0; i < len; i++)
+  {
+    j = ((int) (crc & 0xFF) ^ *buffer++);
+    crc = (crc >> 8) ^ CrcTable[j];
+  }
+  return crc ^ 0xffffffffUL;
+} /* CalcCrc32 */
+
+/* -------------------------------------------------------------------------
+ * Function   : PacketCrc32
+ * Description: Calculates the CRC-32 value for an IP packet
+ * Input      : ipPacket - the IP packet
+ *              len - the number of octets in the IP packet
+ * Output     : none
+ * Return     : 32-bits CRC value
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+u_int32_t PacketCrc32(unsigned char* ipPacket, ssize_t len)
+{
+  struct TSaveTtl sttl;
+  struct ip* ipHeader;
+  u_int32_t result;
+
+  assert(ipPacket != NULL);
+
+  /* Skip TTL: in a multi-homed OLSR-network, the same multicast packet
+   * may enter the network multiple times, each copy differing only in its
+   * TTL value. BMF must not calculate a different CRC for packets that
+   * differ only in TTL. Skip also the IP-header checksum, because it changes
+   * along with TTL. Besides, it is not a good idea to calculate a CRC over
+   * data that already contains a checksum.
+   *
+   * Clip number of bytes over which CRC is calculated to prevent
+   * long packets from possibly claiming too much CPU resources. */
+  assert(len > 0);
+  if (len > CRC_UPTO_NBYTES)
+  {
+    len = CRC_UPTO_NBYTES;
+  }
+
+  SaveTtlAndChecksum(ipPacket, &sttl);
+
+  ipHeader = (struct ip*)ipPacket;
+  ipHeader->ip_ttl = 0xFF; /* fixed value of TTL for CRC-32 calculation */
+  ipHeader->ip_sum = 0x5A5A; /* fixed value of IP header checksum for CRC-32 calculation */
+
+  result = CalcCrc32(ipPacket, len);
+
+  RestoreTtlAndChecksum(ipPacket, &sttl);
+  return result;
+} /* PacketCrc32 */
+
+/* -------------------------------------------------------------------------
+ * Function   : Hash
+ * Description: Calculates a hash value from a 32-bit value
+ * Input      : from32 - 32-bit value
+ * Output     : none
+ * Return     : hash value
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+u_int32_t Hash(u_int32_t from32)
+{
+  return ((from32 >> N_HASH_BITS) + from32) & ((1 << N_HASH_BITS) - 1);
+} /* Hash */
+
+/* -------------------------------------------------------------------------
+ * Function   : InitPacketHistory
+ * Description: Initialize the packet history table and CRC-32 table
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : PacketHistory
+ * ------------------------------------------------------------------------- */
+void InitPacketHistory(void)
+{
+  int i;
+
+  GenerateCrc32Table();
+
+  for(i = 0; i < HISTORY_HASH_SIZE; i++)
+  {
+    PacketHistory[i] = NULL;
+  }
+} /* InitPacketHistory */
+
+/* -------------------------------------------------------------------------
+ * Function   : CheckAndMarkRecentPacket
+ * Description: Check if this packet was seen recently, then record the fact
+ *              that this packet was seen recently.
+ * Input      : crc32 - 32-bits crc value of the packet
+ * Output     : none
+ * Return     : not recently seen (0), recently seen (1)
+ * Data Used  : PacketHistory
+ * ------------------------------------------------------------------------- */
+int CheckAndMarkRecentPacket(u_int32_t crc32)
+{
+  u_int32_t idx;
+  struct TDupEntry* walker;
+  struct TDupEntry* newEntry;
+
+  idx = Hash(crc32);
+  assert(idx < HISTORY_HASH_SIZE);
+
+  for (walker = PacketHistory[idx]; walker != NULL; walker = walker->next)
+  {
+    if (walker->crc32 == crc32)
+    {
+      /* Found duplicate entry */
+
+      /* Always mark as "seen recently": refresh time-out */
+      walker->timeOut = GET_TIMESTAMP(HISTORY_HOLD_TIME);
+
+      return 1;
+    } /* if */
+  } /* for */
+
+  /* No duplicate entry found: create one */
+  newEntry = malloc(sizeof(struct TDupEntry));
+  if (newEntry != NULL)
+  {
+    newEntry->crc32 = crc32;
+    newEntry->timeOut = GET_TIMESTAMP(HISTORY_HOLD_TIME);
+
+    /* Add new entry at the front of the list */
+    newEntry->next = PacketHistory[idx];
+    PacketHistory[idx] = newEntry;
+  }
+
+  return 0;
+} /* CheckAndMarkRecentPacket */
+
+/* -------------------------------------------------------------------------
+ * Function   : PrunePacketHistory
+ * Description: Prune the packet history table.
+ * Input      : useless - not used
+ * Output     : none
+ * Return     : none
+ * Data Used  : PacketHistory
+ * ------------------------------------------------------------------------- */
+void PrunePacketHistory(void* useless __attribute__((unused)))
+{
+  uint i;
+  for (i = 0; i < HISTORY_HASH_SIZE; i++)
+  {
+    if (PacketHistory[i] != NULL)
+    {
+      struct TDupEntry* nextEntry = PacketHistory[i];
+      struct TDupEntry* prevEntry = NULL;
+      while (nextEntry != NULL)
+      {
+        struct TDupEntry* entry = nextEntry;
+        nextEntry = entry->next;
+
+        if (TIMED_OUT(entry->timeOut))
+        {
+          /* De-queue */
+          if (prevEntry != NULL)
+          {
+            prevEntry->next = entry->next;
+          }
+          else
+          {
+            PacketHistory[i] = entry->next;
+          } /* if */
+
+          /* De-allocate memory */
+          free(entry);
+	      }
+	      else
+	      {
+	        prevEntry = entry;
+	      } /* if */
+      } /* while */
+    } /* if (PacketHistory[i] != NULL) */
+  } /* for (i = ...) */
+} /* PrunePacketHistory */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/PacketHistory.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/PacketHistory.h	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,75 @@
+#ifndef _BMF_PACKETHISTORY_H
+#define _BMF_PACKETHISTORY_H
+
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : PacketHistory.h
+ * Description: Functions for keeping and accessing the history of processed
+ *              multicast IP packets.
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+/* System includes */
+#include <sys/types.h> /* ssize_t */
+#include <sys/times.h> /* clock_t */
+
+#define N_HASH_BITS 12
+#define HISTORY_HASH_SIZE (1 << N_HASH_BITS)
+
+/* Time-out of duplicate entries, in milliseconds */
+#define HISTORY_HOLD_TIME 3000
+
+struct TDupEntry
+{
+  u_int32_t crc32;
+  clock_t timeOut;
+  struct TDupEntry* next;
+};
+
+void InitPacketHistory(void);
+u_int32_t PacketCrc32(unsigned char* ipPkt, ssize_t len);
+u_int32_t Hash(u_int32_t from32);
+void MarkRecentPacket(u_int32_t crc32);
+int CheckAndMarkRecentPacket(u_int32_t crc32);
+void PrunePacketHistory(void*);
+
+#endif /* _BMF_PACKETHISTORY_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/mdns.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/mdns.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,1174 @@
+/*
+ * OLSR MDNS plugin.
+ * Written by Saverio Proto.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+//#define _MULTI_THREADED
+
+#include "mdns.h"
+
+/* System includes */
+#include <stddef.h> /* NULL */
+#include <sys/types.h> /* ssize_t */
+#include <string.h> /* strerror() */
+#include <stdarg.h> /* va_list, va_start, va_end */
+#include <errno.h> /* errno */
+#include <assert.h> /* assert() */
+#include <linux/if_ether.h> /* ETH_P_IP */
+#include <linux/if_packet.h> /* struct sockaddr_ll, PACKET_MULTICAST */
+//#include <pthread.h> /* pthread_t, pthread_create() */
+#include <signal.h> /* sigset_t, sigfillset(), sigdelset(), SIGINT */
+#include <netinet/ip.h> /* struct ip */
+#include <netinet/udp.h> /* struct udphdr */
+#include <unistd.h> /* close() */
+
+#include <netinet/in.h>
+#include <netinet/ip6.h>
+
+/* OLSRD includes */
+#include "plugin_util.h" /* set_plugin_int */
+#include "defs.h" /* olsr_cnf, OLSR_PRINTF */
+#include "ipcalc.h"
+#include "olsr.h" /* OLSR_PRINTF */
+#include "mid_set.h" /* mid_lookup_main_addr() */
+#include "mpr_selector_set.h" /* olsr_lookup_mprs_set() */
+#include "link_set.h" /* get_best_link_to_neighbor() */
+#include "net_olsr.h" /* ipequal */
+
+/* plugin includes */
+#include "NetworkInterfaces.h" /* TBmfInterface, CreateBmfNetworkInterfaces(), CloseBmfNetworkInterfaces() */
+#include "Address.h" /* IsMulticast() */
+#include "Packet.h" /* ENCAP_HDR_LEN, BMF_ENCAP_TYPE, BMF_ENCAP_LEN etc. */
+#include "PacketHistory.h" /* InitPacketHistory() */
+
+//static pthread_t mdnsThread;
+//static int mdnsThreadRunning = 0;
+
+/* -------------------------------------------------------------------------
+ * Function   : PacketReceivedFromOLSR
+ * Description: Handle a received packet from a OLSR message
+ * Input      : ipPacket into an unsigned char and the lenght of the packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : BmfInterfaces
+ * ------------------------------------------------------------------------- */
+static void PacketReceivedFromOLSR(
+  unsigned char* encapsulationUdpData, int len)
+{
+  struct ip* ipHeader; /* IP header inside the encapsulated IP packet */
+  union olsr_ip_addr mcSrc; /* Original source of the encapsulated multicast packet */
+  union olsr_ip_addr mcDst; /* Multicast destination of the encapsulated packet */
+  struct TBmfInterface* walker;
+  ipHeader = (struct ip*) encapsulationUdpData;
+  mcSrc.v4 = ipHeader->ip_src;
+  mcDst.v4 = ipHeader->ip_dst;
+
+  OLSR_PRINTF(3, "MDNS PLUGIN got packet from OLSR message\n");
+
+
+  /* Check with each network interface what needs to be done on it */
+  for (walker = BmfInterfaces; walker != NULL; walker = walker->next)
+  {
+    /* To a non-OLSR interface: unpack the encapsulated IP packet and forward it */
+    if (walker->olsrIntf == NULL)
+    {
+      int nBytesWritten;
+      struct sockaddr_ll dest;
+
+      memset(&dest, 0, sizeof(dest));
+      dest.sll_family = AF_PACKET;
+      if ((encapsulationUdpData[0] & 0xf0) == 0x40) dest.sll_protocol = htons(ETH_P_IP);
+      if ((encapsulationUdpData[0] & 0xf0) == 0x60) dest.sll_protocol = htons(ETH_P_IPV6);
+      //TODO: if packet is not IP die here
+      dest.sll_ifindex = if_nametoindex(walker->ifName);
+      dest.sll_halen = IFHWADDRLEN;
+
+      /* Use all-ones as destination MAC address. When the IP destination is
+       * a multicast address, the destination MAC address should normally also
+       * be a multicast address. E.g., when the destination IP is 224.0.0.1,
+       * the destination MAC should be 01:00:5e:00:00:01. However, it does not
+       * seem to matter when the destination MAC address is set to all-ones
+       * in that case. */
+      memset(dest.sll_addr, 0xFF, IFHWADDRLEN);
+
+      nBytesWritten = sendto(
+        walker->capturingSkfd,
+        encapsulationUdpData,
+        len,
+        0,
+        (struct sockaddr*) &dest,
+        sizeof(dest));
+      if (nBytesWritten != len)
+      {
+        BmfPError("sendto() error forwarding unpacked encapsulated pkt on \"%s\"", walker->ifName);
+      }
+      else
+      {
+
+        OLSR_PRINTF(
+          2,
+          "%s: --> unpacked and forwarded on \"%s\"\n",
+          PLUGIN_NAME_SHORT,
+          walker->ifName);
+     }
+    } /* if (walker->olsrIntf == NULL) */
+} 
+} /* PacketReceivedFromOLSR */
+
+
+
+bool
+olsr_parser(union olsr_message *m,
+            struct interface *in_if __attribute__((unused)),
+            union olsr_ip_addr *ipaddr)
+{
+        union olsr_ip_addr originator;
+        int size;
+        olsr_reltime vtime;
+        OLSR_PRINTF(2, "MDNS PLUGIN: Received msg in parser\n");
+        /* Fetch the originator of the messsage */
+        if(olsr_cnf->ip_version == AF_INET) {
+                memcpy(&originator, &m->v4.originator, olsr_cnf->ipsize);
+		vtime = me_to_reltime(m->v4.olsr_vtime);
+                size = ntohs(m->v4.olsr_msgsize);
+        } else {
+                memcpy(&originator, &m->v6.originator, olsr_cnf->ipsize);
+		vtime = me_to_reltime(m->v6.olsr_vtime);
+  	        size = ntohs(m->v6.olsr_msgsize);
+        }    
+
+        /* Check if message originated from this node.
+ *         If so - back off */
+        if(ipequal(&originator, &olsr_cnf->main_addr))
+                return false;
+
+        /* Check that the neighbor this message was received from is symmetric.
+ *         If not - back off*/
+        if(check_neighbor_link(ipaddr) != SYM_LINK) {
+                struct ipaddr_str strbuf;
+                OLSR_PRINTF(3, "NAME PLUGIN: Received msg from NON SYM neighbor %s\n", olsr_ip_to_string(&strbuf, ipaddr));
+                return false;
+        }    
+	
+        if(olsr_cnf->ip_version == AF_INET){
+	PacketReceivedFromOLSR((unsigned char*) &m->v4.message,size-12);
+	}
+	else {
+	PacketReceivedFromOLSR((unsigned char*) &m->v6.message,size-12-96);
+	}
+        /* Forward the message */
+        return 1;
+}
+
+//Sends a packet in the OLSR network
+void
+olsr_mdns_gen(unsigned char* packet, int len)
+{
+        /* send buffer: huge */
+        char buffer[10240];
+        union olsr_message *message = (union olsr_message *)buffer;
+        struct interface *ifn;
+        //int namesize;
+
+        /* fill message */
+        if(olsr_cnf->ip_version == AF_INET)
+        {    
+                /* IPv4 */
+                message->v4.olsr_msgtype = MESSAGE_TYPE;
+                message->v4.olsr_vtime = reltime_to_me(MDNS_VALID_TIME * MSEC_PER_SEC);
+                memcpy(&message->v4.originator, &olsr_cnf->main_addr, olsr_cnf->ipsize);
+                message->v4.ttl = MAX_TTL;
+                message->v4.hopcnt = 0; 
+                message->v4.seqno = htons(get_msg_seqno());
+
+                message->v4.olsr_msgsize = htons(len+12);
+
+		memcpy(&message->v4.message,packet,len);
+                len=len+12;
+        }    
+        else 
+        {    
+                /* IPv6 */
+                message->v6.olsr_msgtype = MESSAGE_TYPE;
+                message->v6.olsr_vtime = reltime_to_me(MDNS_VALID_TIME * MSEC_PER_SEC);
+                memcpy(&message->v6.originator, &olsr_cnf->main_addr, olsr_cnf->ipsize);
+                message->v6.ttl = MAX_TTL;
+                message->v6.hopcnt = 0; 
+                message->v6.seqno = htons(get_msg_seqno());
+
+                message->v6.olsr_msgsize = htons(len+12+96);
+		memcpy(&message->v6.message,packet,len);
+                len=len+12+96;
+        }    
+
+        /* looping trough interfaces */
+		for (ifn = ifnet; ifn; ifn = ifn->int_next) {
+                OLSR_PRINTF(1, "MDNS PLUGIN: Generating packet - [%s]\n", ifn->int_name);
+
+                if(net_outbuffer_push(ifn, message, len) != len) {
+                        /* send data and try again */
+                        net_output(ifn);
+                        if(net_outbuffer_push(ifn, message, len) != len) {
+                                OLSR_PRINTF(1, "MDNS PLUGIN: could not send on interface: %s\n", ifn->int_name);
+                        }    
+                }    
+        } 
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : BmfPError
+ * Description: Prints an error message at OLSR debug level 1.
+ *              First the plug-in name is printed. Then (if format is not NULL
+ *              and *format is not empty) the arguments are printed, followed
+ *              by a colon and a blank. Then the message and a new-line.
+ * Input      : format, arguments
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+
+void BmfPError(const char* format, ...)
+{
+#define MAX_STR_DESC 255
+#ifndef NODEBUG
+  char* strErr = strerror(errno);
+#endif
+  char strDesc[MAX_STR_DESC];
+
+  /* Rely on short-circuit boolean evaluation */
+  if (format == NULL || *format == '\0')
+  {
+    OLSR_PRINTF(1, "%s: %s\n", PLUGIN_NAME, strErr);
+  }
+  else
+  {
+    va_list arglist;
+
+    OLSR_PRINTF(1, "%s: ", PLUGIN_NAME);
+
+    va_start(arglist, format);
+    vsnprintf(strDesc, MAX_STR_DESC, format, arglist);
+    va_end(arglist);
+
+    strDesc[MAX_STR_DESC - 1] = '\0'; /* Ensures null termination */
+
+    OLSR_PRINTF(1, "%s: %s\n", strDesc, strErr);
+  }
+} /* BmfPError */
+
+/* -------------------------------------------------------------------------
+ * Function   : MainAddressOf
+ * Description: Lookup the main address of a node
+ * Input      : ip - IP address of the node
+ * Output     : none
+ * Return     : The main IP address of the node
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+union olsr_ip_addr* MainAddressOf(union olsr_ip_addr* ip)
+{
+  union olsr_ip_addr* result;
+
+  /* TODO: mid_lookup_main_addr() is not thread-safe! */
+  result = mid_lookup_main_addr(ip);
+  if (result == NULL)
+  {
+    result = ip;
+  }
+  return result;
+} /* MainAddressOf */
+
+/* -------------------------------------------------------------------------
+ * Function   : EncapsulateAndForwardPacket
+ * Description: Encapsulate a captured raw IP packet and forward it
+ * Input      : intf - the network interface on which to forward the packet
+ *              encapsulationUdpData - The encapsulation header, followed by
+ *                the encapsulated IP packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * ------------------------------------------------------------------------- */
+//static void EncapsulateAndForwardPacket(
+//  struct TBmfInterface* intf,
+//  unsigned char* encapsulationUdpData)
+//{
+////  /* The packet */
+//  u_int16_t udpDataLen = GetEncapsulationUdpDataLength(encapsulationUdpData);
+//
+//  /* The next destination(s) */
+//  struct TBestNeighbors bestNeighborLinks;
+//  struct link_entry* bestNeighbor;
+//
+//  int nPossibleNeighbors = 0;
+//  struct sockaddr_in forwardTo; /* Next destination of encapsulation packet */
+//  int nPacketsToSend;
+//  int sendUnicast; /* 0 = send broadcast; 1 = send unicast */
+//
+//  int i;
+//
+//  /* Find at most 'FanOutLimit' best neigbors to forward the packet to */
+//  FindNeighbors(&bestNeighborLinks, &bestNeighbor, intf, NULL, NULL, NULL, &nPossibleNeighbors);
+//
+//  if (nPossibleNeighbors <= 0)
+//  {
+//    OLSR_PRINTF(
+//      8,
+//      "%s: --> not encap-forwarding on \"%s\": there is no neighbor that needs my retransmission\n",
+//      PLUGIN_NAME_SHORT,
+//      intf->ifName);
+//    return;
+//  }
+//
+//  /* Compose destination of encapsulation packet */
+//
+//  memset(&forwardTo, 0, sizeof(forwardTo));
+//  forwardTo.sin_family = AF_INET;
+//  forwardTo.sin_port = htons(BMF_ENCAP_PORT);
+//
+//  /* Start by filling in the local broadcast address. This may be overwritten later. */
+//  forwardTo.sin_addr = intf->broadAddr.v4;
+//
+//  /* - If the BMF mechanism is BM_UNICAST_PROMISCUOUS, always send just one
+//   *   unicast packet (to the best neighbor).
+//   * - But if the BMF mechanism is BM_BROADCAST,
+//   *   - send 'nPossibleNeighbors' unicast packets if there are up to
+//   *     'FanOutLimit' possible neighbors,
+//   *   - if there are more than 'FanOutLimit' possible neighbors, then
+//   *     send a (WLAN-air-expensive, less reliable) broadcast packet. */
+//  if (BmfMechanism == BM_UNICAST_PROMISCUOUS)
+//  {
+//    /* One unicast packet to the best neighbor */
+//    nPacketsToSend = 1;
+//    sendUnicast = 1;
+//    bestNeighborLinks.links[0] = bestNeighbor;
+//  }
+//  else /* BmfMechanism == BM_BROADCAST */
+//  {
+//    if (nPossibleNeighbors <= FanOutLimit)
+//    {
+//      /* 'nPossibleNeighbors' unicast packets */
+//      nPacketsToSend = nPossibleNeighbors;
+//      sendUnicast = 1;
+//    }
+//    else /* nPossibleNeighbors > FanOutLimit */
+//    {
+//      /* One broadcast packet, possibly retransmitted as specified in the
+//       * 'BroadcastRetransmitCount' plugin parameter */
+//      nPacketsToSend = BroadcastRetransmitCount;
+//      sendUnicast = 0;
+//    } /* if */
+//  } /* if */
+//
+//  for (i = 0; i < nPacketsToSend; i++)
+//  {
+//    int nBytesWritten;
+//
+//    if (sendUnicast == 1)
+//    {
+//      /* For unicast, overwrite the local broadcast address which was filled in above */
+//      forwardTo.sin_addr = bestNeighborLinks.links[i]->neighbor_iface_addr.v4;
+//    }
+//
+//    /* Forward the BMF packet via the encapsulation socket */
+//    nBytesWritten = sendto(
+//      intf->encapsulatingSkfd,
+//      encapsulationUdpData,
+//      udpDataLen,
+//      MSG_DONTROUTE,
+//      (struct sockaddr*) &forwardTo,
+//      sizeof(forwardTo));
+//
+//    /* Evaluate and display result */
+//    if (nBytesWritten != udpDataLen)
+//    {
+//      BmfPError("sendto() error forwarding pkt on \"%s\"", intf->ifName);
+//    }
+//    else
+//    {
+//      /* Increase counter */
+//      intf->nBmfPacketsTx++;
+//
+//      OLSR_PRINTF(
+//        8,
+//        "%s: --> encapsulated and forwarded on \"%s\" to %s\n",
+//        PLUGIN_NAME_SHORT,
+//        intf->ifName,
+//        inet_ntoa(forwardTo.sin_addr));
+//    } /* if (nBytesWritten != udpDataLen) */
+//  } /* for */
+//} /* EncapsulateAndForwardPacket */
+
+/* -------------------------------------------------------------------------
+ * Function   : BmfPacketCaptured
+ * Description: Handle a captured IP packet
+ * Input      : intf - the network interface on which the packet was captured
+ *              sllPkttype - the type of packet. Either PACKET_OUTGOING,
+ *                PACKET_BROADCAST or PACKET_MULTICAST.
+ *              encapsulationUdpData - space for the encapsulation header, followed by
+ *                the captured IP packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : BmfInterfaces
+ * Notes      : The IP packet is assumed to be captured on a socket of family
+ *              PF_PACKET and type SOCK_DGRAM (cooked).
+ * ------------------------------------------------------------------------- */
+static void BmfPacketCaptured(
+  //struct TBmfInterface* intf,
+  //unsigned char sllPkttype,
+  unsigned char* encapsulationUdpData,
+  int nBytes)
+{
+  union olsr_ip_addr src; /* Source IP address in captured packet */
+  union olsr_ip_addr dst; /* Destination IP address in captured packet */
+  union olsr_ip_addr* origIp; /* Main OLSR address of source of captured packet */
+  //struct TBmfInterface* walker;
+  //int isFromOlsrIntf;
+  //int isFromOlsrNeighbor;
+  //int iAmMpr;
+  //unsigned char* ipPacket; /* The captured IP packet... */
+  //u_int16_t ipPacketLen; /* ...and its length */
+  struct ip* ipHeader; /* The IP header inside the captured IP packet */
+  struct ip6_hdr* ipHeader6; /* The IP header inside the captured IP packet */
+  //u_int32_t crc32;
+  //struct TEncapHeader* encapHdr;
+  //struct ipaddr_str srcBuf, dstBuf;
+  struct udphdr* udpHeader;
+  u_int16_t destPort;
+  
+  if ((encapsulationUdpData[0] & 0xf0) == 0x40) { //IPV4
+
+            ipHeader = (struct ip*) encapsulationUdpData;
+
+            dst.v4 = ipHeader->ip_dst;
+
+            /* Only forward multicast packets. If configured, also forward local broadcast packets */
+            if (IsMulticast(&dst))
+            {
+              /* continue */
+            }
+            else
+            {
+              return;
+            }
+            if (ipHeader->ip_p != SOL_UDP)
+            {
+              /* Not UDP */
+              OLSR_PRINTF(1,"NON UDP PACKET\n");
+              return; /* for */
+            }
+            udpHeader = (struct udphdr*)(encapsulationUdpData + GetIpHeaderLength(encapsulationUdpData));
+            destPort = ntohs(udpHeader->dest);
+            if (destPort != 5353)
+            {
+               return; 
+            }
+  }//END IPV4
+
+  else if ((encapsulationUdpData[0] & 0xf0) == 0x60) { //IPv6
+  
+            ipHeader6 = (struct ip6_hdr*) encapsulationUdpData;
+            if (ipHeader6->ip6_dst.s6_addr[0] == 0xff) //Multicast
+            {
+              //Continua
+            }
+            else
+            {
+            return; //not multicast
+            }
+            if (ipHeader6->ip6_nxt != SOL_UDP)
+            {
+              /* Not UDP */
+              OLSR_PRINTF(1,"NON UDP PACKET\n");
+              return; /* for */
+            }
+            udpHeader = (struct udphdr*)(encapsulationUdpData + 40);
+            destPort = ntohs(udpHeader->dest);
+            if (destPort != 5353)
+            {
+               return; 
+            }
+  } //END IPV6
+  else return; //Is not IP packet
+
+  /* Check if the frame is captured on an OLSR-enabled interface */
+  //isFromOlsrIntf = (intf->olsrIntf != NULL); TODO: put again this check
+
+  /* Retrieve the length of the captured packet */
+  //ipPacketLen = GetIpTotalLength(ipPacket);
+
+  //src.v4 = ipHeader->ip_src;
+
+  //OLSR_PRINTF(
+  //  1,
+  //  "%s: %s pkt of %ld bytes captured on %s interface \"%s\": %s->%s\n",
+  //  PLUGIN_NAME_SHORT,
+  //  sllPkttype == PACKET_OUTGOING ? "outgoing" : "incoming",
+  //  (long)ipPacketLen,
+  //  isFromOlsrIntf ? "OLSR" : "non-OLSR",
+  //  intf->ifName,
+  //  olsr_ip_to_string(&srcBuf, &src),
+  //  olsr_ip_to_string(&dstBuf, &dst));
+
+  /* Lookup main address of source in the MID table of OLSR */
+  origIp = MainAddressOf(&src);
+
+  // send the packet to OLSR forward mechanism
+  olsr_mdns_gen(encapsulationUdpData,nBytes);
+} /* BmfPacketCaptured */
+
+
+/* -------------------------------------------------------------------------
+ * Function   : BmfEncapsulationPacketReceived
+ * Description: Handle a received BMF-encapsulation packet
+ * Input      : intf - the network interface on which the packet was received
+ *              forwardedBy - the IP node that forwarded the packet to me
+ *              forwardedTo - the destination IP address of the encapsulation
+ *                packet, in case the packet was received promiscuously.
+ *                Pass NULL if the packet is received normally (unicast or
+ *                broadcast).
+ *              encapsulationUdpData - the encapsulating IP UDP data, containting
+ *                the BMF encapsulation header, followed by the encapsulated
+ *                IP packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : BmfInterfaces
+ * ------------------------------------------------------------------------- */
+//static void BmfEncapsulationPacketReceived(
+//  struct TBmfInterface* intf,
+//  union olsr_ip_addr* forwardedBy,
+//  union olsr_ip_addr* forwardedTo,
+//  unsigned char* encapsulationUdpData)
+//{
+//  int iAmMpr; /* True (1) if I am selected as MPR by 'forwardedBy' */
+//  struct sockaddr_in forwardTo; /* Next destination of encapsulation packet */
+//  unsigned char* ipPacket; /* The encapsulated IP packet */
+//  u_int16_t ipPacketLen; /* Length of the encapsulated IP packet */
+//  struct ip* ipHeader; /* IP header inside the encapsulated IP packet */
+//  union olsr_ip_addr mcSrc; /* Original source of the encapsulated multicast packet */
+//  union olsr_ip_addr mcDst; /* Multicast destination of the encapsulated packet */
+//  struct TEncapHeader* encapsulationHdr;
+//  u_int16_t encapsulationUdpDataLen;
+//  struct TBmfInterface* walker;
+//  struct ipaddr_str mcSrcBuf, mcDstBuf, forwardedByBuf, forwardedToBuf;
+//  /* Are we talking to ourselves? */
+//  if (if_ifwithaddr(forwardedBy) != NULL)
+//  {
+//    return;
+//  }
+//
+//  /* Discard encapsulated packets received on a non-OLSR interface */
+//  if (intf->olsrIntf == NULL)
+//  {
+//    return;
+//  }
+//
+//  /* Retrieve details about the encapsulated IP packet */
+//  ipPacket = GetIpPacket(encapsulationUdpData);
+//  ipPacketLen = GetIpTotalLength(ipPacket);
+//  ipHeader = GetIpHeader(encapsulationUdpData);
+//
+//  mcSrc.v4 = ipHeader->ip_src;
+//  mcDst.v4 = ipHeader->ip_dst;
+//
+//  /* Increase counter */
+//  intf->nBmfPacketsRx++;
+//
+//  /* Beware: not possible to call olsr_ip_to_string more than 4 times in same printf */
+//  OLSR_PRINTF(
+//    8,
+//    "%s: encapsulated pkt of %ld bytes incoming on \"%s\": %s->%s, forwarded by %s to %s\n",
+//    PLUGIN_NAME_SHORT,
+//    (long)ipPacketLen,
+//    intf->ifName,
+//    olsr_ip_to_string(&mcSrcBuf, &mcSrc),
+//    olsr_ip_to_string(&mcDstBuf, &mcDst),
+//    olsr_ip_to_string(&forwardedByBuf, forwardedBy),
+//    forwardedTo != NULL ? olsr_ip_to_string(&forwardedToBuf, forwardedTo) : "me");
+//
+//  /* Get encapsulation header */
+//  encapsulationHdr = (struct TEncapHeader*) encapsulationUdpData;
+//
+//  /* Verify correct format of BMF encapsulation header */
+//  if (encapsulationHdr->type != BMF_ENCAP_TYPE ||
+//      encapsulationHdr->len != BMF_ENCAP_LEN ||
+//      ntohs(encapsulationHdr->reserved != 0))
+//  {
+//    OLSR_PRINTF(
+//      8,
+//      "%s: --> discarding: format of BMF encapsulation header not recognized\n",
+//      PLUGIN_NAME_SHORT);
+//    return;
+//  }
+//
+//  /* Check if this packet was seen recently */
+//  if (CheckAndMarkRecentPacket(ntohl(encapsulationHdr->crc32)))
+//  {
+//    /* Increase counter */
+//    intf->nBmfPacketsRxDup++;
+//
+//    OLSR_PRINTF(
+//      8,
+//      "%s: --> discarding: packet is duplicate\n",
+//      PLUGIN_NAME_SHORT);
+//    return;
+//  }
+//
+//  if (EtherTunTapFd >= 0)
+//  {
+//    /* Unpack the encapsulated IP packet and deliver it locally, by sending
+//     * a copy into the local IP stack via the EtherTunTap interface */
+//
+//    union olsr_ip_addr broadAddr;
+//    int nBytesToWrite, nBytesWritten;
+//    unsigned char* bufferToWrite;
+//
+//    /* If the encapsulated IP packet is a local broadcast packet,
+//     * update its destination address to match the subnet of the EtherTunTap
+//     * interface */
+//    broadAddr.v4.s_addr = htonl(EtherTunTapIpBroadcast);
+//    CheckAndUpdateLocalBroadcast(ipPacket, &broadAddr);
+//
+//    bufferToWrite = ipPacket;
+//    nBytesToWrite = ipPacketLen;
+//
+//    /* Write the packet into the EtherTunTap interface for local delivery */
+//    nBytesWritten = write(EtherTunTapFd, bufferToWrite, nBytesToWrite);
+//    if (nBytesWritten != nBytesToWrite)
+//    {
+//      BmfPError("write() error forwarding encapsulated pkt on \"%s\"", EtherTunTapIfName);
+//    }
+//    else
+//    {
+//      OLSR_PRINTF(
+//        8,
+//        "%s: --> unpacked and delivered locally on \"%s\"\n",
+//        PLUGIN_NAME_SHORT,
+//        EtherTunTapIfName);
+//    }
+//  } /* if (EtherTunTapFd >= 0) */
+//
+//  /* Check if I am MPR for the forwarder */
+//  /* TODO: olsr_lookup_mprs_set() is not thread-safe! */
+//  iAmMpr = (olsr_lookup_mprs_set(MainAddressOf(forwardedBy)) != NULL);
+//
+//  /* Compose destination address for next hop */
+//  memset(&forwardTo, 0, sizeof(forwardTo));
+//  forwardTo.sin_family = AF_INET;
+//  forwardTo.sin_port = htons(BMF_ENCAP_PORT);
+//
+//  /* Retrieve the number of bytes to be forwarded via the encapsulation socket */
+//  encapsulationUdpDataLen = GetEncapsulationUdpDataLength(encapsulationUdpData);
+//
+//  /* Check with each network interface what needs to be done on it */
+//  for (walker = BmfInterfaces; walker != NULL; walker = walker->next)
+//  {
+//    /* What to do with the packet on a non-OLSR interface? Unpack
+//     * encapsulated packet, and forward it.
+//     *
+//     * What to do with the packet on an OLSR interface? Forward it only
+//     * if the forwarding node has selected us as MPR (iAmMpr).
+//     *
+//     * Note that the packet is always coming in on an OLSR interface, because
+//     * it is an encapsulated BMF packet. */
+//
+//    /* To a non-OLSR interface: unpack the encapsulated IP packet and forward it */
+//    if (walker->olsrIntf == NULL)
+//    {
+//      int nBytesWritten;
+//      struct sockaddr_ll dest;
+//
+//      /* If the encapsulated IP packet is a local broadcast packet,
+//       * update its destination address to match the subnet of the network
+//       * interface on which the packet is being sent. */
+//      CheckAndUpdateLocalBroadcast(ipPacket, &walker->broadAddr);
+//
+//      memset(&dest, 0, sizeof(dest));
+//      dest.sll_family = AF_PACKET;
+//      dest.sll_protocol = htons(ETH_P_IP);
+//      dest.sll_ifindex = if_nametoindex(walker->ifName);
+//      dest.sll_halen = IFHWADDRLEN;
+//
+//      /* Use all-ones as destination MAC address. When the IP destination is
+//       * a multicast address, the destination MAC address should normally also
+//       * be a multicast address. E.g., when the destination IP is 224.0.0.1,
+//       * the destination MAC should be 01:00:5e:00:00:01. However, it does not
+//       * seem to matter when the destination MAC address is set to all-ones
+//       * in that case. */
+//      memset(dest.sll_addr, 0xFF, IFHWADDRLEN);
+//
+//      nBytesWritten = sendto(
+//        walker->capturingSkfd,
+//        ipPacket,
+//        ipPacketLen,
+//        0,
+//        (struct sockaddr*) &dest,
+//        sizeof(dest));
+//      if (nBytesWritten != ipPacketLen)
+//      {
+//        BmfPError("sendto() error forwarding unpacked encapsulated pkt on \"%s\"", walker->ifName);
+//      }
+//      else
+//      {
+//        /* Increase counter */
+//        walker->nBmfPacketsTx++;
+//
+//        OLSR_PRINTF(
+//          8,
+//          "%s: --> unpacked and forwarded on \"%s\"\n",
+//          PLUGIN_NAME_SHORT,
+//          walker->ifName);
+//      }
+//    } /* if (walker->olsrIntf == NULL) */
+//
+//    /* To an OLSR interface: forward the packet, but only if this node is
+//     * selected as MPR by the forwarding node */
+//    else if (iAmMpr)
+//    {
+//      struct TBestNeighbors bestNeighborLinks;
+//      struct link_entry* bestNeighbor;
+//      int nPossibleNeighbors;
+//      int nPacketsToSend;
+//      int sendUnicast; /* 0 = send broadcast; 1 = send unicast */
+//      int i;
+//
+//      /* Retrieve at most two best neigbors to forward the packet to */
+//      FindNeighbors(
+//        &bestNeighborLinks,
+//        &bestNeighbor,
+//        walker,
+//        &mcSrc,
+//        forwardedBy,
+//        forwardedTo,
+//        &nPossibleNeighbors);
+//
+//      if (nPossibleNeighbors <= 0)
+//      {
+//        OLSR_PRINTF(
+//          8,
+//          "%s: --> not forwarding on \"%s\": there is no neighbor that needs my retransmission\n",
+//          PLUGIN_NAME_SHORT,
+//          walker->ifName);
+//
+//        continue; /* for */
+//      }
+//
+//      /* Compose destination of encapsulation packet.
+//       * Start by filling in the local broadcast address. This may be overwritten later. */
+//      forwardTo.sin_addr = walker->broadAddr.v4;
+//
+//      /* - If the BMF mechanism is BM_UNICAST_PROMISCUOUS, always send just one
+//       *   unicast packet (to the best neighbor).
+//       * - But if the BMF mechanism is BM_BROADCAST,
+//       *   - send 'nPossibleNeighbors' unicast packets if there are up to
+//       *     'FanOutLimit' possible neighbors,
+//       *   - if there are more than 'FanOutLimit' possible neighbors, then
+//       *     send a (WLAN-air-expensive, less reliable) broadcast packet. */
+//      if (BmfMechanism == BM_UNICAST_PROMISCUOUS)
+//      {
+//        /* One unicast packet to the best neighbor */
+//        nPacketsToSend = 1;
+//        sendUnicast = 1;
+//        bestNeighborLinks.links[0] = bestNeighbor;
+//      }
+//      else /* BmfMechanism == BM_BROADCAST */
+//      {
+//        if (nPossibleNeighbors <= FanOutLimit)
+//        {
+//          /* 'nPossibleNeighbors' unicast packets */
+//          nPacketsToSend = nPossibleNeighbors;
+//          sendUnicast = 1;
+//        }
+//        else /* nPossibleNeighbors > FanOutLimit */
+//        {
+//          /* One broadcast packet, possibly retransmitted as specified in the
+//           * 'BroadcastRetransmitCount' plugin parameter */
+//          nPacketsToSend = BroadcastRetransmitCount;
+//          sendUnicast = 0;
+//        } /* if */
+//      } /* if */
+//
+//      for (i = 0; i < nPacketsToSend; i++)
+//      {
+//        int nBytesWritten;
+//
+//        if (sendUnicast)
+//        {
+//          /* For unicast, overwrite the local broadcast address which was filled in above */
+//          forwardTo.sin_addr = bestNeighborLinks.links[i]->neighbor_iface_addr.v4;
+//        }
+//
+//        /* Forward the BMF packet via the encapsulation socket */
+//        nBytesWritten = sendto(
+//          walker->encapsulatingSkfd,
+//          encapsulationUdpData,
+//          encapsulationUdpDataLen,
+//          MSG_DONTROUTE,
+//          (struct sockaddr*) &forwardTo,
+//          sizeof(forwardTo));
+//
+//        /* Evaluate and display result */
+//        if (nBytesWritten != encapsulationUdpDataLen)
+//        {
+//          BmfPError("sendto() error forwarding encapsulated pkt on \"%s\"", walker->ifName);
+//        }
+//        else
+//        {
+//          /* Increase counter */
+//          walker->nBmfPacketsTx++;
+//
+//          OLSR_PRINTF(
+//            8,
+//            "%s: --> forwarded on \"%s\" to %s\n",
+//            PLUGIN_NAME_SHORT,
+//            walker->ifName,
+//            inet_ntoa(forwardTo.sin_addr));
+//        } /* if */
+//      } /* for */
+//    }  /* else if (iAmMpr) */
+//
+//    else /* walker->olsrIntf != NULL && !iAmMpr */
+//    {
+//      struct ipaddr_str buf;
+//      /* 'walker' is an OLSR interface, but I am not selected as MPR. In that
+//       * case, don't forward. */
+//      OLSR_PRINTF(
+//        8,
+//        "%s: --> not forwarding on \"%s\": I am not selected as MPR by %s\n",
+//        PLUGIN_NAME_SHORT,
+//        walker->ifName,
+//        olsr_ip_to_string(&buf, forwardedBy));
+//    } /* else */
+//  } /* for */
+//} /* BmfEncapsulationPacketReceived */
+//
+/* -------------------------------------------------------------------------
+ * Function   : BmfTunPacketCaptured
+ * Description: Handle an IP packet, captured outgoing on the tuntap interface
+ * Input      : encapsulationUdpData - space for the encapsulation header, followed by
+ *                the captured outgoing IP packet
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : The packet is assumed to be captured on a socket of family
+ *              PF_PACKET and type SOCK_DGRAM (cooked).
+ * ------------------------------------------------------------------------- */
+//static void BmfTunPacketCaptured(unsigned char* encapsulationUdpData)
+//{
+//  union olsr_ip_addr srcIp;
+//  union olsr_ip_addr dstIp;
+//  union olsr_ip_addr broadAddr;
+//  struct TBmfInterface* walker;
+//  unsigned char* ipPacket;
+//  u_int16_t ipPacketLen;
+//  struct ip* ipHeader;
+//  u_int32_t crc32;
+//  struct TEncapHeader* encapHdr;
+//  struct ipaddr_str srcIpBuf, dstIpBuf;
+//  ipPacket = GetIpPacket(encapsulationUdpData);
+//  ipPacketLen = GetIpTotalLength(ipPacket);
+//  ipHeader = GetIpHeader(encapsulationUdpData);
+//
+//  dstIp.v4 = ipHeader->ip_dst;
+//  broadAddr.v4.s_addr = htonl(EtherTunTapIpBroadcast);
+//
+//  /* Only forward multicast packets. If configured, also forward local broadcast packets */
+//  if (IsMulticast(&dstIp) ||
+//      (EnableLocalBroadcast != 0 && olsr_ipequal(&dstIp, &broadAddr)))
+//  {
+//    /* continue */
+//  }
+//  else
+//  {
+//    return;
+//  }
+//
+//  srcIp.v4 = ipHeader->ip_src;
+//
+//  OLSR_PRINTF(
+//    8,
+//    "%s: outgoing pkt of %ld bytes captured on tuntap interface \"%s\": %s->%s\n",
+//    PLUGIN_NAME_SHORT,
+//    (long)ipPacketLen,
+//    EtherTunTapIfName,
+//    olsr_ip_to_string(&srcIpBuf, &srcIp),
+//    olsr_ip_to_string(&dstIpBuf, &dstIp));
+//
+//  /* Calculate packet fingerprint */
+//  crc32 = PacketCrc32(ipPacket, ipPacketLen);
+//
+//  /* Check if this packet was seen recently */
+//  if (CheckAndMarkRecentPacket(crc32))
+//  {
+//    OLSR_PRINTF(
+//      8,
+//      "%s: --> discarding: packet is duplicate\n",
+//      PLUGIN_NAME_SHORT);
+//    return;
+//  }
+//
+//  /* Compose encapsulation header */
+//  encapHdr = (struct TEncapHeader*) encapsulationUdpData;
+//  memset (encapHdr, 0, ENCAP_HDR_LEN);
+//  encapHdr->type = BMF_ENCAP_TYPE;
+//  encapHdr->len = BMF_ENCAP_LEN;
+//  encapHdr->reserved = 0;
+//  encapHdr->crc32 = htonl(crc32);
+//
+//  /* Check with each network interface what needs to be done on it */
+//  for (walker = BmfInterfaces; walker != NULL; walker = walker->next)
+//  {
+//    /* Is the forwarding interface OLSR-enabled? */
+//    if (walker->olsrIntf != NULL)
+//    {
+//      /* On an OLSR interface: encapsulate and forward packet. */
+//
+//      EncapsulateAndForwardPacket(walker, encapsulationUdpData);
+//    }
+//    else
+//    {
+//      /* On a non-OLSR interface: what to do?
+//       * Answer 1: nothing. Multicast routing between non-OLSR interfaces
+//       * is to be done by other protocols (e.g. PIM, DVMRP).
+//       * Answer 2 (better): Forward it. */
+//
+//      int nBytesWritten;
+//      struct sockaddr_ll dest;
+//
+//      /* If the encapsulated IP packet is a local broadcast packet,
+//       * update its destination address to match the subnet of the network
+//       * interface on which the packet is being sent. */
+//      CheckAndUpdateLocalBroadcast(ipPacket, &walker->broadAddr);
+//
+//      memset(&dest, 0, sizeof(dest));
+//      dest.sll_family = AF_PACKET;
+//      dest.sll_protocol = htons(ETH_P_IP);
+//      dest.sll_ifindex = if_nametoindex(walker->ifName);
+//      dest.sll_halen = IFHWADDRLEN;
+//
+//      /* Use all-ones as destination MAC address. When the IP destination is
+//       * a multicast address, the destination MAC address should normally also
+//       * be a multicast address. E.g., when the destination IP is 224.0.0.1,
+//       * the destination MAC should be 01:00:5e:00:00:01. However, it does not
+//       * seem to matter when the destination MAC address is set to all-ones
+//       * in that case. */
+//      memset(dest.sll_addr, 0xFF, IFHWADDRLEN);
+//
+//      nBytesWritten = sendto(
+//        walker->capturingSkfd,
+//        ipPacket,
+//        ipPacketLen,
+//        0,
+//        (struct sockaddr*) &dest,
+//        sizeof(dest));
+//      if (nBytesWritten != ipPacketLen)
+//      {
+//        BmfPError("sendto() error forwarding pkt on \"%s\"", walker->ifName);
+//      }
+//      else
+//      {
+//        /* Increase counter */
+//        walker->nBmfPacketsTx++;
+//
+//        OLSR_PRINTF(
+//          8,
+//          "%s: --> forwarded from non-OLSR to non-OLSR \"%s\"\n",
+//          PLUGIN_NAME_SHORT,
+//          walker->ifName);
+//      } /* if */
+//    } /* if */
+//  } /* for */
+//} /* BmfTunPacketCaptured */
+//
+/* -------------------------------------------------------------------------
+ * Function   : DoBmf
+ * Description: Wait (blocking) for IP packets, then call the handler for each
+ *              received packet
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : BmfInterfaces
+ * ------------------------------------------------------------------------- */
+void DoMDNS(int skfd, void *data __attribute__ ((unused)), unsigned int flags __attribute__ ((unused)))
+
+{
+//  int nFdBitsSet;
+  unsigned char rxBuffer[BMF_BUFFER_SIZE];
+//  fd_set rxFdSet;
+//  OLSR_PRINTF(1,"ENTERING DoMDNS\n");
+//  assert(HighestSkfd >= 0);
+//
+//  /* Make a local copy of the set of file descriptors that select() can
+//   * modify to indicate which descriptors actually changed status */
+//  rxFdSet = InputSet;
+//
+//  /* Wait (blocking) for packets received on any of the sockets.
+//   * NOTE: don't use a timeout (last parameter). It causes a high system CPU load! */
+//  nFdBitsSet = select(HighestSkfd + 1, &rxFdSet, NULL, NULL, NULL);
+//  if (nFdBitsSet < 0)
+//  {
+//    if (errno != EINTR)
+//    {
+//      BmfPError("select() error");
+//    }
+//    return;
+//  }
+//
+  //while (nFdBitsSet > 0)
+  //{
+    //struct TBmfInterface* walker;
+
+    /* Check if a packet was received on the capturing socket (if any)
+     * of each network interface */
+    //for (walker = BmfInterfaces; walker != NULL; walker = walker->next)
+    //{
+      //int skfd = walker->capturingSkfd;
+      //if (skfd >= 0 && (FD_ISSET(skfd, &rxFdSet)))
+      if (skfd >= 0)
+      {
+        struct sockaddr_ll pktAddr;
+        socklen_t addrLen = sizeof(pktAddr);
+        int nBytes;
+        unsigned char* ipPacket;
+
+        /* Receive the captured Ethernet frame, leaving space for the BMF
+         * encapsulation header */
+	ipPacket = GetIpPacket(rxBuffer);
+	nBytes = recvfrom(
+			skfd,
+			ipPacket,
+			//BMF_BUFFER_SIZE - ENCAP_HDR_LEN, //TODO: understand how to change this
+			BMF_BUFFER_SIZE, //TODO: understand how to change this
+			0,
+			(struct sockaddr*)&pktAddr,
+			&addrLen);
+	if (nBytes < 0)
+	{
+		//BmfPError("recvfrom() error on \"%s\"", walker->ifName);
+
+		return; /* for */
+	} /* if (nBytes < 0) */
+
+	/* Check if the number of received bytes is large enough for an IP
+	 * packet which contains at least a minimum-size IP header.
+	 * Note: There is an apparent bug in the packet socket implementation in
+	 * combination with VLAN interfaces. On a VLAN interface, the value returned
+	 * by 'recvfrom' may (but need not) be 4 (bytes) larger than the value
+	 * returned on a non-VLAN interface, for the same ethernet frame. */
+	if (nBytes < (int)sizeof(struct ip))
+	{
+		//OLSR_PRINTF(
+		//		1,
+		//		"%s: captured frame too short (%d bytes) on \"%s\"\n",
+		//		PLUGIN_NAME,
+		//		nBytes,
+		//		walker->ifName);
+
+		return; /* for */
+	}
+
+	if (pktAddr.sll_pkttype == PACKET_OUTGOING ||
+			pktAddr.sll_pkttype == PACKET_MULTICAST ||
+			pktAddr.sll_pkttype == PACKET_BROADCAST)
+	{
+		/* A multicast or broadcast packet was captured */
+
+		//OLSR_PRINTF(
+		//		1,
+		//		"%s: captured frame (%d bytes) on \"%s\"\n",
+		//		PLUGIN_NAME,
+		//		nBytes,
+		//		walker->ifName);
+		//BmfPacketCaptured(walker, pktAddr.sll_pkttype, rxBuffer);
+		BmfPacketCaptured(ipPacket,nBytes);
+
+        } /* if (pktAddr.sll_pkttype == ...) */
+      } /* if (skfd >= 0 && (FD_ISSET...)) */
+//    } /* for */
+
+//  } /* while (nFdBitsSet > 0) */
+} /* DoMDNS */
+
+int InitMDNS(struct interface* skipThisIntf)
+{
+  
+
+  //Tells OLSR to launch olsr_parser when the packets for this plugin arrive
+  olsr_parser_add_function(&olsr_parser, PARSER_TYPE);
+  CreateBmfNetworkInterfaces(skipThisIntf);
+
+  return 0;
+} /* InitBmf */
+
+/* -------------------------------------------------------------------------
+ * Function   : CloseBmf
+ * Description: Close the BMF plugin and clean up
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : BmfThread
+ * ------------------------------------------------------------------------- */
+void CloseMDNS(void)
+{
+//  if (EtherTunTapFd >= 0)
+//  {
+//    /* If there is a multicast route, try to delete it first */
+//    DeleteMulticastRoute();
+//
+//    /* Restore IP spoof filter for EtherTunTap interface */
+//    RestoreSpoofFilter();
+//  }
+//
+//  if (mdnsThreadRunning)
+//  {
+//    /* Signal BmfThread to exit */
+//    /* Strangely enough, all running threads receive the SIGALRM signal. But only the
+//     * BMF thread is affected by this signal, having specified a handler for this
+//     * signal in its thread entry function BmfRun(...). */
+//    if (pthread_kill(mdnsThread, SIGALRM) != 0)
+//    {
+//      BmfPError("pthread_kill() error");
+//    }
+//
+//    /* Wait for BmfThread to acknowledge */
+//    if (pthread_join(mdnsThread, NULL) != 0)
+//    {
+//      BmfPError("pthread_join() error");
+//    }
+//  }
+//
+//  /* Clean up after the BmfThread has been killed */
+  CloseBmfNetworkInterfaces();
+} /* CloseBmf */
+
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/mdns.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/mdns.h	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,95 @@
+#ifndef _BMF_BMF_H
+#define _BMF_BMF_H
+
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : Bmf.h
+ * Description: Multicast forwarding functions
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+#include "olsrd_plugin.h" /* union set_plugin_parameter_addon */
+
+#include "parser.h"
+#include <socket_parser.h>
+
+#define MESSAGE_TYPE 132
+#define PARSER_TYPE		MESSAGE_TYPE
+#define EMISSION_INTERVAL       10     /* seconds */
+#define EMISSION_JITTER         25      /* percent */
+#define MDNS_VALID_TIME          1800    /* seconds */
+
+/* BMF plugin data */
+#define PLUGIN_NAME "OLSRD MDNS plugin"
+#define PLUGIN_NAME_SHORT "OLSRD MDNS"
+#define PLUGIN_VERSION "1.0.0 (" __DATE__ " " __TIME__ ")"
+#define PLUGIN_COPYRIGHT "  (C) Ninux.org"
+#define PLUGIN_AUTHOR "  Saverio Proto (zioproto@gmail.com)"
+#define MOD_DESC PLUGIN_NAME " " PLUGIN_VERSION "\n" PLUGIN_COPYRIGHT "\n" PLUGIN_AUTHOR
+#define PLUGIN_INTERFACE_VERSION 5
+
+/* UDP-Port on which multicast packets are encapsulated */
+//#define BMF_ENCAP_PORT 50698
+
+/* Forward declaration of OLSR interface type */
+struct interface;
+
+//extern int FanOutLimit;
+//extern int BroadcastRetransmitCount;
+
+void DoMDNS(int sd, void * x, unsigned int y);
+void BmfPError(const char* format, ...) __attribute__((format(printf, 1, 2)));
+union olsr_ip_addr* MainAddressOf(union olsr_ip_addr* ip);
+//int InterfaceChange(struct interface* interf, int action);
+//int SetFanOutLimit(const char* value, void* data, set_plugin_parameter_addon addon);
+//int InitBmf(struct interface* skipThisIntf);
+//void CloseBmf(void);
+int InitMDNS(struct interface* skipThisIntf);
+void CloseMDNS(void);
+
+void olsr_mdns_gen(unsigned char*  packet, int len);
+
+/* Parser function to register with the scheduler */
+bool
+olsr_parser(union olsr_message *, struct interface *, union olsr_ip_addr *); 
+
+#endif /* _BMF_BMF_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/src/olsrd_plugin.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/src/olsrd_plugin.c	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,185 @@
+/*
+ * OLSR Basic Multicast Forwarding (BMF) plugin.
+ * Copyright (c) 2005 - 2007, Thales Communications, Huizen, The Netherlands.
+ * Written by Erik Tromp.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in
+ *   the documentation and/or other materials provided with the
+ *   distribution.
+ * * Neither the name of Thales, BMF nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* -------------------------------------------------------------------------
+ * File       : olsrd_plugin.c
+ * Description: Interface to the OLSRD plugin system
+ * Created    : 29 Jun 2006
+ *
+ * ------------------------------------------------------------------------- */
+
+/* System includes */
+#include <assert.h> /* assert() */
+#include <stddef.h> /* NULL */
+
+/* OLSRD includes */
+#include "olsrd_plugin.h"
+#include "plugin_util.h"
+#include "defs.h" /* uint8_t, olsr_cnf */
+#include "scheduler.h" /* olsr_start_timer() */
+#include "olsr_cfg.h" /* olsr_cnf() */
+#include "olsr_cookie.h" /* olsr_alloc_cookie() */
+
+/* BMF includes */
+#include "mdns.h" /* InitBmf(), CloseBmf() */
+#include "PacketHistory.h" /* InitPacketHistory() */
+#include "NetworkInterfaces.h" /* AddNonOlsrBmfIf(), SetBmfInterfaceIp(), ... */
+#include "Address.h" /* DoLocalBroadcast() */
+
+static void __attribute__ ((constructor)) my_init(void);
+static void __attribute__ ((destructor)) my_fini(void);
+
+//static struct olsr_cookie_info *prune_packet_history_timer_cookie;
+
+void olsr_plugin_exit(void);
+
+/* -------------------------------------------------------------------------
+ * Function   : olsrd_plugin_interface_version
+ * Description: Plugin interface version
+ * Input      : none
+ * Output     : none
+ * Return     : BMF plugin interface version number
+ * Data Used  : none
+ * Notes      : Called by main OLSRD (olsr_load_dl) to check plugin interface
+ *              version
+ * ------------------------------------------------------------------------- */
+int olsrd_plugin_interface_version(void)
+{
+  return PLUGIN_INTERFACE_VERSION;
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : olsrd_plugin_init
+ * Description: Plugin initialisation
+ * Input      : none
+ * Output     : none
+ * Return     : fail (0) or success (1)
+ * Data Used  : olsr_cnf
+ * Notes      : Called by main OLSRD (init_olsr_plugin) to initialize plugin
+ * ------------------------------------------------------------------------- */
+int olsrd_plugin_init(void)
+{
+  /* Clear the packet history */
+  //InitPacketHistory();
+
+  /* Register ifchange function */
+  //add_ifchgf(&InterfaceChange);
+
+  /* create the cookie */
+  //prune_packet_history_timer_cookie = olsr_alloc_cookie("BMF: Prune Packet History", OLSR_COOKIE_TYPE_TIMER);
+
+  /* Register the duplicate registration pruning process */
+  //olsr_start_timer(3 * MSEC_PER_SEC, 0, OLSR_TIMER_PERIODIC,
+  //                 &PrunePacketHistory, NULL, prune_packet_history_timer_cookie->ci_id);
+
+
+  return InitMDNS(NULL);
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : olsr_plugin_exit
+ * Description: Plugin cleanup
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : Called by my_fini() at unload of shared object
+ * ------------------------------------------------------------------------- */
+void olsr_plugin_exit(void)
+{
+  CloseMDNS();
+}
+
+static const struct olsrd_plugin_parameters plugin_parameters[] = {
+    { .name = "NonOlsrIf", .set_plugin_parameter = &AddNonOlsrBmfIf, .data = NULL },
+    //{ .name = "DoLocalBroadcast", .set_plugin_parameter = &DoLocalBroadcast, .data = NULL },
+    //{ .name = "BmfInterface", .set_plugin_parameter = &SetBmfInterfaceName, .data = NULL },
+    //{ .name = "BmfInterfaceIp", .set_plugin_parameter = &SetBmfInterfaceIp, .data = NULL },
+    //{ .name = "CapturePacketsOnOlsrInterfaces", .set_plugin_parameter = &SetCapturePacketsOnOlsrInterfaces, .data = NULL },
+    //{ .name = "BmfMechanism", .set_plugin_parameter = &SetBmfMechanism, .data = NULL },
+    //{ .name = "FanOutLimit", .set_plugin_parameter = &SetFanOutLimit, .data = NULL },
+    //{ .name = "BroadcastRetransmitCount", .set_plugin_parameter = &set_plugin_int, .data = &BroadcastRetransmitCount},
+};
+
+/* -------------------------------------------------------------------------
+ * Function   : olsrd_get_plugin_parameters
+ * Description: Return the parameter table and its size
+ * Input      : none
+ * Output     : params - the parameter table
+ *              size - its size in no. of entries
+ * Return     : none
+ * Data Used  : plugin_parameters
+ * Notes      : Called by main OLSR (init_olsr_plugin) for all plugins
+ * ------------------------------------------------------------------------- */
+void olsrd_get_plugin_parameters(const struct olsrd_plugin_parameters **params, int *size)
+{
+    *params = plugin_parameters;
+    *size = ARRAYSIZE(plugin_parameters);
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : my_init
+ * Description: Plugin constructor
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : Called at load of shared object
+ * ------------------------------------------------------------------------- */
+static void my_init(void)
+{
+  /* Print plugin info to stdout */
+  printf("%s\n", MOD_DESC);
+
+  return;
+}
+
+/* -------------------------------------------------------------------------
+ * Function   : my_fini
+ * Description: Plugin destructor
+ * Input      : none
+ * Output     : none
+ * Return     : none
+ * Data Used  : none
+ * Notes      : Called at unload of shared object
+ * ------------------------------------------------------------------------- */
+static void my_fini(void)
+{
+  olsr_plugin_exit();
+}
+
+/*
+ * Local Variables:
+ * c-basic-offset: 2
+ * indent-tabs-mode: nil
+ * End:
+ */
diff -r feb3d7883ff0 -r d73e73400732 lib/mdns/version-script.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/lib/mdns/version-script.txt	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,10 @@
+VERS_1.0
+{
+  global:
+    olsrd_plugin_interface_version;
+    olsrd_plugin_init;
+    olsrd_get_plugin_parameters;
+
+  local:
+    *;
+};
diff -r feb3d7883ff0 -r d73e73400732 lib/nameservice/README_NAMESERVICE
--- a/lib/nameservice/README_NAMESERVICE	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/nameservice/README_NAMESERVICE	Fri Mar 13 19:16:23 2009 +0100
@@ -112,12 +112,32 @@
         table. Useful for executing a script that uses the hosts file
         to keep a website or a database updated.
 
+PlParam "service" "http://me.olsr:80|tcp|my little homepage"
+        Add a new service announcement to be spreaded in the mesh.
+
+PlParam "services-file" "/path/to/services_file"
+	File to write (default: /var/run/services_olsr)
+
 PlParam "services-change-script" "/path/to/script"
         Similar to the previous parameter. Script to execute when there
         is a change in the services list propagated by the nameserver
         plugin. Useful for executing a script that uses the services file
         to keep a website or a database updated.
 
+PlParam "mac" "xx:xx:xx:xx:xx:xx[,0-255]"
+        Add a new MAC addr to be spreaded in the mesh. This MAC addr
+        may be used to fine control nerve-wreck-page solutions based
+        on MAC adresses. The optional dec. number designates a class.
+
+PlParam "macs-file" "/path/to/macs_file"
+	File to write (default: /var/run/macs_olsr)
+
+PlParam "macs-change-script" "/path/to/script"
+        Similar to the previous parameter. Script to execute when there
+        is a change in the macs list propagated by the nameserver
+        plugin. Useful for executing a script that uses the services file
+        to keep a website or a database updated.
+
 ---------------------------------------------------------------------
 SAMPLE CONFIG
 ---------------------------------------------------------------------
diff -r feb3d7883ff0 -r d73e73400732 lib/nameservice/src/mapwrite.c
--- a/lib/nameservice/src/mapwrite.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/nameservice/src/mapwrite.c	Fri Mar 13 19:16:23 2009 +0100
@@ -167,7 +167,7 @@
         if (0 >
             fprintf(fmap, "PLink('%s','%s',%s,%s,%s,%s);\n", olsr_ip_to_string(&strbuf1, &tc_edge->T_dest_addr),
                     olsr_ip_to_string(&strbuf2, &tc->addr), get_tc_edge_entry_text(tc_edge, ',', &lqbuffer2),
-                    get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer), lla, llb)) {
+                    get_linkcost_text(tc_edge->cost, false, &lqbuffer), lla, llb)) {
           return;
         }
       } else {
@@ -179,7 +179,7 @@
         if (0 >
             fprintf(fmap, "Link('%s','%s',%s,%s);\n", olsr_ip_to_string(&strbuf1, &tc_edge->T_dest_addr),
                     olsr_ip_to_string(&strbuf2, &tc->addr), get_tc_edge_entry_text(tc_edge, ',', &lqbuffer2),
-                    get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer))) {
+                    get_linkcost_text(tc_edge->cost, false, &lqbuffer))) {
           return;
         }
       }
@@ -233,13 +233,13 @@
     unlink(fifoname);
     if (0 > mkfifo(fifoname, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH)) {
       OLSR_PRINTF(1, "mkfifo(%s): %s", fifoname, strerror(errno));
-      return OLSR_FALSE;
+      return false;
     } else {
       the_fifoname = fifoname;
       olsr_start_timer(100, 5, OLSR_TIMER_PERIODIC, &mapwrite_poll, NULL, 0);
     }
   }
-  return OLSR_TRUE;
+  return true;
 }
 
 void
diff -r feb3d7883ff0 -r d73e73400732 lib/nameservice/src/nameservice.c
--- a/lib/nameservice/src/nameservice.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/nameservice/src/nameservice.c	Fri Mar 13 19:16:23 2009 +0100
@@ -75,8 +75,10 @@
 static double my_timeout = NAME_VALID_TIME;
 static char my_resolv_file[MAX_FILE + 1];
 static char my_services_file[MAX_FILE + 1];
+static char my_macs_file[MAX_FILE + 1];
 static char my_name_change_script[MAX_FILE + 1];
 static char my_services_change_script[MAX_FILE + 1];
+static char my_macs_change_script[MAX_FILE + 1];
 static char latlon_in_file[MAX_FILE + 1];
 static char my_latlon_file[MAX_FILE + 1];
 float my_lat = 0.0, my_lon = 0.0;
@@ -90,18 +92,22 @@
 static struct list_node name_list[HASHSIZE];
 struct name_entry *my_names = NULL;
 struct timer_entry *name_table_write = NULL;
-static olsr_bool name_table_changed = OLSR_TRUE;
+static bool name_table_changed = true;
 
 static struct list_node service_list[HASHSIZE];
 static struct name_entry *my_services = NULL;
-static olsr_bool service_table_changed = OLSR_TRUE;
+static bool service_table_changed = true;
+
+static struct list_node mac_list[HASHSIZE];
+static struct name_entry *my_macs = NULL;
+static bool mac_table_changed = true;
 
 static struct list_node forwarder_list[HASHSIZE];
 static struct name_entry *my_forwarders = NULL;
-static olsr_bool forwarder_table_changed = OLSR_TRUE;
+static bool forwarder_table_changed = true;
 
 struct list_node latlon_list[HASHSIZE];
-static olsr_bool latlon_table_changed = OLSR_TRUE;
+static bool latlon_table_changed = true;
 
 /* backoff timer for writing changes into a file */
 struct timer_entry *write_file_timer = NULL;
@@ -131,6 +137,7 @@
 
   GetWindowsDirectory(my_hosts_file, MAX_FILE - 12);
   GetWindowsDirectory(my_services_file, MAX_FILE - 12);
+  GetWindowsDirectory(my_macs_file, MAX_FILE - 12);
   GetWindowsDirectory(my_resolv_file, MAX_FILE - 12);
 
   len = strlen(my_hosts_file);
@@ -143,6 +150,11 @@
     strscat(my_services_file, "\\", sizeof(my_services_file));
   strscat(my_services_file, "services_olsr", sizeof(my_services_file));
 
+  len = strlen(my_macs_file);
+  if (my_macs_file[len - 1] != '\\')
+    strscat(my_macs_file, "\\", sizeof(my_macs_file));
+  strscat(my_macs_file, "macs_olsr", sizeof(my_macs_file));
+
   len = strlen(my_resolv_file);
   if (my_resolv_file[len - 1] != '\\')
     strscat(my_resolv_file, "\\", sizeof(my_resolv_file));
@@ -150,6 +162,7 @@
 #else
   strscpy(my_hosts_file, "/var/run/hosts_olsr", sizeof(my_hosts_file));
   strscpy(my_services_file, "/var/run/services_olsr", sizeof(my_services_file));
+  strscpy(my_macs_file, "/var/run/macs_olsr", sizeof(my_macs_file));
   strscpy(my_resolv_file, "/var/run/resolvconf_olsr", sizeof(my_resolv_file));
   *my_sighup_pid_file = 0;
 #endif
@@ -160,12 +173,14 @@
   latlon_in_file[0] = '\0';
   my_name_change_script[0] = '\0';
   my_services_change_script[0] = '\0';
+  my_macs_change_script[0] = '\0';
 
   /* init the lists heads */
   for (i = 0; i < HASHSIZE; i++) {
     list_head_init(&name_list[i]);
     list_head_init(&forwarder_list[i]);
     list_head_init(&service_list[i]);
+    list_head_init(&mac_list[i]);
     list_head_init(&latlon_list[i]);
   }
 
@@ -232,58 +247,31 @@
   return 0;
 }
 
+/* *INDENT-OFF* */
 static const struct olsrd_plugin_parameters plugin_parameters[] = {
-  {.name = "interval",.set_plugin_parameter = &set_plugin_int,.data = &my_interval},
-  {.name = "timeout",.set_plugin_parameter = &set_nameservice_float,.data = &my_timeout},
-  {.name = "sighup-pid-file",.set_plugin_parameter = &set_plugin_string,.data = &my_sighup_pid_file,.addon =
-   {sizeof(my_sighup_pid_file)}
-   }
-  ,
-  {.name = "hosts-file",.set_plugin_parameter = &set_plugin_string,.data = &my_hosts_file,.addon = {sizeof(my_hosts_file)}
-   }
-  ,
-  {.name = "name-change-script",.set_plugin_parameter = &set_plugin_string,.data = &my_name_change_script,.addon =
-   {sizeof(my_name_change_script)}
-   }
-  ,
-  {.name = "services-change-script",.set_plugin_parameter = &set_plugin_string,.data = &my_services_change_script,.addon =
-   {sizeof(my_services_change_script)}
-   }
-  ,
-  {.name = "resolv-file",.set_plugin_parameter = &set_plugin_string,.data = &my_resolv_file,.addon = {sizeof(my_resolv_file)}
-   }
-  ,
-  {.name = "suffix",.set_plugin_parameter = &set_plugin_string,.data = &my_suffix,.addon = {sizeof(my_suffix)}
-   }
-  ,
-  {.name = "add-hosts",.set_plugin_parameter = &set_plugin_string,.data = &my_add_hosts,.addon = {sizeof(my_add_hosts)}
-   }
-  ,
-  {.name = "services-file",.set_plugin_parameter = &set_plugin_string,.data = &my_services_file,.addon = {sizeof(my_services_file)}
-   }
-  ,
-  {.name = "lat",.set_plugin_parameter = &set_nameservice_float,.data = &my_lat}
-  ,
-  {.name = "lon",.set_plugin_parameter = &set_nameservice_float,.data = &my_lon}
-  ,
-  {.name = "latlon-file",.set_plugin_parameter = &set_plugin_string,.data = &my_latlon_file,.addon = {sizeof(my_latlon_file)}
-   }
-  ,
-  {.name = "latlon-infile",.set_plugin_parameter = &set_plugin_string,.data = &latlon_in_file,.addon = {sizeof(latlon_in_file)}
-   }
-  ,
-  {.name = "dns-server",.set_plugin_parameter = &set_nameservice_server,.data = &my_forwarders,.addon = {NAME_FORWARDER}
-   }
-  ,
-  {.name = "name",.set_plugin_parameter = &set_nameservice_name,.data = &my_names,.addon = {NAME_HOST}
-   }
-  ,
-  {.name = "service",.set_plugin_parameter = &set_nameservice_name,.data = &my_services,.addon = {NAME_SERVICE}
-   }
-  ,
-  {.name = "",.set_plugin_parameter = &set_nameservice_host,.data = &my_names}
-  ,
+  { .name = "interval",               .set_plugin_parameter = &set_plugin_int,         .data = &my_interval },
+  { .name = "timeout",                .set_plugin_parameter = &set_nameservice_float,  .data = &my_timeout },
+  { .name = "sighup-pid-file",        .set_plugin_parameter = &set_plugin_string,      .data = &my_sighup_pid_file,        .addon = {sizeof(my_sighup_pid_file)} },
+  { .name = "hosts-file",             .set_plugin_parameter = &set_plugin_string,      .data = &my_hosts_file,             .addon = {sizeof(my_hosts_file)} },
+  { .name = "name-change-script",     .set_plugin_parameter = &set_plugin_string,      .data = &my_name_change_script,     .addon = {sizeof(my_name_change_script)} },
+  { .name = "services-change-script", .set_plugin_parameter = &set_plugin_string,      .data = &my_services_change_script, .addon = {sizeof(my_services_change_script)} },
+  { .name = "macs-change-script",     .set_plugin_parameter = &set_plugin_string,      .data = &my_macs_change_script,     .addon = {sizeof(my_macs_change_script)} },
+  { .name = "resolv-file",            .set_plugin_parameter = &set_plugin_string,      .data = &my_resolv_file,            .addon = {sizeof(my_resolv_file)} },
+  { .name = "suffix",                 .set_plugin_parameter = &set_plugin_string,      .data = &my_suffix,                 .addon = {sizeof(my_suffix)} },
+  { .name = "add-hosts",              .set_plugin_parameter = &set_plugin_string,      .data = &my_add_hosts,              .addon = {sizeof(my_add_hosts)} },
+  { .name = "services-file",          .set_plugin_parameter = &set_plugin_string,      .data = &my_services_file,          .addon = {sizeof(my_services_file)} },
+  { .name = "macs-file",              .set_plugin_parameter = &set_plugin_string,      .data = &my_macs_file,              .addon = {sizeof(my_macs_file)} },
+  { .name = "lat",                    .set_plugin_parameter = &set_nameservice_float,  .data = &my_lat },
+  { .name = "lon",                    .set_plugin_parameter = &set_nameservice_float,  .data = &my_lon },
+  { .name = "latlon-file",            .set_plugin_parameter = &set_plugin_string,      .data = &my_latlon_file,            .addon = {sizeof(my_latlon_file)} },
+  { .name = "latlon-infile",          .set_plugin_parameter = &set_plugin_string,      .data = &latlon_in_file,            .addon = {sizeof(latlon_in_file)} },
+  { .name = "dns-server",             .set_plugin_parameter = &set_nameservice_server, .data = &my_forwarders,             .addon = {NAME_FORWARDER} },
+  { .name = "name",                   .set_plugin_parameter = &set_nameservice_name,   .data = &my_names,                  .addon = {NAME_HOST} },
+  { .name = "service",                .set_plugin_parameter = &set_nameservice_name,   .data = &my_services,               .addon = {NAME_SERVICE} },
+  { .name = "mac",                    .set_plugin_parameter = &set_nameservice_name,   .data = &my_macs,                   .addon = {NAME_MACADDR} },
+  { .name = "",                       .set_plugin_parameter = &set_nameservice_host,   .data = &my_names },
 };
+/* *INDENT-OFF* */
 
 void
 olsrd_get_plugin_parameters(const struct olsrd_plugin_parameters **params, int *size)
@@ -404,6 +392,7 @@
   my_names = remove_nonvalid_names_from_list(my_names, NAME_HOST);
   my_forwarders = remove_nonvalid_names_from_list(my_forwarders, NAME_FORWARDER);
   my_services = remove_nonvalid_names_from_list(my_services, NAME_SERVICE);
+  my_macs = remove_nonvalid_names_from_list(my_macs, NAME_MACADDR);
 
   /* register functions with olsrd */
   olsr_parser_add_function(&olsr_parser, PARSER_TYPE);
@@ -420,7 +409,7 @@
 remove_nonvalid_names_from_list(struct name_entry *my_list, int type)
 {
   struct name_entry *next = my_list;
-  olsr_bool valid = OLSR_FALSE;
+  bool valid = false;
   if (my_list == NULL) {
     return NULL;
   }
@@ -435,6 +424,9 @@
   case NAME_SERVICE:
     valid = allowed_service(my_list->name);
     break;
+  case NAME_MACADDR:
+    valid = is_mac_wellformed(my_list->name);
+    break;
   case NAME_LATLON:
     valid = is_latlon_wellformed(my_list->name);
     break;
@@ -470,10 +462,12 @@
 
   free_name_entry_list(&my_names);
   free_name_entry_list(&my_services);
+  free_name_entry_list(&my_macs);
   free_name_entry_list(&my_forwarders);
 
   free_all_list_entries(name_list);
   free_all_list_entries(service_list);
+  free_all_list_entries(mac_list);
   free_all_list_entries(forwarder_list);
   free_all_list_entries(latlon_list);
 
@@ -517,11 +511,12 @@
 {
   write_file_timer = NULL;
 
-  write_resolv_file();          /* if forwarder_table_changed */
-  write_hosts_file();           /* if name_table_changed */
-  write_services_file();        /* if service_table_changed */
+  write_resolv_file();             /* if forwarder_table_changed */
+  write_hosts_file();              /* if name_table_changed */
+  write_services_file(false); /* if service_table_changed */
+  write_services_file(true);  /* if mac_table_changed */
 #ifdef WIN32
-  write_latlon_file();          /* if latlon_table_changed */
+  write_latlon_file();             /* if latlon_table_changed */
 #endif
 }
 
@@ -629,14 +624,14 @@
 /**
  * Parse name olsr message of NAME type
  */
-olsr_bool
+bool
 olsr_parser(union olsr_message *m, struct interface *in_if __attribute__ ((unused)), union olsr_ip_addr *ipaddr)
 {
   struct namemsg *namemessage;
   union olsr_ip_addr originator;
   olsr_reltime vtime;
   int size;
-  olsr_u16_t seqno;
+  uint16_t seqno;
 
   /* Fetch the originator of the messsage */
   if (olsr_cnf->ip_version == AF_INET) {
@@ -661,20 +656,20 @@
   /* Check if message originated from this node.
      If so - back off */
   if (ipequal(&originator, &olsr_cnf->main_addr))
-    return OLSR_FALSE;
+    return false;
 
   /* Check that the neighbor this message was received from is symmetric.
      If not - back off */
   if (check_neighbor_link(ipaddr) != SYM_LINK) {
     struct ipaddr_str strbuf;
     OLSR_PRINTF(3, "NAME PLUGIN: Received msg from NON SYM neighbor %s\n", olsr_ip_to_string(&strbuf, ipaddr));
-    return OLSR_FALSE;
+    return false;
   }
 
   update_name_entry(&originator, namemessage, size, vtime);
 
   /* Forward the message */
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -688,7 +683,6 @@
 encap_namemsg(struct namemsg *msg)
 {
   struct name_entry *my_name;
-  struct name_entry *my_service;
 
   // add the hostname, service and forwarder entries after the namemsg header
   char *pos = (char *)msg + sizeof(struct namemsg);
@@ -705,15 +699,20 @@
     i++;
   }
   // services
-  for (my_service = my_services; my_service != NULL; my_service = my_service->next) {
-    pos = create_packet((struct name *)pos, my_service);
+  for (my_name = my_services; my_name != NULL; my_name = my_name->next) {
+    pos = create_packet((struct name *)pos, my_name);
+    i++;
+  }
+  // macs
+  for (my_name = my_macs; my_name != NULL; my_name = my_name->next) {
+    pos = create_packet((struct name *)pos, my_name);
     i++;
   }
   // latlon
   if ('\0' != latlon_in_file[0]) {
     FILE *in = fopen(latlon_in_file, "r");
     if (in != NULL) {
-      fscanf(in, "%f,%f", &my_lat, &my_lon);
+      if (fscanf(in, "%f,%f", &my_lat, &my_lon)) {}
       fclose(in);
     } else {
       OLSR_PRINTF(0, "NAME PLUGIN: cant read latlon in file %s\n", latlon_in_file);
@@ -766,7 +765,7 @@
  * decapsulate a received name, service or forwarder and update the corresponding hash table if necessary
  */
 void
-decap_namemsg(struct name *from_packet, struct name_entry **to, olsr_bool * this_table_changed)
+decap_namemsg(struct name *from_packet, struct name_entry **to, bool * this_table_changed)
 {
   struct ipaddr_str strbuf;
   struct name_entry *tmp;
@@ -779,6 +778,7 @@
   //XXX: should I check the from_packet->ip here? If so, why not also check the ip from HOST and SERVICE?
   if ((type_of_from_packet == NAME_HOST && !is_name_wellformed(name))
       || (type_of_from_packet == NAME_SERVICE && !is_service_wellformed(name))
+      || (type_of_from_packet == NAME_MACADDR && !is_mac_wellformed(name))
       || (type_of_from_packet == NAME_LATLON && !is_latlon_wellformed(name))) {
     OLSR_PRINTF(4, "NAME PLUGIN: invalid name [%s] received, skipping.\n", name);
     return;
@@ -811,7 +811,7 @@
         already_saved_name_entries->name = olsr_malloc(len_of_name + 1, "upd name_entry name");
         strscpy(already_saved_name_entries->name, name, len_of_name + 1);
 
-        *this_table_changed = OLSR_TRUE;
+        *this_table_changed = true;
         olsr_start_write_file_timer();
       }
       if (!ipequal(&already_saved_name_entries->ip, &from_packet->ip)) {
@@ -820,7 +820,7 @@
                     olsr_ip_to_string(&strbuf2, &from_packet->ip), olsr_ip_to_string(&strbuf3, &already_saved_name_entries->ip));
         already_saved_name_entries->ip = from_packet->ip;
 
-        *this_table_changed = OLSR_TRUE;
+        *this_table_changed = true;
         olsr_start_write_file_timer();
       }
       if (!*this_table_changed) {
@@ -842,7 +842,7 @@
   OLSR_PRINTF(3, "\nNAME PLUGIN: create new name/service/forwarder entry %s (%s) [len=%d] [type=%d] in linked list\n", tmp->name,
               olsr_ip_to_string(&strbuf, &tmp->ip), tmp->len, tmp->type);
 
-  *this_table_changed = OLSR_TRUE;
+  *this_table_changed = true;
   olsr_start_write_file_timer();
 
   // queue to front
@@ -886,6 +886,9 @@
     case NAME_SERVICE:
       insert_new_name_in_list(originator, service_list, from_packet, &service_table_changed, vtime);
       break;
+    case NAME_MACADDR:
+      insert_new_name_in_list(originator, mac_list, from_packet, &mac_table_changed, vtime);
+      break;
     case NAME_LATLON:
       insert_new_name_in_list(originator, latlon_list, from_packet, &latlon_table_changed, vtime);
       break;
@@ -909,13 +912,13 @@
  */
 void
 insert_new_name_in_list(union olsr_ip_addr *originator, struct list_node *this_list, struct name *from_packet,
-                        olsr_bool * this_table_changed, olsr_reltime vtime)
+                        bool * this_table_changed, olsr_reltime vtime)
 {
   int hash;
   struct db_entry *entry;
   struct list_node *list_head, *list_node;
 
-  olsr_bool entry_found = OLSR_FALSE;
+  bool entry_found = false;
 
   hash = olsr_ip_hashing(originator);
 
@@ -936,7 +939,7 @@
       olsr_set_timer(&entry->db_timer, vtime, OLSR_NAMESVC_DB_JITTER, OLSR_TIMER_ONESHOT, &olsr_nameservice_expire_db_timer, entry,
                      0);
 
-      entry_found = OLSR_TRUE;
+      entry_found = true;
     }
   }
 
@@ -1115,7 +1118,7 @@
   if (*my_sighup_pid_file)
     send_sighup_to_pidfile(my_sighup_pid_file);
 #endif
-  name_table_changed = OLSR_FALSE;
+  name_table_changed = false;
 
   // Executes my_name_change_script after writing the hosts file
   if (my_name_change_script[0] != '\0') {
@@ -1128,45 +1131,47 @@
 }
 
 /**
- * write services to a file in the format:
- * service  #originator ip
+ * write services or macs to a file in the format:
+ * service-or-mac  #originator ip
  *
  * since service has a special format
  * each line will look similar to e.g.
  * http://me.olsr:80|tcp|my little homepage
+ * while a mac line will look similar to
+ * 02:ca:ff:ee:ba:be,1
  */
 void
-write_services_file(void)
+write_services_file(bool writemacs)
 {
   int hash;
   struct name_entry *name;
   struct db_entry *entry;
   struct list_node *list_head, *list_node;
-  FILE *services_file;
+  FILE *file;
   time_t currtime;
 
-  if (!service_table_changed)
+  if ((writemacs && !mac_table_changed) || (!writemacs && !service_table_changed))
     return;
 
-  OLSR_PRINTF(2, "NAME PLUGIN: writing services file\n");
+  OLSR_PRINTF(2, "NAME PLUGIN: writing %s file\n", writemacs ? "macs" : "services");
 
-  services_file = fopen(my_services_file, "w");
-  if (services_file == NULL) {
-    OLSR_PRINTF(2, "NAME PLUGIN: cant write services_file file\n");
+  file = fopen(writemacs ? my_macs_file : my_services_file, "w");
+  if (file == NULL) {
+    OLSR_PRINTF(2, "NAME PLUGIN: cant write %s\n", writemacs ? my_macs_file : my_services_file);
     return;
   }
 
-  fprintf(services_file, "### this file is overwritten regularly by olsrd\n");
-  fprintf(services_file, "### do not edit\n\n");
+  fprintf(file, "### this file is overwritten regularly by olsrd\n");
+  fprintf(file, "### do not edit\n\n");
 
-  // write own services
-  for (name = my_services; name != NULL; name = name->next) {
-    fprintf(services_file, "%s\t# my own service\n", name->name);
+  // write own services or macs
+  for (name = writemacs ? my_macs : my_services; name != NULL; name = name->next) {
+    fprintf(file, "%s\t# my own %s\n", name->name, writemacs ? "mac" : "service");
   }
 
-  // write received services
+  // write received services or macs
   for (hash = 0; hash < HASHSIZE; hash++) {
-    list_head = &service_list[hash];
+    list_head = writemacs ? &mac_list[hash] : &service_list[hash];
     for (list_node = list_head->next; list_node != list_head; list_node = list_node->next) {
 
       entry = list2db(list_node);
@@ -1176,26 +1181,38 @@
         OLSR_PRINTF(6, "%s\t", name->name);
         OLSR_PRINTF(6, "\t#%s\n", olsr_ip_to_string(&strbuf, &entry->originator));
 
-        fprintf(services_file, "%s\t", name->name);
-        fprintf(services_file, "\t#%s\n", olsr_ip_to_string(&strbuf, &entry->originator));
+        fprintf(file, "%s\t", name->name);
+        fprintf(file, "\t#%s\n", olsr_ip_to_string(&strbuf, &entry->originator));
       }
     }
   }
 
   if (time(&currtime)) {
-    fprintf(services_file, "\n### written by olsrd at %s", ctime(&currtime));
+    fprintf(file, "\n### written by olsrd at %s", ctime(&currtime));
   }
 
-  fclose(services_file);
-  service_table_changed = OLSR_FALSE;
-
-  // Executes my_services_change_script after writing the services file
-  if (my_services_change_script[0] != '\0') {
-    if (system(my_services_change_script) != -1) {
-      OLSR_PRINTF(2, "NAME PLUGIN: Service changed, %s executed\n", my_services_change_script);
-    } else {
-      OLSR_PRINTF(2, "NAME PLUGIN: WARNING! Failed to execute %s on service change\n", my_services_change_script);
+  fclose(file);
+  if (writemacs) {
+    // Executes my_macs_change_script after writing the macs file
+    if (my_macs_change_script[0] != '\0') {
+      if (system(my_macs_change_script) != -1) {
+        OLSR_PRINTF(2, "NAME PLUGIN: Service changed, %s executed\n", my_macs_change_script);
+      } else {
+        OLSR_PRINTF(2, "NAME PLUGIN: WARNING! Failed to execute %s on mac change\n", my_macs_change_script);
+      }
     }
+    mac_table_changed = false;
+  }
+  else {
+    // Executes my_services_change_script after writing the services file
+    if (my_services_change_script[0] != '\0') {
+      if (system(my_services_change_script) != -1) {
+        OLSR_PRINTF(2, "NAME PLUGIN: Service changed, %s executed\n", my_services_change_script);
+      } else {
+        OLSR_PRINTF(2, "NAME PLUGIN: WARNING! Failed to execute %s on service change\n", my_services_change_script);
+      }
+    }
+    service_table_changed = false;
   }
 }
 
@@ -1229,7 +1246,7 @@
        * first is better, swap the pointers.
        */
       OLSR_PRINTF(6, "NAME PLUGIN: nameserver %s, cost %s\n", olsr_ip_to_string(&strbuf, &rt1->rt_dst.prefix),
-                  get_linkcost_text(rt1->rt_best->rtp_metric.cost, OLSR_TRUE, &lqbuffer));
+                  get_linkcost_text(rt1->rt_best->rtp_metric.cost, true, &lqbuffer));
 
       rt[nameserver_idx] = rt2;
       rt[nameserver_idx + 1] = rt1;
@@ -1282,7 +1299,7 @@
         /* enqueue it on the head of list */
         *nameserver_routes = route;
         OLSR_PRINTF(6, "NAME PLUGIN: found nameserver %s, cost %s", olsr_ip_to_string(&strbuf, &name->ip),
-                    get_linkcost_text(route->rt_best->rtp_metric.cost, OLSR_TRUE, &lqbuffer));
+                    get_linkcost_text(route->rt_best->rtp_metric.cost, true, &lqbuffer));
 
         /* find the closet one */
         select_best_nameserver(nameserver_routes);
@@ -1322,7 +1339,7 @@
     fprintf(resolv, "\n### written by olsrd at %s", ctime(&currtime));
   }
   fclose(resolv);
-  forwarder_table_changed = OLSR_FALSE;
+  forwarder_table_changed = false;
 }
 
 /**
@@ -1340,16 +1357,19 @@
     /* flag changes */
     switch (to_delete->type) {
     case NAME_HOST:
-      name_table_changed = OLSR_TRUE;
+      name_table_changed = true;
       break;
     case NAME_FORWARDER:
-      forwarder_table_changed = OLSR_TRUE;
+      forwarder_table_changed = true;
       break;
     case NAME_SERVICE:
-      service_table_changed = OLSR_TRUE;
+      service_table_changed = true;
+      break;
+    case NAME_MACADDR:
+      mac_table_changed = true;
       break;
     case NAME_LATLON:
-      latlon_table_changed = OLSR_TRUE;
+      latlon_table_changed = true;
       break;
     default:
       break;
@@ -1368,7 +1388,7 @@
  * so the IP must either be from one of the interfaces
  * or inside a HNA which we have configured
  */
-olsr_bool
+bool
 allowed_ip(const union olsr_ip_addr *addr)
 {
   struct ip_prefix_list *hna;
@@ -1382,7 +1402,7 @@
     OLSR_PRINTF(6, "interface %s\n", olsr_ip_to_string(&strbuf, &iface->ip_addr));
     if (ipequal(&iface->ip_addr, addr)) {
       OLSR_PRINTF(6, "MATCHED\n");
-      return OLSR_TRUE;
+      return true;
     }
   }
 
@@ -1396,7 +1416,7 @@
       olsr_prefix_to_netmask(&netmask, hna->net.prefix_len);
       if ((addr->v4.s_addr & netmask.v4.s_addr) == hna->net.prefix.v4.s_addr) {
         OLSR_PRINTF(6, "MATCHED\n");
-        return OLSR_TRUE;
+        return true;
       }
     }
   } else {
@@ -1411,18 +1431,18 @@
       }
       if (ipequal(&tmp_ip, &hna->net.prefix)) {
         OLSR_PRINTF(6, "MATCHED\n");
-        return OLSR_TRUE;
+        return true;
       }
     }
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /** check if name has the right syntax, i.e. it must adhere to a special regex
  * stored in regex_t_name
  * necessary to avaid names like "0.0.0.0 google.de\n etc"
  */
-olsr_bool
+bool
 is_name_wellformed(const char *name)
 {
   return regexec(&regex_t_name, name, 1, &regmatch_t_name, 0) == 0;
@@ -1432,29 +1452,29 @@
  * check if the service is in the right syntax and also that the hostname
  * or ip whithin the service is allowed
  */
-olsr_bool
+bool
 allowed_service(const char *service_line)
 {
   /* the call of is_service_wellformed generates the submatches stored in regmatch_t_service
    * these are then used by allowed_hostname_or_ip_in_service
    * see regexec(3) for more infos */
   if (!is_service_wellformed(service_line)) {
-    return OLSR_FALSE;
+    return false;
   } else if (!allowed_hostname_or_ip_in_service(service_line, &(regmatch_t_service[1]))) {
-    return OLSR_FALSE;
+    return false;
   }
 
-  return OLSR_TRUE;
+  return true;
 }
 
-olsr_bool
+bool
 allowed_hostname_or_ip_in_service(const char *service_line, const regmatch_t * hostname_or_ip_match)
 {
   char *hostname_or_ip;
   union olsr_ip_addr olsr_ip;
   struct name_entry *name;
   if (hostname_or_ip_match->rm_so < 0 || hostname_or_ip_match->rm_eo < 0) {
-    return OLSR_FALSE;
+    return false;
   }
 
   hostname_or_ip = strndup(&service_line[hostname_or_ip_match->rm_so], hostname_or_ip_match->rm_eo - hostname_or_ip_match->rm_so);
@@ -1464,7 +1484,7 @@
       OLSR_PRINTF(4, "NAME PLUGIN: hostname %s in service %s is OK\n", hostname_or_ip, service_line);
       free(hostname_or_ip);
       hostname_or_ip = NULL;
-      return OLSR_TRUE;
+      return true;
     }
   }
 
@@ -1475,7 +1495,7 @@
       OLSR_PRINTF(2, "NAME PLUGIN: ip %s in service %s is OK\n", olsr_ip_to_string(&strbuf, &olsr_ip), service_line);
       free(hostname_or_ip);
       hostname_or_ip = NULL;
-      return OLSR_TRUE;
+      return true;
     }
   }
 
@@ -1484,7 +1504,7 @@
   free(hostname_or_ip);
   hostname_or_ip = NULL;
 
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -1492,16 +1512,32 @@
  * of "protocol://host:port/path|tcp_or_udp|a short description",
  * which is given in the regex regex_t_service
  */
-olsr_bool
+bool
 is_service_wellformed(const char *service_line)
 {
   return regexec(&regex_t_service, service_line, pmatch_service, regmatch_t_service, 0) == 0;
 }
 
+/*
+ * check if the mac matches the syntax
+ */
+bool
+is_mac_wellformed(const char *mac_line)
+{
+  size_t i;
+  bool ret;
+  int x[6], d = -1;
+  for(i = 0; i < ARRAYSIZE(x); i++) x[i] = -1;
+  sscanf(mac_line, "%02x:%02x:%02x:%02x:%02x:%02x,%d\n", &x[0], &x[1], &x[2], &x[3], &x[4], &x[5], &d);
+  ret = 0 <= d && d <= 0xffff;
+  for(i = 0; i < ARRAYSIZE(x); i++) ret = ret && 0 <= x[i];
+  return ret;
+}
+
 /**
  * check if the latlot matches the syntax
  */
-olsr_bool
+bool
 is_latlon_wellformed(const char *latlon_line)
 {
   int hna = -1;
@@ -1513,16 +1549,16 @@
 /**
  * Returns 1 if this olsrd announces inet
  */
-olsr_bool
+bool
 get_isdefhna_latlon(void)
 {
   struct ip_prefix_list *hna;
   for (hna = olsr_cnf->hna_entries; hna != NULL; hna = hna->next) {
     if (hna->net.prefix_len == 0) {
-      return OLSR_TRUE;
+      return true;
     }
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -1592,7 +1628,7 @@
   fprintf(fmap, "/* This file is overwritten regularly by olsrd */\n");
   mapwrite_work(fmap);
   fclose(fmap);
-  latlon_table_changed = OLSR_FALSE;
+  latlon_table_changed = false;
 }
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 lib/nameservice/src/nameservice.h
--- a/lib/nameservice/src/nameservice.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/nameservice/src/nameservice.h	Fri Mar 13 19:16:23 2009 +0100
@@ -85,8 +85,8 @@
  */
 struct name_entry {
   union olsr_ip_addr ip;
-  olsr_u16_t type;
-  olsr_u16_t len;
+  uint16_t type;
+  uint16_t len;
   char *name;
   struct name_entry *next;             /* linked list */
 };
@@ -122,7 +122,7 @@
 void olsr_namesvc_delete_db_entry(struct db_entry *);
 
 /* Parser function to register with the sceduler */
-olsr_bool olsr_parser(union olsr_message *, struct interface *, union olsr_ip_addr *);
+bool olsr_parser(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 /* callback for periodic timer */
 void olsr_namesvc_gen(void *);
@@ -135,17 +135,17 @@
 
 void free_all_list_entries(struct list_node *);
 
-void decap_namemsg(struct name *from_packet, struct name_entry **to, olsr_bool * this_table_changed);
+void decap_namemsg(struct name *from_packet, struct name_entry **to, bool * this_table_changed);
 
-void insert_new_name_in_list(union olsr_ip_addr *, struct list_node *, struct name *, olsr_bool *, olsr_reltime);
+void insert_new_name_in_list(union olsr_ip_addr *, struct list_node *, struct name *, bool *, olsr_reltime);
 
-olsr_bool allowed_hostname_or_ip_in_service(const char *service_line, const regmatch_t * hostname_or_ip);
+bool allowed_hostname_or_ip_in_service(const char *service_line, const regmatch_t * hostname_or_ip);
 
 void update_name_entry(union olsr_ip_addr *, struct namemsg *, int, olsr_reltime);
 
 void write_hosts_file(void);
 
-void write_services_file(void);
+void write_services_file(bool writemacs);
 
 void write_resolv_file(void);
 
@@ -153,19 +153,19 @@
 
 void free_name_entry_list(struct name_entry **list);
 
-olsr_bool allowed_ip(const union olsr_ip_addr *addr);
+bool allowed_ip(const union olsr_ip_addr *addr);
 
-olsr_bool allowed_service(const char *service_line);
+bool allowed_service(const char *service_line);
 
-olsr_bool is_name_wellformed(const char *service_line);
+bool is_name_wellformed(const char *service_line);
 
-olsr_bool is_service_wellformed(const char *service_line);
+bool is_service_wellformed(const char *service_line);
 
-olsr_bool is_service_wellformed(const char *service_line);
+bool is_mac_wellformed(const char *service_line);
 
-olsr_bool is_latlon_wellformed(const char *latlon_line);
+bool is_latlon_wellformed(const char *latlon_line);
 
-olsr_bool get_isdefhna_latlon(void);
+bool get_isdefhna_latlon(void);
 
 void lookup_defhna_latlon(union olsr_ip_addr *ip);
 
diff -r feb3d7883ff0 -r d73e73400732 lib/nameservice/src/nameservice_msg.h
--- a/lib/nameservice/src/nameservice_msg.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/nameservice/src/nameservice_msg.h	Fri Mar 13 19:16:23 2009 +0100
@@ -43,6 +43,7 @@
   NAME_FORWARDER = 1,
   NAME_SERVICE = 2,
   NAME_LATLON = 3,
+  NAME_MACADDR = 4,
 } NAME_TYPE;
 
 /**
@@ -50,8 +51,8 @@
  * message
  **/
 struct name {
-  olsr_u16_t type;
-  olsr_u16_t len;                      // length of the name
+  uint16_t type;
+  uint16_t len;                      // length of the name
   // the ip of the hostname, or the ip of the dns-server
   // ip is irrelevant for services
   union olsr_ip_addr ip;
@@ -61,8 +62,8 @@
 };
 
 struct namemsg {
-  olsr_u16_t version;                  // version number of the nameservice plugin
-  olsr_u16_t nr_names;                 // number of following packets including names, forwarders or services
+  uint16_t version;                  // version number of the nameservice plugin
+  uint16_t nr_names;                 // number of following packets including names, forwarders or services
   /*
    * at least one struct name following
    */
diff -r feb3d7883ff0 -r d73e73400732 lib/pgraph/src/olsrd_pgraph.c
--- a/lib/pgraph/src/olsrd_pgraph.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/pgraph/src/olsrd_pgraph.c	Fri Mar 13 19:16:23 2009 +0100
@@ -215,7 +215,7 @@
 plugin_ipc_init(void)
 {
   struct sockaddr_in sin;
-  olsr_u32_t yes = 1;
+  uint32_t yes = 1;
 
   /* Init ipc socket */
   if ((ipc_socket = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
@@ -385,7 +385,7 @@
   if (ipc_connection == -1)
     return 0;
 
-#if defined __FreeBSD__ || defined __MacOSX__
+#if defined __FreeBSD__ || defined __MacOSX__ || __OpenBSD__
 #define FLAG 0
 #else
 #define FLAG MSG_NOSIGNAL
diff -r feb3d7883ff0 -r d73e73400732 lib/secure/src/olsrd_secure.c
--- a/lib/secure/src/olsrd_secure.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/secure/src/olsrd_secure.c	Fri Mar 13 19:16:23 2009 +0100
@@ -73,7 +73,7 @@
 #include "md5.h"
 
 static void
-MD5_checksum(const olsr_u8_t * data, const olsr_u16_t data_len, olsr_u8_t * hashbuf)
+MD5_checksum(const uint8_t * data, const uint16_t data_len, uint8_t * hashbuf)
 {
   MD5_CTX context;
 
@@ -115,8 +115,8 @@
   union olsr_ip_addr addr;
   /* Timestamp difference */
   int diff;
-  olsr_u32_t challenge;
-  olsr_u8_t validated;
+  uint32_t challenge;
+  uint8_t validated;
   clock_t valtime;                     /* Validity time */
   clock_t conftime;                    /* Reconfiguration time */
   struct stamp *prev;
@@ -139,8 +139,8 @@
 static void olsr_event(void);
 #endif
 static int send_challenge(struct interface *olsr_if, const union olsr_ip_addr *);
-static int send_cres(struct interface *olsr_if, union olsr_ip_addr *, union olsr_ip_addr *, olsr_u32_t, struct stamp *);
-static int send_rres(struct interface *olsr_if, union olsr_ip_addr *, union olsr_ip_addr *, olsr_u32_t);
+static int send_cres(struct interface *olsr_if, union olsr_ip_addr *, union olsr_ip_addr *, uint32_t, struct stamp *);
+static int send_rres(struct interface *olsr_if, union olsr_ip_addr *, union olsr_ip_addr *, uint32_t);
 static int parse_challenge(struct interface *olsr_if, char *);
 static int parse_cres(struct interface *olsr_if, char *);
 static int parse_rres(char *);
@@ -148,7 +148,7 @@
 #if 0
 static int ipc_send(char *, int);
 #endif
-static int add_signature(olsr_u8_t *, int *);
+static int add_signature(uint8_t *, int *);
 static int validate_packet(struct interface *olsr_if, const char *, int *);
 static char *secure_preprocessor(char *packet, struct interface *olsr_if, union olsr_ip_addr *from_addr, int *length);
 static void timeout_timestamps(void *);
@@ -304,13 +304,13 @@
  * increase the size
  */
 int
-add_signature(olsr_u8_t * pck, int *size)
+add_signature(uint8_t * pck, int *size)
 {
   struct s_olsrmsg *msg;
 #ifdef DEBUG
   unsigned int i;
   int j;
-  const olsr_u8_t *sigmsg;
+  const uint8_t *sigmsg;
 #endif
 
   olsr_printf(2, "[ENC]Adding signature for packet size %d\n", *size);
@@ -336,13 +336,13 @@
 
   /* Add timestamp */
   msg->sig.timestamp = htonl(now.tv_sec);
-  olsr_printf(3, "[ENC]timestamp: %ld\n", now.tv_sec);
+  olsr_printf(3, "[ENC]timestamp: %lld\n", (long long)now.tv_sec);
 
   /* Set the new size */
   *size += sizeof(struct s_olsrmsg);
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, pck, *size - SIGNATURE_SIZE);
@@ -357,7 +357,7 @@
   olsr_printf(1, "Signature message:\n");
 
   j = 0;
-  sigmsg = (olsr_u8_t *) msg;
+  sigmsg = (uint8_t *) msg;
 
   for (i = 0; i < sizeof(struct s_olsrmsg); i++) {
     olsr_printf(1, "  %3i", sigmsg[i]);
@@ -378,14 +378,14 @@
 validate_packet(struct interface *olsr_if, const char *pck, int *size)
 {
   int packetsize;
-  olsr_u8_t sha1_hash[SIGNATURE_SIZE];
+  uint8_t sha1_hash[SIGNATURE_SIZE];
   const struct s_olsrmsg *sig;
   time_t rec_time;
 
 #ifdef DEBUG
   unsigned int i;
   int j;
-  const olsr_u8_t *sigmsg;
+  const uint8_t *sigmsg;
 #endif
 
   /* Find size - signature message */
@@ -402,7 +402,7 @@
   olsr_printf(1, "Input message:\n");
 
   j = 0;
-  sigmsg = (const olsr_u8_t *)sig;
+  sigmsg = (const uint8_t *)sig;
 
   for (i = 0; i < sizeof(struct s_olsrmsg); i++) {
     olsr_printf(1, "  %3i", sigmsg[i]);
@@ -441,7 +441,7 @@
 one_checksum_SHA:
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, pck, *size - SIGNATURE_SIZE);
@@ -455,7 +455,7 @@
 #ifdef DEBUG
   olsr_printf(1, "Recevied hash:\n");
 
-  sigmsg = (const olsr_u8_t *)sig->sig.signature;
+  sigmsg = (const uint8_t *)sig->sig.signature;
 
   for (i = 0; i < SIGNATURE_SIZE; i++) {
     olsr_printf(1, " %3i", sigmsg[i]);
@@ -487,7 +487,7 @@
     return 0;
   }
 
-  olsr_printf(1, "[ENC]Received timestamp %ld diff: %ld\n", rec_time, now.tv_sec - rec_time);
+  olsr_printf(1, "[ENC]Received timestamp %lld diff: %lld\n", (long long)rec_time, (long long)now.tv_sec - (long long)rec_time);
 
   /* Remove signature message */
   *size = packetsize;
@@ -549,7 +549,7 @@
 {
   struct challengemsg cmsg;
   struct stamp *entry;
-  olsr_u32_t challenge, hash;
+  uint32_t challenge, hash;
   struct ipaddr_str buf;
 
   olsr_printf(1, "[ENC]Building CHALLENGE message\n");
@@ -575,7 +575,7 @@
   olsr_printf(3, "[ENC]Size: %lu\n", (unsigned long)sizeof(struct challengemsg));
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, &cmsg, sizeof(struct challengemsg) - SIGNATURE_SIZE);
@@ -621,7 +621,7 @@
 parse_cres(struct interface *olsr_if, char *in_msg)
 {
   struct c_respmsg *msg;
-  olsr_u8_t sha1_hash[SIGNATURE_SIZE];
+  uint8_t sha1_hash[SIGNATURE_SIZE];
   struct stamp *entry;
   struct ipaddr_str buf;
 
@@ -640,7 +640,7 @@
   /* Check signature */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, msg, sizeof(struct c_respmsg) - SIGNATURE_SIZE);
@@ -670,14 +670,14 @@
   olsr_printf(3, "[ENC]Entry-challenge 0x%x\n", entry->challenge);
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* First the challenge received */
     memcpy(checksum_cache, &entry->challenge, 4);
     /* Then the local IP */
-    memcpy(&checksum_cache[sizeof(olsr_u32_t)], &msg->originator, olsr_cnf->ipsize);
+    memcpy(&checksum_cache[sizeof(uint32_t)], &msg->originator, olsr_cnf->ipsize);
 
     /* Create the hash */
-    CHECKSUM(checksum_cache, sizeof(olsr_u32_t) + olsr_cnf->ipsize, sha1_hash);
+    CHECKSUM(checksum_cache, sizeof(uint32_t) + olsr_cnf->ipsize, sha1_hash);
   }
 
   if (memcmp(msg->res_sig, sha1_hash, SIGNATURE_SIZE) != 0) {
@@ -711,7 +711,7 @@
 parse_rres(char *in_msg)
 {
   struct r_respmsg *msg;
-  olsr_u8_t sha1_hash[SIGNATURE_SIZE];
+  uint8_t sha1_hash[SIGNATURE_SIZE];
   struct stamp *entry;
   struct ipaddr_str buf;
 
@@ -728,7 +728,7 @@
   /* Check signature */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, msg, sizeof(struct r_respmsg) - SIGNATURE_SIZE);
@@ -758,14 +758,14 @@
   olsr_printf(3, "[ENC]Entry-challenge 0x%x\n", entry->challenge);
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* First the challenge received */
     memcpy(checksum_cache, &entry->challenge, 4);
     /* Then the local IP */
-    memcpy(&checksum_cache[sizeof(olsr_u32_t)], &msg->originator, olsr_cnf->ipsize);
+    memcpy(&checksum_cache[sizeof(uint32_t)], &msg->originator, olsr_cnf->ipsize);
 
     /* Create the hash */
-    CHECKSUM(checksum_cache, sizeof(olsr_u32_t) + olsr_cnf->ipsize, sha1_hash);
+    CHECKSUM(checksum_cache, sizeof(uint32_t) + olsr_cnf->ipsize, sha1_hash);
   }
 
   if (memcmp(msg->res_sig, sha1_hash, SIGNATURE_SIZE) != 0) {
@@ -796,9 +796,9 @@
 parse_challenge(struct interface *olsr_if, char *in_msg)
 {
   struct challengemsg *msg;
-  olsr_u8_t sha1_hash[SIGNATURE_SIZE];
+  uint8_t sha1_hash[SIGNATURE_SIZE];
   struct stamp *entry;
-  olsr_u32_t hash;
+  uint32_t hash;
   struct ipaddr_str buf;
 
   msg = (struct challengemsg *)in_msg;
@@ -839,7 +839,7 @@
   /* Check signature */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, msg, sizeof(struct challengemsg) - SIGNATURE_SIZE);
@@ -875,10 +875,10 @@
  *
  */
 int
-send_cres(struct interface *olsr_if, union olsr_ip_addr *to, union olsr_ip_addr *from, olsr_u32_t chal_in, struct stamp *entry)
+send_cres(struct interface *olsr_if, union olsr_ip_addr *to, union olsr_ip_addr *from, uint32_t chal_in, struct stamp *entry)
 {
   struct c_respmsg crmsg;
-  olsr_u32_t challenge;
+  uint32_t challenge;
   struct ipaddr_str buf;
 
   olsr_printf(1, "[ENC]Building CRESPONSE message\n");
@@ -901,7 +901,7 @@
 
   /* set timestamp */
   crmsg.timestamp = now.tv_sec;
-  olsr_printf(3, "[ENC]Timestamp %ld\n", crmsg.timestamp);
+  olsr_printf(3, "[ENC]Timestamp %lld\n", (long long)crmsg.timestamp);
 
   /* Fill subheader */
   memcpy(&crmsg.destination, to, olsr_cnf->ipsize);
@@ -910,21 +910,21 @@
   /* Create digest of received challenge + IP */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the challenge received */
     memcpy(checksum_cache, &chal_in, 4);
     /* Then the local IP */
-    memcpy(&checksum_cache[sizeof(olsr_u32_t)], from, olsr_cnf->ipsize);
+    memcpy(&checksum_cache[sizeof(uint32_t)], from, olsr_cnf->ipsize);
 
     /* Create the hash */
-    CHECKSUM(checksum_cache, sizeof(olsr_u32_t) + olsr_cnf->ipsize, crmsg.res_sig);
+    CHECKSUM(checksum_cache, sizeof(uint32_t) + olsr_cnf->ipsize, crmsg.res_sig);
   }
 
   /* Now create the digest of the message and the key */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, &crmsg, sizeof(struct c_respmsg) - SIGNATURE_SIZE);
@@ -951,7 +951,7 @@
  *
  */
 static int
-send_rres(struct interface *olsr_if, union olsr_ip_addr *to, union olsr_ip_addr *from, olsr_u32_t chal_in)
+send_rres(struct interface *olsr_if, union olsr_ip_addr *to, union olsr_ip_addr *from, uint32_t chal_in)
 {
   struct r_respmsg rrmsg;
   struct ipaddr_str buf;
@@ -969,7 +969,7 @@
 
   /* set timestamp */
   rrmsg.timestamp = now.tv_sec;
-  olsr_printf(3, "[ENC]Timestamp %ld\n", rrmsg.timestamp);
+  olsr_printf(3, "[ENC]Timestamp %lld\n", (long long)rrmsg.timestamp);
 
   /* Fill subheader */
   memcpy(&rrmsg.destination, to, olsr_cnf->ipsize);
@@ -977,21 +977,21 @@
   /* Create digest of received challenge + IP */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the challenge received */
     memcpy(checksum_cache, &chal_in, 4);
     /* Then the local IP */
-    memcpy(&checksum_cache[sizeof(olsr_u32_t)], from, olsr_cnf->ipsize);
+    memcpy(&checksum_cache[sizeof(uint32_t)], from, olsr_cnf->ipsize);
 
     /* Create the hash */
-    CHECKSUM(checksum_cache, sizeof(olsr_u32_t) + olsr_cnf->ipsize, rrmsg.res_sig);
+    CHECKSUM(checksum_cache, sizeof(uint32_t) + olsr_cnf->ipsize, rrmsg.res_sig);
   }
 
   /* Now create the digest of the message and the key */
 
   {
-    olsr_u8_t checksum_cache[512 + KEYLENGTH];
+    uint8_t checksum_cache[512 + KEYLENGTH];
     /* Create packet + key cache */
     /* First the OLSR packet + signature message - digest */
     memcpy(checksum_cache, &rrmsg, sizeof(struct r_respmsg) - SIGNATURE_SIZE);
@@ -1016,7 +1016,7 @@
 static struct stamp *
 lookup_timestamp_entry(const union olsr_ip_addr *adr)
 {
-  olsr_u32_t hash;
+  uint32_t hash;
   struct stamp *entry;
   struct ipaddr_str buf;
 
diff -r feb3d7883ff0 -r d73e73400732 lib/secure/src/secure_messages.h
--- a/lib/secure/src/secure_messages.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/secure/src/secure_messages.h	Fri Mar 13 19:16:23 2009 +0100
@@ -77,12 +77,12 @@
  ****************************************************************************/
 
 struct sig_msg {
-  olsr_u8_t type;
-  olsr_u8_t algorithm;
-  olsr_u16_t reserved;
+  uint8_t type;
+  uint8_t algorithm;
+  uint16_t reserved;
 
   time_t timestamp;
-  olsr_u8_t signature[SIGSIZE];
+  uint8_t signature[SIGSIZE];
 };
 
 /*
@@ -90,13 +90,13 @@
  */
 
 struct s_olsrmsg {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
-  olsr_u32_t originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
+  uint32_t originator;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
   /* YOUR PACKET GOES HERE */
   struct sig_msg sig;
@@ -108,54 +108,54 @@
  */
 
 struct challengemsg {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
-  olsr_u32_t originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
+  uint32_t originator;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
-  olsr_u32_t destination;
-  olsr_u32_t challenge;
+  uint32_t destination;
+  uint32_t challenge;
 
-  olsr_u8_t signature[SIGSIZE];
+  uint8_t signature[SIGSIZE];
 
 };
 
 struct c_respmsg {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
-  olsr_u32_t originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
+  uint32_t originator;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
-  olsr_u32_t destination;
-  olsr_u32_t challenge;
+  uint32_t destination;
+  uint32_t challenge;
   time_t timestamp;
 
-  olsr_u8_t res_sig[SIGSIZE];
+  uint8_t res_sig[SIGSIZE];
 
-  olsr_u8_t signature[SIGSIZE];
+  uint8_t signature[SIGSIZE];
 };
 
 struct r_respmsg {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
-  olsr_u32_t originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
+  uint32_t originator;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
-  olsr_u32_t destination;
+  uint32_t destination;
   time_t timestamp;
 
-  olsr_u8_t res_sig[SIGSIZE];
+  uint8_t res_sig[SIGSIZE];
 
-  olsr_u8_t signature[SIGSIZE];
+  uint8_t signature[SIGSIZE];
 };
 
 /*
@@ -163,13 +163,13 @@
  */
 
 struct s_olsrmsg6 {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
   struct in6_addr originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
   /* YOUR PACKET GOES HERE */
   struct sig_msg sig;
@@ -180,14 +180,14 @@
  */
 
 struct s_olsr {
-  olsr_u16_t olsr_packlen;             /* packet length */
-  olsr_u16_t olsr_seqno;
+  uint16_t olsr_packlen;             /* packet length */
+  uint16_t olsr_seqno;
   struct s_olsrmsg olsr_msg[1];        /* variable messages */
 };
 
 struct s_olsr6 {
-  olsr_u16_t olsr_packlen;             /* packet length */
-  olsr_u16_t olsr_seqno;
+  uint16_t olsr_packlen;             /* packet length */
+  uint16_t olsr_seqno;
   struct s_olsrmsg6 olsr_msg[1];       /* variable messages */
 };
 
diff -r feb3d7883ff0 -r d73e73400732 lib/tas/src/lua/lobject.c
--- a/lib/tas/src/lua/lobject.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/tas/src/lua/lobject.c	Fri Mar 13 19:16:23 2009 +0100
@@ -42,11 +42,11 @@
   return (m << 3) | cast(int, x);
 }
 
+/* *INDENT-OFF* */
 int
 luaO_log2(unsigned int x)
 {
   static const lu_byte log_8[255] = {
-/* *INDENT-OFF* */
     0,
     1,1,
     2,2,2,2,
@@ -59,7 +59,6 @@
     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
     7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
-/* *INDENT-ON* */
   };
   if (x >= 0x00010000) {
     if (x >= 0x01000000)
@@ -74,6 +73,7 @@
     return -1;                  /* special `log' for 0 */
   }
 }
+/* *INDENT-ON* */
 
 int
 luaO_rawequalObj(const TObject * t1, const TObject * t2)
diff -r feb3d7883ff0 -r d73e73400732 lib/tas/src/plugin.c
--- a/lib/tas/src/plugin.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/tas/src/plugin.c	Fri Mar 13 19:16:23 2009 +0100
@@ -118,7 +118,7 @@
            rawIpAddrToString(&iterLinkTab->local_iface_addr, ipAddrLen), rawIpAddrToString(&iterLinkTab->neighbor_iface_addr,
                                                                                            ipAddrLen),
            rawIpAddrToString(&iterLinkTab->neighbor->neighbor_main_addr, ipAddrLen), iterLinkTab->L_link_quality,
-           get_linkcost_text(iterLinkTab->linkcost, OLSR_FALSE, &lqbuffer));
+           get_linkcost_text(iterLinkTab->linkcost, false, &lqbuffer));
 
   link_node = iterLinkTab->link_list.next;
   if (link_node != &link_entry_head) {
@@ -285,7 +285,7 @@
 
     res =
       snprintf(buff, len, "[~%d~address~%s~cost~%s~]~", i, rawIpAddrToString(&tc_edge->T_dest_addr, ipAddrLen),
-               get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer));
+               get_linkcost_text(tc_edge->cost, false, &lqbuffer));
 
     if (res < len)
       buff += res;
@@ -317,7 +317,7 @@
   iterTcTab = (node ? vertex_tree2tc(node) : NULL);
 }
 
-static olsr_bool
+static bool
 parserFunc(union olsr_message *msg, struct interface *inInt __attribute__ ((unused)), union olsr_ip_addr *neighIntAddr)
 {
   char *mess = (char *)msg;
@@ -327,16 +327,16 @@
   int i;
 
   if (memcmp(orig, mainAddr, ipAddrLen) == 0)
-    return OLSR_FALSE;
+    return false;
 
   if (check_neighbor_link(neighIntAddr) != SYM_LINK) {
     error("TAS message not from symmetric neighbour\n");
-    return OLSR_FALSE;
+    return false;
   }
 
   if (len < ipAddrLen + 8 + 2) {
     error("short TAS message received (%d bytes)\n", len);
-    return OLSR_FALSE;
+    return false;
   }
 
   len -= ipAddrLen + 8;
@@ -346,12 +346,12 @@
 
   if (i++ == len) {
     error("TAS message has unterminated service string\n");
-    return OLSR_FALSE;
+    return false;
   }
 
   if (i == len) {
     error("TAS message lacks payload string\n");
-    return OLSR_FALSE;
+    return false;
   }
 
   string = service + i;
@@ -361,13 +361,13 @@
 
   if (i == len) {
     error("TAS message has unterminated payload string\n");
-    return OLSR_FALSE;
+    return false;
   }
 
   httpAddTasMessage(service, string, rawIpAddrToString(orig, ipAddrLen));
 
   /* Forward the message */
-  return OLSR_TRUE;
+  return true;
 }
 
 void
diff -r feb3d7883ff0 -r d73e73400732 lib/txtinfo/src/olsrd_txtinfo.c
--- a/lib/txtinfo/src/olsrd_txtinfo.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/lib/txtinfo/src/olsrd_txtinfo.c	Fri Mar 13 19:16:23 2009 +0100
@@ -155,7 +155,7 @@
   struct sockaddr_storage sst;
   struct sockaddr_in *sin;
   struct sockaddr_in6 *sin6;
-  olsr_u32_t yes = 1;
+  uint32_t yes = 1;
   socklen_t addrlen;
 
   /* Init ipc socket */
@@ -353,7 +353,7 @@
     ipc_sendf("%s\t%s\t%0.2f\t%s\t%s\t\n", olsr_ip_to_string(&buf1, &link->local_iface_addr),
               olsr_ip_to_string(&buf2, &link->neighbor_iface_addr), link->L_link_quality, get_link_entry_text(link, '\t',
                                                                                                               &lqbuffer1),
-              get_linkcost_text(link->linkcost, OLSR_FALSE, &lqbuffer2));
+              get_linkcost_text(link->linkcost, false, &lqbuffer2));
   } OLSR_FOR_ALL_LINK_ENTRIES_END(link);
 
   ipc_sendf("\n");
@@ -372,7 +372,7 @@
   OLSR_FOR_ALL_RT_ENTRIES(rt) {
     ipc_sendf("%s/%d\t%s\t%d\t%s\t%s\t\n", olsr_ip_to_string(&buf1, &rt->rt_dst.prefix), rt->rt_dst.prefix_len,
               olsr_ip_to_string(&buf2, &rt->rt_best->rtp_nexthop.gateway), rt->rt_best->rtp_metric.hops,
-              get_linkcost_text(rt->rt_best->rtp_metric.cost, OLSR_TRUE, &lqbuffer),
+              get_linkcost_text(rt->rt_best->rtp_metric.cost, true, &lqbuffer),
               if_ifwithindex_name(rt->rt_best->rtp_nexthop.iif_index));
   } OLSR_FOR_ALL_RT_ENTRIES_END(rt);
 
@@ -395,7 +395,7 @@
         struct ipaddr_str dstbuf, addrbuf;
         struct lqtextbuffer lqbuffer1, lqbuffer2;
         ipc_sendf("%s\t%s\t%s\t%s\n", olsr_ip_to_string(&dstbuf, &tc_edge->T_dest_addr), olsr_ip_to_string(&addrbuf, &tc->addr),
-                  get_tc_edge_entry_text(tc_edge, '\t', &lqbuffer1), get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer2));
+                  get_tc_edge_entry_text(tc_edge, '\t', &lqbuffer1), get_linkcost_text(tc_edge->cost, false, &lqbuffer2));
       }
     } OLSR_FOR_ALL_TC_EDGE_ENTRIES_END(tc, tc_edge);
   } OLSR_FOR_ALL_TC_ENTRIES_END(tc);
@@ -462,7 +462,7 @@
 
     while (entry != &mid_set[index]) {
       struct ipaddr_str buf;
-      ipc_sendf(olsr_ip_to_string(&buf, &entry->main_addr));
+      ipc_sendf("%s", olsr_ip_to_string(&buf, &entry->main_addr));
       alias = entry->aliases;
       is_first = 1;
 
diff -r feb3d7883ff0 -r d73e73400732 release-howto.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/release-howto.txt	Fri Mar 13 19:16:23 2009 +0100
@@ -0,0 +1,93 @@
+cheat sheet for making a (stable) release tarball.
+
+0. check if your name settings in .hgrc are correct. (have
+   your real name and email address in there).
+
+1. clone a fresh tree:
+
+   $ hg clone http://gredler.at/hg/olsrd-0.5.6
+   $ hg update -C OLSRD_0_5_6_BRANCH
+
+2. check if the DEBUG settings in Makefile.inc are correct:
+
+   DEBUG ?= 0
+   NO_DEBUG_MESSAGES ?= 1
+
+   now check if it builds correct:
+
+   $ make build_all
+
+3. Change VERS in Makefile.inc to your target release.
+   in this example the target release is 0.5.6-r4
+
+   most likely this is carrying some pre-XXX-release tag.
+   
+   $ grep -E "^VERS" Makefile
+   VERS =          pre-0.5.6-r4
+
+   change it to
+
+   VERS =          0.5.6-r4
+
+4. commit & push
+
+5. display the used tags: 
+   
+   $ hg tags
+   tip                             1757:77e1ccb98227
+   OLSRD_0_5_6_R3                  1728:feb3d7883ff0
+   OLSRD_0_5_6_R2                  1688:1573e530a679
+   OLSRD_0_5_6                     1669:d91b47b34ba7
+   OLSRD_0_5_6_RC7                 1644:1516480b552f
+   OLSRD_0_5_6_RC6                 1634:f1b2cdeafd74
+   OLSRD_0_5_6_RC5                 1622:99b89bb6a9a4
+   OLSRD_0_5_6_RC4                 1612:0490bdcb7910
+   OLSRD_0_5_6_RC3                 1591:c6c9571fe4d6
+   OLSRD_0_5_6_RC2                 1587:bd66c98dc4c8
+   OLSRD_0_5_6_RC1                 1526:fd8f4e49a398
+   OLSRD_0_5_5                     1460:233036647bca
+   OLSRD_0_5_5_RC1                 1452:669b81f6918e
+   OLSRD_0_5_4                     1264:60f04fc39707
+   OLSRD_0_5_3                     1158:00991ca84047
+   OLSRD_0_5_2                     1121:283effb1472c
+   OLSRD_0_5_1                     1101:c23aab9db1e1
+   OLSRD_0_5_0                      994:612f5a21a303
+   OLSRD_0_4_10                     893:a39cda38836b
+   OLSRD_0_4_9                      704:43d67c4814ef
+   OLSRD_0_4_8                      404:e9beaf82c0ea
+
+   now tag the tree (please stick to the tagging scheme).
+
+   $ hg tag OLSRD_0_5_6_R4
+
+6. make the release tarball
+
+   $ cd scripts/
+   $ ./mk-tarball.sh
+   [ ... ]
+   ### creating /tmp/olsrd-0.5.6-r4.tar.gz
+   6c996e94de06115d19dbbcaf6847051a  /tmp/olsrd-0.5.6-r4.tar.gz
+   ### creating /tmp/olsrd-0.5.6-r4.tar.bz2
+   e476819be5747758e3d6f579e4096bce  /tmp/olsrd-0.5.6-r4.tar.bz2
+
+7. check if everything is in the release tarball (ideally on a a
+   differnt machine) and try to build from the tarball.
+
+8. upload the the .tgz and .bz2 tarballs to the http://www.olsr.org/downaload/0.5/
+   sectaion and add a release articel on the web.
+
+9. Change VERS in Makefile.inc to your *next* target release.
+   in this example the next target release is pre-0.5.6-r5
+
+   change it from:
+   
+   $ grep -E "^VERS" Makefile
+   VERS =          0.5.6-r4
+
+   to
+
+   VERS =          pre-0.5.6-r5
+
+   commit & push
+
+you are done, congratulations !
diff -r feb3d7883ff0 -r d73e73400732 src/bsd/kernel_routes.c
--- a/src/bsd/kernel_routes.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/bsd/kernel_routes.c	Fri Mar 13 19:16:23 2009 +0100
@@ -46,14 +46,17 @@
 #include "net_olsr.h"
 #include "ipcalc.h"
 
+#include <errno.h>
+#include <unistd.h>
 #include <net/if_dl.h>
-#include <ifaddrs.h>
 
 #ifdef _WRS_KERNEL
+#include <net/ifaddrs.h>
 #include <wrn/coreip/net/route.h>
 #include <m2Lib.h>
 #define OLSR_PID taskIdSelf ()
 #else
+#include <ifaddrs.h>
 #define OLSR_PID getpid ()
 #endif
 
@@ -68,19 +71,16 @@
 static int
 add_del_route(const struct rt_entry *rt, int add)
 {
-  struct rt_msghdr *rtm;               /* message to configure a route */
-  /* contains data to be written to the
-     routing socket */
+  struct rt_msghdr *rtm;               /* message to send to the routing socket */
   unsigned char buff[512];
   unsigned char *walker;               /* points within the buffer */
-  struct sockaddr_in sin;              /* internet style sockaddr */
+  struct sockaddr_in sin4;             /* internet style sockaddr */
   struct sockaddr_dl *sdl;             /* link level sockaddr */
   struct ifaddrs *addrs;
   struct ifaddrs *awalker;
   const struct rt_nexthop *nexthop;
   union olsr_ip_addr mask;             /* netmask as ip address */
-  int sin_size, sdl_size;              /* size of addresses - e.g. destination
-                                          (payload of the message) */
+  int sin_size, sdl_size;              /* payload of the message */
   int len;                             /* message size written to routing socket */
 
   if (add) {
@@ -90,10 +90,10 @@
   }
 
   memset(buff, 0, sizeof(buff));
-  memset(&sin, 0, sizeof(sin));
+  memset(&sin4, 0, sizeof(sin4));
 
-  sin.sin_len = sizeof(sin);
-  sin.sin_family = AF_INET;
+  sin4.sin_len = sizeof(sin4);
+  sin4.sin_family = AF_INET;
 
   sin_size = 1 + ((sizeof(struct sockaddr_in) - 1) | 3);
   sdl_size = 1 + ((sizeof(struct sockaddr_dl) - 1) | 3);
@@ -108,7 +108,6 @@
   rtm->rtm_version = RTM_VERSION;
   rtm->rtm_type = add ? RTM_ADD : RTM_DELETE;
   rtm->rtm_index = 0;           /* is ignored in outgoing messages */
-  /* RTF_UP [and RTF_HOST and/or RTF_GATEWAY] */
   rtm->rtm_flags = olsr_rt_flags(rt);
   rtm->rtm_pid = OLSR_PID;
   rtm->rtm_seq = ++seq;
@@ -120,44 +119,42 @@
    *                  SET  DESTINATION OF THE ROUTE
    **********************************************************************/
 
-  rtm->rtm_addrs = RTA_DST;     /* part of the header */
-
-  sin.sin_addr = rt->rt_dst.prefix.v4;
-  OLSR_PRINTF(8, "\t- Destination of the route: %s\n", inet_ntoa(sin.sin_addr));
-
-  /* change proto or tos here */
-#ifdef CODE_IS_FIXED_ON_FBSD
+#ifdef _WRS_KERNEL
+  /*
+   * vxWorks: change proto or tos
+   */
   OLSR_PRINTF(8, "\t- Setting Protocol: 0\n");
-  ((struct sockaddr_rt *)(&sin))->srt_proto = 0;
+  ((struct sockaddr_rt *)(&sin4))->srt_proto = 0;
   OLSR_PRINTF(8, "\t- Setting TOS: 0\n");
-  ((struct sockaddr_rt *)(&sin))->srt_tos = 0;
+  ((struct sockaddr_rt *)(&sin4))->srt_tos = 0;
 #endif
 
-  memcpy(walker, &sin, sizeof(sin));
+  sin4.sin_addr = rt->rt_dst.prefix.v4;
+  memcpy(walker, &sin4, sizeof(sin4));
   walker += sin_size;
+  rtm->rtm_addrs = RTA_DST;
 
   /**********************************************************************
    *                  SET GATEWAY OF THE ROUTE
    **********************************************************************/
 
-  if (add || (rtm->rtm_addrs & RTF_GATEWAY)) {
-    rtm->rtm_addrs |= RTA_GATEWAY;      /* part of the header */
+#ifdef _WRS_KERNEL
+  /*
+   * vxWorks: Route with no gateway is deleted
+   */
+  if (add) {
+#endif
     nexthop = olsr_get_nh(rt);
-
-    if ((rtm->rtm_flags & RTF_GATEWAY)) {       /* GATEWAY */
-      sin.sin_addr = nexthop->gateway.v4;
-
-      memcpy(walker, &sin, sizeof(sin));
+    if (0 != (rtm->rtm_flags & RTF_GATEWAY)) {
+      sin4.sin_addr = nexthop->gateway.v4;
+      memcpy(walker, &sin4, sizeof(sin4));
       walker += sin_size;
-
-      OLSR_PRINTF(8, "\t- Gateway of the route: %s\n", inet_ntoa(sin.sin_addr));
+      rtm->rtm_addrs |= RTA_GATEWAY;
     }
-    /* NO GATEWAY - destination is directly reachable */
     else {
-      rtm->rtm_flags |= RTF_CLONING;    /* part of the header! */
-
       /*
-       * Host is directly reachable, so add the output interface MAC address.
+       * Host is directly reachable, so add
+       * the output interface MAC address.
        */
       if (getifaddrs(&addrs)) {
         fprintf(stderr, "\ngetifaddrs() failed\n");
@@ -176,38 +173,29 @@
 
       /* sdl is "struct sockaddr_dl" */
       sdl = (struct sockaddr_dl *)awalker->ifa_addr;
-#ifdef DEBUG
-      OLSR_PRINTF(8, "\t- Link layer address of the non gateway route: %s\n", LLADDR(sdl));
-#endif
-
       memcpy(walker, sdl, sdl->sdl_len);
       walker += sdl_size;
-
+      rtm->rtm_addrs |= RTA_GATEWAY;
+      rtm->rtm_flags |= RTF_CLONING;
+#ifndef _WRS_KERNEL
+      rtm->rtm_flags &= ~RTF_HOST;
+#endif
       freeifaddrs(addrs);
     }
-  } else {
-    /* Route with no gateway is deleted */
+#ifdef _WRS_KERNEL
   }
+#endif
 
   /**********************************************************************
    *                         SET  NETMASK
    **********************************************************************/
 
-  if ((rtm->rtm_flags & RTF_HOST)) {
-    OLSR_PRINTF(8, "\t- No netmask needed for a host route.\n");
-  } else {                      /* NO! hoste route */
-
-    rtm->rtm_addrs |= RTA_NETMASK;      /* part of the header */
-
-    if (!olsr_prefix_to_netmask(&mask, rt->rt_dst.prefix_len)) {
-      return -1;
-    }
-    sin.sin_addr = mask.v4;
-
-    memcpy(walker, &sin, sizeof(sin));
+  if (0 == (rtm->rtm_flags & RTF_HOST)) {
+    olsr_prefix_to_netmask(&mask, rt->rt_dst.prefix_len);
+    sin4.sin_addr = mask.v4;
+    memcpy(walker, &sin4, sizeof(sin4));
     walker += sin_size;
-
-    OLSR_PRINTF(8, "\t- Netmask of the route: %s\n", inet_ntoa(sin.sin_addr));
+    rtm->rtm_addrs |= RTA_NETMASK;
   }
 
   /**********************************************************************
@@ -215,23 +203,11 @@
    **********************************************************************/
 
   rtm->rtm_msglen = (unsigned short)(walker - buff);
-
   len = write(olsr_cnf->rts, buff, rtm->rtm_msglen);
-  OLSR_PRINTF(8, "\nWrote %d bytes to rts socket (FD=%d)\n", len, olsr_cnf->rts);
-
   if (0 != rtm->rtm_errno || len < rtm->rtm_msglen) {
     fprintf(stderr, "\nCannot write to routing socket: (rtm_errno= 0x%x) (last error message: %s)\n", rtm->rtm_errno,
             strerror(errno));
   }
-
-  OLSR_PRINTF(8,
-              "\nWriting the following information to routing socket (message header):" "\n\trtm_msglen: %u" "\n\trtm_version: %u"
-              "\n\trtm_type: %u" "\n\trtm_index: %u" "\n\trtm_flags: 0x%x" "\n\trtm_addrs: %u" "\n\trtm_pid: 0x%x" "\n\trtm_seq: %u"
-              "\n\trtm_errno: 0x%x" "\n\trtm_use %u" "\n\trtm_inits: %u\n", (unsigned int)rtm->rtm_msglen,
-              (unsigned int)rtm->rtm_version, (unsigned int)rtm->rtm_type, (unsigned int)rtm->rtm_index,
-              (unsigned int)rtm->rtm_flags, (unsigned int)rtm->rtm_addrs, (unsigned int)rtm->rtm_pid, (unsigned int)rtm->rtm_seq,
-              (unsigned int)rtm->rtm_errno, (unsigned int)rtm->rtm_use, (unsigned int)rtm->rtm_inits);
-
   return 0;
 }
 
@@ -256,7 +232,7 @@
   struct sockaddr_in6 sin6;
   struct sockaddr_dl sdl;
   const struct rt_nexthop *nexthop;
-  int step, step_dl;
+  int sin_size, sdl_size;
   int len;
 
   if (add) {
@@ -274,28 +250,41 @@
   sdl.sdl_len = sizeof(sdl);
   sdl.sdl_family = AF_LINK;
 
-  step = 1 + ((sizeof(struct sockaddr_in6) - 1) | 3);
-  step_dl = 1 + ((sizeof(struct sockaddr_dl) - 1) | 3);
+  sin_size = 1 + ((sizeof(struct sockaddr_in6) - 1) | 3);
+  sdl_size = 1 + ((sizeof(struct sockaddr_dl) - 1) | 3);
 
+  /**********************************************************************
+   *                  FILL THE ROUTING MESSAGE HEADER
+   **********************************************************************/
+
+  /* position header to the beginning of the buffer */
   rtm = (struct rt_msghdr *)buff;
   rtm->rtm_version = RTM_VERSION;
   rtm->rtm_type = (add != 0) ? RTM_ADD : RTM_DELETE;
   rtm->rtm_index = 0;
   rtm->rtm_flags = olsr_rt_flags(rt);
-  rtm->rtm_addrs = RTA_DST | RTA_GATEWAY;
+  rtm->rtm_pid = OLSR_PID;
   rtm->rtm_seq = ++seq;
 
+  /* walk to the end of the header */
   walker = buff + sizeof(struct rt_msghdr);
 
+  /**********************************************************************
+   *                  SET  DESTINATION OF THE ROUTE
+   **********************************************************************/
+
   memcpy(&sin6.sin6_addr.s6_addr, &rt->rt_dst.prefix.v6, sizeof(struct in6_addr));
+  memcpy(walker, &sin6, sizeof(sin6));
+  walker += sin_size;
+  rtm->rtm_addrs = RTA_DST;
 
-  memcpy(walker, &sin6, sizeof(sin6));
-  walker += step;
+  /**********************************************************************
+   *                  SET GATEWAY OF THE ROUTE
+   **********************************************************************/
 
   nexthop = olsr_get_nh(rt);
-  if ((rtm->rtm_flags & RTF_GATEWAY) != 0) {
+  if (0 != (rtm->rtm_flags & RTF_GATEWAY)) {
     memcpy(&sin6.sin6_addr.s6_addr, &nexthop->gateway.v6, sizeof(struct in6_addr));
-
     memset(&sin6.sin6_addr.s6_addr, 0, 8);
     sin6.sin6_addr.s6_addr[0] = 0xfe;
     sin6.sin6_addr.s6_addr[1] = 0x80;
@@ -305,12 +294,14 @@
     sin6.sin6_scope_id = 0;
 #endif
     memcpy(walker, &sin6, sizeof(sin6));
-    walker += step;
+    walker += sin_size;
+    rtm->rtm_addrs = RTA_GATEWAY;
   }
-
-  /* the host is directly reachable, so add the output interface's address */
-
   else {
+    /*
+     * Host is directly reachable, so add
+     * the output interface MAC address.
+     */
     memcpy(&sin6.sin6_addr.s6_addr, &rt->rt_dst.prefix.v6, sizeof(struct in6_addr));
     memset(&sin6.sin6_addr.s6_addr, 0, 8);
     sin6.sin6_addr.s6_addr[0] = 0xfe;
@@ -320,26 +311,36 @@
     *(u_int16_t *) & sin6.sin6_addr.s6_addr[2] = htons(sin6.sin6_scope_id);
     sin6.sin6_scope_id = 0;
 #endif
-
     memcpy(walker, &sin6, sizeof(sin6));
-    walker += step;
+    walker += sin_size;
+    rtm->rtm_addrs = RTA_GATEWAY;
     rtm->rtm_flags |= RTF_GATEWAY;
   }
 
-  if ((rtm->rtm_flags & RTF_HOST) == 0) {
+  /**********************************************************************
+   *                         SET  NETMASK
+   **********************************************************************/
+
+  if (0 == (rtm->rtm_flags & RTF_HOST)) {
     olsr_prefix_to_netmask((union olsr_ip_addr *)&sin6.sin6_addr, rt->rt_dst.prefix_len);
     memcpy(walker, &sin6, sizeof(sin6));
-    walker += step;
+    walker += sin_size;
     rtm->rtm_addrs |= RTA_NETMASK;
   }
 
+  /**********************************************************************
+   *           WRITE CONFIGURATION MESSAGE TO THE ROUTING SOCKET
+   **********************************************************************/
+
   rtm->rtm_msglen = (unsigned short)(walker - buff);
+  len = write(olsr_cnf->rts, buff, rtm->rtm_msglen);
+  if (len < 0 && !(errno == EEXIST || errno == ESRCH)) {
+    fprintf(stderr, "cannot write to routing socket: %s\n", strerror(errno));
+  }
 
-  len = write(olsr_cnf->rts, buff, rtm->rtm_msglen);
-  if (len < 0 && !(errno == EEXIST || errno == ESRCH))
-    fprintf(stderr, "cannot write to routing socket: %s\n", strerror(errno));
-
-  /* If we get an EEXIST error while adding, delete and retry. */
+  /*
+   * If we get an EEXIST error while adding, delete and retry.
+   */
   if (len < 0 && errno == EEXIST && rtm->rtm_type == RTM_ADD) {
     struct rt_msghdr *drtm;
     unsigned char dbuff[512];
@@ -348,7 +349,6 @@
     drtm = (struct rt_msghdr *)dbuff;
     drtm->rtm_version = RTM_VERSION;
     drtm->rtm_type = RTM_DELETE;
-    drtm->rtm_addrs = RTA_DST;
     drtm->rtm_index = 0;
     drtm->rtm_flags = olsr_rt_flags(rt);
     drtm->rtm_seq = ++seq;
@@ -356,17 +356,19 @@
     walker = dbuff + sizeof(struct rt_msghdr);
     memcpy(&sin6.sin6_addr.s6_addr, &rt->rt_dst.prefix.v6, sizeof(struct in6_addr));
     memcpy(walker, &sin6, sizeof(sin6));
-    walker += step;
+    walker += sin_size;
+    drtm->rtm_addrs = RTA_DST;
     drtm->rtm_msglen = (unsigned short)(walker - dbuff);
     len = write(olsr_cnf->rts, dbuff, drtm->rtm_msglen);
-    if (len < 0)
+    if (len < 0) {
       fprintf(stderr, "cannot delete route: %s\n", strerror(errno));
+    }
     rtm->rtm_seq = ++seq;
     len = write(olsr_cnf->rts, buff, rtm->rtm_msglen);
-    if (len < 0)
+    if (len < 0) {
       fprintf(stderr, "still cannot add route: %s\n", strerror(errno));
+    }
   }
-
   return 0;
 }
 
diff -r feb3d7883ff0 -r d73e73400732 src/build_msg.c
--- a/src/build_msg.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/build_msg.c	Fri Mar 13 19:16:23 2009 +0100
@@ -64,7 +64,7 @@
 
 /* All these functions share this buffer */
 
-static olsr_u8_t msg_buffer[MAXMESSAGESIZE - OLSR_HEADERSIZE];
+static uint8_t msg_buffer[MAXMESSAGESIZE - OLSR_HEADERSIZE];
 
 static clock_t send_empty_tc;          /* TC empty message sending */
 
@@ -72,23 +72,23 @@
 
 /* IPv4 */
 
-static olsr_bool serialize_hello4(struct hello_message *, struct interface *);
+static bool serialize_hello4(struct hello_message *, struct interface *);
 
-static olsr_bool serialize_tc4(struct tc_message *, struct interface *);
+static bool serialize_tc4(struct tc_message *, struct interface *);
 
-static olsr_bool serialize_mid4(struct interface *);
+static bool serialize_mid4(struct interface *);
 
-static olsr_bool serialize_hna4(struct interface *);
+static bool serialize_hna4(struct interface *);
 
 /* IPv6 */
 
-static olsr_bool serialize_hello6(struct hello_message *, struct interface *);
+static bool serialize_hello6(struct hello_message *, struct interface *);
 
-static olsr_bool serialize_tc6(struct tc_message *, struct interface *);
+static bool serialize_tc6(struct tc_message *, struct interface *);
 
-static olsr_bool serialize_mid6(struct interface *);
+static bool serialize_mid6(struct interface *);
 
-static olsr_bool serialize_hna6(struct interface *);
+static bool serialize_hna6(struct interface *);
 
 /**
  * Set the timer that controls the generation of
@@ -125,7 +125,7 @@
  *@return nada
  */
 
-olsr_bool
+bool
 queue_hello(struct hello_message * message, struct interface * ifp)
 {
 #ifdef DEBUG
@@ -138,7 +138,7 @@
   case (AF_INET6):
     return serialize_hello6(message, ifp);
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /*
@@ -154,7 +154,7 @@
  *@return nada
  */
 
-olsr_bool
+bool
 queue_tc(struct tc_message * message, struct interface * ifp)
 {
 #ifdef DEBUG
@@ -167,7 +167,7 @@
   case (AF_INET6):
     return serialize_tc6(message, ifp);
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -178,7 +178,7 @@
  *@return 1 on success
  */
 
-olsr_bool
+bool
 queue_mid(struct interface * ifp)
 {
 #ifdef DEBUG
@@ -191,7 +191,7 @@
   case (AF_INET6):
     return serialize_mid6(ifp);
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -201,7 +201,7 @@
  *@param ifp the interface to send on
  *@return nada
  */
-olsr_bool
+bool
 queue_hna(struct interface * ifp)
 {
 #ifdef DEBUG
@@ -214,7 +214,7 @@
   case (AF_INET6):
     return serialize_hna6(ifp);
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /*
@@ -241,20 +241,20 @@
  *@return nada
  */
 
-static olsr_bool
+static bool
 serialize_hello4(struct hello_message *message, struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   struct hello_neighbor *nb;
   union olsr_message *m;
   struct hellomsg *h;
   struct hellinfo *hinfo;
   union olsr_ip_addr *haddr;
   int i, j;
-  olsr_bool first_entry;
+  bool first_entry;
 
   if ((!message) || (!ifp) || (olsr_cnf->ip_version != AF_INET))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -287,7 +287,7 @@
   h->willingness = message->willingness;
   h->htime = reltime_to_me(ifp->hello_etime);
 
-  memset(&h->reserved, 0, sizeof(olsr_u16_t));
+  memset(&h->reserved, 0, sizeof(uint16_t));
 
   /*
    *Loops trough all possible neighbor statuses
@@ -307,7 +307,7 @@
       if (j == HIDE_LINK)
         continue;
 
-      first_entry = OLSR_TRUE;
+      first_entry = true;
 
       /* Looping trough neighbors */
       for (nb = message->neighbors; nb != NULL; nb = nb->next) {
@@ -350,7 +350,7 @@
             hinfo = h->hell_info;
             haddr = (union olsr_ip_addr *)hinfo->neigh_addr;
             /* Make sure typeheader is added */
-            first_entry = OLSR_TRUE;
+            first_entry = true;
           }
 
           net_output(ifp);
@@ -362,7 +362,7 @@
         }
 
         if (first_entry) {
-          memset(&hinfo->reserved, 0, sizeof(olsr_u8_t));
+          memset(&hinfo->reserved, 0, sizeof(uint8_t));
           /* Set link and status for this group of neighbors (this is the first) */
           hinfo->link_code = CREATE_LINK_CODE(i, j);
           curr_size += 4;       /* HELLO type section header */
@@ -374,7 +374,7 @@
         haddr = (union olsr_ip_addr *)&haddr->v6.s6_addr[4];
         curr_size += olsr_cnf->ipsize;  /* IP address added */
 
-        first_entry = OLSR_FALSE;
+        first_entry = false;
       }
 
       if (!first_entry) {
@@ -391,7 +391,7 @@
   net_outbuffer_push(ifp, msg_buffer, curr_size);
 
   /* HELLO will always be generated */
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -404,20 +404,20 @@
  *@return nada
  */
 
-static olsr_bool
+static bool
 serialize_hello6(struct hello_message *message, struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   struct hello_neighbor *nb;
   union olsr_message *m;
   struct hellomsg6 *h6;
   struct hellinfo6 *hinfo6;
   union olsr_ip_addr *haddr;
   int i, j;
-  olsr_bool first_entry;
+  bool first_entry;
 
   if ((!message) || (!ifp) || (olsr_cnf->ip_version != AF_INET6))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
   m = (union olsr_message *)msg_buffer;
@@ -447,7 +447,7 @@
   /* Fill packet header */
   h6->willingness = message->willingness;
   h6->htime = reltime_to_me(ifp->hello_etime);
-  memset(&h6->reserved, 0, sizeof(olsr_u16_t));
+  memset(&h6->reserved, 0, sizeof(uint16_t));
 
   /*
    *Loops trough all possible neighbor statuses
@@ -459,7 +459,7 @@
 #ifdef DEBUG
       struct ipaddr_str buf;
 #endif
-      first_entry = OLSR_TRUE;
+      first_entry = true;
 
       /*
        *Looping trough neighbors
@@ -505,7 +505,7 @@
             hinfo6 = h6->hell_info;
             haddr = (union olsr_ip_addr *)hinfo6->neigh_addr;
             /* Make sure typeheader is added */
-            first_entry = OLSR_TRUE;
+            first_entry = true;
           }
           net_output(ifp);
           /* Reset size and pointers */
@@ -516,7 +516,7 @@
         }
 
         if (first_entry) {
-          memset(&hinfo6->reserved, 0, sizeof(olsr_u8_t));
+          memset(&hinfo6->reserved, 0, sizeof(uint8_t));
           /* Set link and status for this group of neighbors (this is the first) */
           hinfo6->link_code = CREATE_LINK_CODE(i, j);
           curr_size += 4;       /* HELLO type section header */
@@ -528,7 +528,7 @@
         haddr++;
         curr_size += olsr_cnf->ipsize;  /* IP address added */
 
-        first_entry = OLSR_FALSE;
+        first_entry = false;
       }                         /* looping trough neighbors */
 
       if (!first_entry) {
@@ -546,7 +546,7 @@
   net_outbuffer_push(ifp, msg_buffer, curr_size);
 
   /* HELLO is always buildt */
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -559,21 +559,21 @@
  *@return nada
  */
 
-static olsr_bool
+static bool
 serialize_tc4(struct tc_message *message, struct interface *ifp)
 {
 #ifdef DEBUG
   struct ipaddr_str buf;
 #endif
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   struct tc_mpr_addr *mprs;
   union olsr_message *m;
   struct olsr_tcmsg *tc;
   struct neigh_info *mprsaddr;
-  olsr_bool found = OLSR_FALSE, partial_sent = OLSR_FALSE;
+  bool found = false, partial_sent = false;
 
   if ((!message) || (!ifp) || (olsr_cnf->ip_version != AF_INET))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -621,8 +621,8 @@
         /* Reset stuff */
         mprsaddr = tc->neigh;
         curr_size = OLSR_TC_IPV4_HDRSIZE;
-        found = OLSR_FALSE;
-        partial_sent = OLSR_TRUE;
+        found = false;
+        partial_sent = true;
       }
 
       net_output(ifp);
@@ -630,7 +630,7 @@
       check_buffspace(curr_size + olsr_cnf->ipsize, remainsize, "TC2");
 
     }
-    found = OLSR_TRUE;
+    found = true;
 #ifdef DEBUG
     OLSR_PRINTF(BMSG_DBGLVL, "\t%s\n", olsr_ip_to_string(&buf, &mprs->address));
 #endif
@@ -657,7 +657,7 @@
 
       net_outbuffer_push(ifp, msg_buffer, curr_size);
 
-      found = OLSR_TRUE;
+      found = true;
     }
   }
 
@@ -674,21 +674,21 @@
  *@return nada
  */
 
-static olsr_bool
+static bool
 serialize_tc6(struct tc_message *message, struct interface *ifp)
 {
 #ifdef DEBUG
   struct ipaddr_str buf;
 #endif
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   struct tc_mpr_addr *mprs;
   union olsr_message *m;
   struct olsr_tcmsg6 *tc6;
   struct neigh_info6 *mprsaddr6;
-  olsr_bool found = OLSR_FALSE, partial_sent = OLSR_FALSE;
+  bool found = false, partial_sent = false;
 
   if ((!message) || (!ifp) || (olsr_cnf->ip_version != AF_INET6))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -733,15 +733,15 @@
         net_outbuffer_push(ifp, msg_buffer, curr_size);
         mprsaddr6 = tc6->neigh;
         curr_size = OLSR_TC_IPV6_HDRSIZE;
-        found = OLSR_FALSE;
-        partial_sent = OLSR_TRUE;
+        found = false;
+        partial_sent = true;
       }
       net_output(ifp);
       remainsize = net_outbuffer_bytes_left(ifp);
       check_buffspace(curr_size + olsr_cnf->ipsize, remainsize, "TC2");
 
     }
-    found = OLSR_TRUE;
+    found = true;
 #ifdef DEBUG
     OLSR_PRINTF(BMSG_DBGLVL, "\t%s\n", olsr_ip_to_string(&buf, &mprs->address));
 #endif
@@ -766,7 +766,7 @@
 
       net_outbuffer_push(ifp, msg_buffer, curr_size);
 
-      found = OLSR_TRUE;
+      found = true;
     }
   }
 
@@ -781,17 +781,17 @@
  *@return 1 on success
  */
 
-static olsr_bool
+static bool
 serialize_mid4(struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   /* preserve existing data in output buffer */
   union olsr_message *m;
   struct midaddr *addrs;
   struct interface *ifs;
 
   if ((olsr_cnf->ip_version != AF_INET) || (!ifp) || (ifnet == NULL || ifnet->int_next == NULL))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -858,7 +858,7 @@
   if (curr_size > OLSR_MID_IPV4_HDRSIZE)
     net_outbuffer_push(ifp, msg_buffer, curr_size);
 
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -869,10 +869,10 @@
  *@return 1 on success
  */
 
-static olsr_bool
+static bool
 serialize_mid6(struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   /* preserve existing data in output buffer */
   union olsr_message *m;
   struct midaddr6 *addrs6;
@@ -881,7 +881,7 @@
   //printf("\t\tGenerating mid on %s\n", ifn->int_name);
 
   if ((olsr_cnf->ip_version != AF_INET6) || (!ifp) || (ifnet == NULL || ifnet->int_next == NULL))
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -947,7 +947,7 @@
   if (curr_size > OLSR_MID_IPV6_HDRSIZE)
     net_outbuffer_push(ifp, msg_buffer, curr_size);
 
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -956,10 +956,10 @@
  *@param ifp the interface to send on
  *@return nada
  */
-static olsr_bool
+static bool
 serialize_hna4(struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   /* preserve existing data in output buffer */
   union olsr_message *m;
   struct hnapair *pair;
@@ -967,14 +967,14 @@
 
   /* No hna nets */
   if (ifp == NULL) {
-    return OLSR_FALSE;
+    return false;
   }
   if (olsr_cnf->ip_version != AF_INET) {
-    return OLSR_FALSE;
+    return false;
   }
   h = olsr_cnf->hna_entries;
   if (h == NULL) {
-    return OLSR_FALSE;
+    return false;
   }
 
   remainsize = net_outbuffer_bytes_left(ifp);
@@ -1033,7 +1033,7 @@
   net_outbuffer_push(ifp, msg_buffer, curr_size);
 
   //printf("Sending HNA (%d bytes)...\n", outputsize);
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -1042,10 +1042,10 @@
  *@param ifp the interface to send on
  *@return nada
  */
-static olsr_bool
+static bool
 serialize_hna6(struct interface *ifp)
 {
-  olsr_u16_t remainsize, curr_size;
+  uint16_t remainsize, curr_size;
   /* preserve existing data in output buffer */
   union olsr_message *m;
   struct hnapair6 *pair6;
@@ -1054,7 +1054,7 @@
 
   /* No hna nets */
   if ((olsr_cnf->ip_version != AF_INET6) || (!ifp) || h == NULL)
-    return OLSR_FALSE;
+    return false;
 
   remainsize = net_outbuffer_bytes_left(ifp);
 
@@ -1113,7 +1113,7 @@
 #if 0
   printf("Sending HNA (%d bytes)...\n", outputsize);
 #endif
-  return OLSR_FALSE;
+  return false;
 
 }
 
diff -r feb3d7883ff0 -r d73e73400732 src/build_msg.h
--- a/src/build_msg.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/build_msg.h	Fri Mar 13 19:16:23 2009 +0100
@@ -50,13 +50,13 @@
 
 clock_t get_empty_tc_timer(void);
 
-olsr_bool queue_hello(struct hello_message *, struct interface *);
+bool queue_hello(struct hello_message *, struct interface *);
 
-olsr_bool queue_tc(struct tc_message *, struct interface *);
+bool queue_tc(struct tc_message *, struct interface *);
 
-olsr_bool queue_mid(struct interface *);
+bool queue_mid(struct interface *);
 
-olsr_bool queue_hna(struct interface *);
+bool queue_hna(struct interface *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/cfgfile_gen.c
--- a/src/cfgparser/cfgfile_gen.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/cfgfile_gen.c	Fri Mar 13 19:16:23 2009 +0100
@@ -344,7 +344,7 @@
     } while (0)
 
 int
-olsrd_write_cnf_buf(struct olsrd_config *cnf, char *buf, olsr_u32_t bufsize)
+olsrd_write_cnf_buf(struct olsrd_config *cnf, char *buf, uint32_t bufsize)
 {
   struct ip_prefix_list *h = cnf->hna_entries;
   struct olsr_if *in = cnf->interfaces;
@@ -496,7 +496,7 @@
   WRITE_TO_BUF("# can shar the same config block. Just list the\n# interfaces(e.g. Interface \"eth0\" \"eth2\"\n\n");
   /* Interfaces */
   if (in) {
-    olsr_bool first = OLSR_TRUE;
+    bool first = true;
     while (in) {
       WRITE_TO_BUF("Interface \"%s\" {\n", in->name);
 
@@ -609,7 +609,7 @@
 
       WRITE_TO_BUF("}\n\n");
       in = in->next;
-      first = OLSR_FALSE;
+      first = false;
     }
 
   }
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/local.mk
--- a/src/cfgparser/local.mk	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/local.mk	Fri Mar 13 19:16:23 2009 +0100
@@ -61,7 +61,7 @@
 $(C)oscan.o: $(C)oparse.c
 $(C)oscan.o: CFLAGS := $(filter-out -Wunreachable-code -Wsign-compare,$(CFLAGS)) -Wno-sign-compare
 # we need potentially another -I directory
-$(C)oscan.o: CPPFLAGS += $(if $(CFGDIR),-I$(CFGDIR))
+$(C)oscan.o: CPPFLAGS += $(if $(CFGDIR),-I$(CFGDIR)) -DYY_NO_INPUT
 
 $(C)oparse.c: $(C)oparse.y $(C)olsrd_conf.h $(C)Makefile
 	$(BISON) -d -o "$@-tmp" "$<"
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/olsrd_conf.c
--- a/src/cfgparser/olsrd_conf.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/olsrd_conf.c	Fri Mar 13 19:16:23 2009 +0100
@@ -150,9 +150,9 @@
 
   for (in = olsr_cnf->interfaces; in != NULL; in = in->next) {
     /* set various stuff */
-    in->configured = OLSR_FALSE;
+    in->configured = false;
     in->interf = NULL;
-    in->host_emul = OLSR_FALSE;
+    in->host_emul = false;
   }
   return olsr_cnf;
 }
@@ -182,13 +182,13 @@
     return -1;
   }
 
-  if (cnf->willingness_auto == OLSR_FALSE && (cnf->willingness > MAX_WILLINGNESS)) {
+  if (cnf->willingness_auto == false && (cnf->willingness > MAX_WILLINGNESS)) {
     fprintf(stderr, "Willingness %d is not allowed\n", cnf->willingness);
     return -1;
   }
 
   /* Hysteresis */
-  if (cnf->use_hysteresis == OLSR_TRUE) {
+  if (cnf->use_hysteresis == true) {
     if (cnf->hysteresis_param.scaling < MIN_HYST_PARAM || cnf->hysteresis_param.scaling > MAX_HYST_PARAM) {
       fprintf(stderr, "Hyst scaling %0.2f is not allowed\n", cnf->hysteresis_param.scaling);
       return -1;
@@ -246,7 +246,7 @@
   }
 
   /* Link Q and hysteresis cannot be activated at the same time */
-  if (cnf->use_hysteresis == OLSR_TRUE && cnf->lq_level) {
+  if (cnf->use_hysteresis == true && cnf->lq_level) {
     fprintf(stderr, "Hysteresis and LinkQuality cannot both be active! Deactivate one of them.\n");
     return -1;
   }
@@ -388,8 +388,8 @@
   memset(cnf, 0, sizeof(*cnf));
 
   cnf->debug_level = DEF_DEBUGLVL;
-  cnf->no_fork = OLSR_FALSE;
-  cnf->host_emul = OLSR_FALSE;
+  cnf->no_fork = false;
+  cnf->host_emul = false;
   cnf->ip_version = AF_INET;
   cnf->ipsize = sizeof(struct in_addr);
   cnf->maxplen = 32;
@@ -420,7 +420,7 @@
   cnf->lq_nat_thresh = DEF_LQ_NAT_THRESH;
   cnf->clear_screen = DEF_CLEAR_SCREEN;
 
-  cnf->del_gws = OLSR_FALSE;
+  cnf->del_gws = false;
   cnf->will_int = 10 * HELLO_INTERVAL;
   cnf->max_jitter = 0.0;
   cnf->exit_value = EXIT_SUCCESS;
@@ -458,7 +458,7 @@
 
   io->lq_mult = NULL;
 
-  io->weight.fixed = OLSR_FALSE;
+  io->weight.fixed = false;
   io->weight.value = 0;
 
   io->ipv6_addrtype = 0;        /* global */
@@ -471,7 +471,7 @@
   io->mid_params.validity_time = MID_HOLD_TIME;
   io->hna_params.emission_interval = HNA_INTERVAL;
   io->hna_params.validity_time = HNA_HOLD_TIME;
-  io->autodetect_chg = OLSR_TRUE;
+  io->autodetect_chg = true;
 
   return io;
 
@@ -660,7 +660,7 @@
 #endif
 
 void
-ip_prefix_list_add(struct ip_prefix_list **list, const union olsr_ip_addr *net, olsr_u8_t prefix_len)
+ip_prefix_list_add(struct ip_prefix_list **list, const union olsr_ip_addr *net, uint8_t prefix_len)
 {
   struct ip_prefix_list *new_entry = malloc(sizeof(*new_entry));
 
@@ -673,7 +673,7 @@
 }
 
 int
-ip_prefix_list_remove(struct ip_prefix_list **list, const union olsr_ip_addr *net, olsr_u8_t prefix_len)
+ip_prefix_list_remove(struct ip_prefix_list **list, const union olsr_ip_addr *net, uint8_t prefix_len)
 {
   struct ip_prefix_list *h = *list, *prev = NULL;
 
@@ -695,7 +695,7 @@
 }
 
 struct ip_prefix_list *
-ip_prefix_list_find(struct ip_prefix_list *list, const union olsr_ip_addr *net, olsr_u8_t prefix_len)
+ip_prefix_list_find(struct ip_prefix_list *list, const union olsr_ip_addr *net, uint8_t prefix_len)
 {
   struct ip_prefix_list *h;
   for (h = list; h != NULL; h = h->next) {
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/olsrd_conf.h
--- a/src/cfgparser/olsrd_conf.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/olsrd_conf.h	Fri Mar 13 19:16:23 2009 +0100
@@ -50,9 +50,9 @@
 extern int current_line;
 
 struct conf_token {
-  olsr_u32_t integer;
+  uint32_t integer;
   float floating;
-  olsr_bool boolean;
+  bool boolean;
   char *string;
 };
 
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/oparse.y
--- a/src/cfgparser/oparse.y	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/oparse.y	Fri Mar 13 19:16:23 2009 +0100
@@ -104,7 +104,7 @@
     }
 
     mult->addr = addr;
-    mult->value = (olsr_u32_t)(mult_arg->floating * LINK_LOSS_MULTIPLIER);
+    mult->value = (uint32_t)(mult_arg->floating * LINK_LOSS_MULTIPLIER);
 
     mult->next = walker->cnf->lq_mult;
     walker->cnf->lq_mult = mult;
@@ -415,7 +415,7 @@
 
   while (ifcnt) {
     ifs->cnf->weight.value = $2->integer;
-    ifs->cnf->weight.fixed = OLSR_TRUE;
+    ifs->cnf->weight.fixed = true;
 
     ifs = ifs->next;
     ifcnt--;
@@ -892,7 +892,7 @@
 awillingness: TOK_WILLINGNESS TOK_INTEGER
 {
   PARSER_DEBUG_PRINTF("Willingness: %d\n", $2->integer);
-  olsr_cnf->willingness_auto = OLSR_FALSE;
+  olsr_cnf->willingness_auto = false;
   olsr_cnf->willingness = $2->integer;
   free($2);
 }
diff -r feb3d7883ff0 -r d73e73400732 src/cfgparser/oscan.lex
--- a/src/cfgparser/oscan.lex	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/cfgparser/oscan.lex	Fri Mar 13 19:16:23 2009 +0100
@@ -73,7 +73,7 @@
 static struct conf_token *get_string_token(const char * const s, const size_t n);
 static struct conf_token *get_integer_token(const char * const s);
 static struct conf_token *get_floating_token(const char * const s);
-static struct conf_token *get_boolean_token(const olsr_bool b);
+static struct conf_token *get_boolean_token(const bool b);
 
 static struct conf_token *get_conf_token(void)
 {
@@ -119,7 +119,7 @@
     return rv;
 }
 
-static struct conf_token *get_boolean_token(const olsr_bool b)
+static struct conf_token *get_boolean_token(const bool b)
 {
     struct conf_token *rv = get_conf_token();
     if (rv != NULL) {
@@ -224,22 +224,22 @@
 
 
 "yes" {
-    yylval = get_boolean_token(OLSR_TRUE);
+    yylval = get_boolean_token(true);
     return TOK_BOOLEAN;
 }
 
 "no" {
-    yylval = get_boolean_token(OLSR_FALSE);
+    yylval = get_boolean_token(false);
     return TOK_BOOLEAN;
 }
 
 "site-local" {
-    yylval = get_boolean_token(OLSR_TRUE);
+    yylval = get_boolean_token(true);
     return TOK_IP6TYPE;
 }
 
 "global" {
-    yylval = get_boolean_token(OLSR_FALSE);
+    yylval = get_boolean_token(false);
     return TOK_IP6TYPE;
 }
 
diff -r feb3d7883ff0 -r d73e73400732 src/common/avl.h
--- a/src/common/avl.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/common/avl.h	Fri Mar 13 19:16:23 2009 +0100
@@ -136,7 +136,7 @@
 {\
   return( \
     ptr ? \
-      (structname *) (((olsr_u8_t *) ptr) - offsetof(structname, avlnodename)) : \
+      (structname *) (((uint8_t *) ptr) - offsetof(structname, avlnodename)) : \
       NULL); \
 }
 
diff -r feb3d7883ff0 -r d73e73400732 src/common/list.h
--- a/src/common/list.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/common/list.h	Fri Mar 13 19:16:23 2009 +0100
@@ -85,7 +85,7 @@
 {\
   return( \
     ptr ? \
-      (structname *) (((olsr_u8_t *) ptr) - offsetof(structname, listnodename)) : \
+      (structname *) (((uint8_t *) ptr) - offsetof(structname, listnodename)) : \
       NULL); \
 }
 
diff -r feb3d7883ff0 -r d73e73400732 src/defs.h
--- a/src/defs.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/defs.h	Fri Mar 13 19:16:23 2009 +0100
@@ -70,7 +70,7 @@
 #define UDP_IPV4_HDRSIZE        28
 #define UDP_IPV6_HDRSIZE        62
 
-#define MIN_PACKET_SIZE(ver)	((int)(sizeof(olsr_u8_t) * (((ver) == AF_INET) ? 4 : 7)))
+#define MIN_PACKET_SIZE(ver)	((int)(sizeof(uint8_t) * (((ver) == AF_INET) ? 4 : 7)))
 
 /* Debug helper macro */
 #ifdef DEBUG
@@ -177,8 +177,8 @@
 extern clock_t now_times;              /* current idea of times(2) reported uptime */
 
 #if defined WIN32
-extern olsr_bool olsr_win32_end_request;
-extern olsr_bool olsr_win32_end_flag;
+extern bool olsr_win32_end_request;
+extern bool olsr_win32_end_flag;
 #endif
 
 /*
@@ -188,7 +188,7 @@
  * the underlying kernel calls the smallest accountable time unit) are
  * inherently "unsigned" (and always incremented).
  */
-unsigned long olsr_times(void);
+clock_t olsr_times(void);
 
 /*
  *IPC functions
diff -r feb3d7883ff0 -r d73e73400732 src/duplicate_set.c
--- a/src/duplicate_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/duplicate_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -62,7 +62,7 @@
 }
 
 struct dup_entry *
-olsr_create_duplicate_entry(void *ip, olsr_u16_t seqnr)
+olsr_create_duplicate_entry(void *ip, uint16_t seqnr)
 {
   struct dup_entry *entry;
   entry = olsr_malloc(sizeof(struct dup_entry), "New duplicate entry");
@@ -98,7 +98,7 @@
   void *mainIp;
   clock_t valid_until;
   struct ipaddr_str buf;
-  olsr_u16_t seqnr;
+  uint16_t seqnr;
   void *ip;
 
   if (olsr_cnf->ip_version == AF_INET) {
@@ -124,7 +124,7 @@
       avl_insert(&duplicate_set, &entry->avl, 0);
       entry->valid_until = valid_until;
     }
-    return OLSR_FALSE;          // okay, we process this package
+    return false;               // okay, we process this package
   }
 
   diff = (int)seqnr - (int)(entry->seqnr);
@@ -146,32 +146,32 @@
       entry->too_low_counter = 0;
       entry->seqnr = seqnr;
       entry->array = 1;
-      return OLSR_FALSE;        /* start with a new sequence number, so NO duplicate */
+      return false;             /* start with a new sequence number, so NO duplicate */
     }
     OLSR_PRINTF(9, "blocked %x from %s\n", seqnr, olsr_ip_to_string(&buf, mainIp));
-    return OLSR_TRUE;           /* duplicate ! */
+    return true;                /* duplicate ! */
   }
 
   entry->too_low_counter = 0;
   if (diff <= 0) {
-    olsr_u32_t bitmask = 1 << ((olsr_u32_t) (-diff));
+    uint32_t bitmask = 1 << ((uint32_t) (-diff));
 
     if ((entry->array & bitmask) != 0) {
       OLSR_PRINTF(9, "blocked %x (diff=%d,mask=%08x) from %s\n", seqnr, diff, entry->array, olsr_ip_to_string(&buf, mainIp));
-      return OLSR_TRUE;         /* duplicate ! */
+      return true;              /* duplicate ! */
     }
     entry->array |= bitmask;
     OLSR_PRINTF(9, "processed %x from %s\n", seqnr, olsr_ip_to_string(&buf, mainIp));
-    return OLSR_FALSE;          /* no duplicate */
+    return false;               /* no duplicate */
   } else if (diff < 32) {
-    entry->array <<= (olsr_u32_t) diff;
+    entry->array <<= (uint32_t) diff;
   } else {
     entry->array = 0;
   }
   entry->array |= 1;
   entry->seqnr = seqnr;
   OLSR_PRINTF(9, "processed %x from %s\n", seqnr, olsr_ip_to_string(&buf, mainIp));
-  return OLSR_FALSE;            /* no duplicate */
+  return false;                 /* no duplicate */
 }
 
 void
diff -r feb3d7883ff0 -r d73e73400732 src/duplicate_set.h
--- a/src/duplicate_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/duplicate_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -54,16 +54,16 @@
 struct dup_entry {
   struct avl_node avl;
   union olsr_ip_addr ip;
-  olsr_u16_t seqnr;
-  olsr_u16_t too_low_counter;
-  olsr_u32_t array;
+  uint16_t seqnr;
+  uint16_t too_low_counter;
+  uint32_t array;
   clock_t valid_until;
 };
 
 AVLNODE2STRUCT(duptree2dupentry, struct dup_entry, avl);
 
 void olsr_init_duplicate_set(void);
-struct dup_entry *olsr_create_duplicate_entry(void *ip, olsr_u16_t seqnr);
+struct dup_entry *olsr_create_duplicate_entry(void *ip, uint16_t seqnr);
 int olsr_message_is_duplicate(union olsr_message *m);
 void olsr_print_duplicate_table(void);
 
diff -r feb3d7883ff0 -r d73e73400732 src/generate_msg.c
--- a/src/generate_msg.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/generate_msg.c	Fri Mar 13 19:16:23 2009 +0100
@@ -61,7 +61,7 @@
 static char pulsedata[] = { '\\', '|', '/', '-' };
 
 #define PULSE_MAX 4
-static olsr_u8_t pulse_state = 0;
+static uint8_t pulse_state = 0;
 
 void
 generate_hello(void *p)
diff -r feb3d7883ff0 -r d73e73400732 src/hashing.c
--- a/src/hashing.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hashing.c	Fri Mar 13 19:16:23 2009 +0100
@@ -64,14 +64,14 @@
   c -= a; c -= b; c ^= (b>>15); \
 }
 
-static inline olsr_u32_t
-jenkins_hash(const olsr_u8_t * k, olsr_u32_t length)
+static uint32_t
+jenkins_hash(const uint8_t * k, uint32_t length)
 {
   /* k: the key
    * length: length of the key
    * initval: the previous hash, or an arbitrary value
    */
-  olsr_u32_t a, b, c, len;
+  uint32_t a, b, c, len;
 
   /* Set up the internal state */
   len = length;
@@ -80,9 +80,9 @@
 
   /* handle most of the key */
   while (len >= 12) {
-    a += (k[0] + ((olsr_u32_t) k[1] << 8) + ((olsr_u32_t) k[2] << 16) + ((olsr_u32_t) k[3] << 24));
-    b += (k[4] + ((olsr_u32_t) k[5] << 8) + ((olsr_u32_t) k[6] << 16) + ((olsr_u32_t) k[7] << 24));
-    c += (k[8] + ((olsr_u32_t) k[9] << 8) + ((olsr_u32_t) k[10] << 16) + ((olsr_u32_t) k[11] << 24));
+    a += (k[0] + ((uint32_t) k[1] << 8) + ((uint32_t) k[2] << 16) + ((uint32_t) k[3] << 24));
+    b += (k[4] + ((uint32_t) k[5] << 8) + ((uint32_t) k[6] << 16) + ((uint32_t) k[7] << 24));
+    c += (k[8] + ((uint32_t) k[9] << 8) + ((uint32_t) k[10] << 16) + ((uint32_t) k[11] << 24));
 
     __jhash_mix(a, b, c);
 
@@ -93,26 +93,26 @@
   c += length;
   switch (len) {
   case 11:
-    c += ((olsr_u32_t) k[10] << 24);
+    c += ((uint32_t) k[10] << 24);
   case 10:
-    c += ((olsr_u32_t) k[9] << 16);
+    c += ((uint32_t) k[9] << 16);
   case 9:
-    c += ((olsr_u32_t) k[8] << 8);
+    c += ((uint32_t) k[8] << 8);
     /* the first byte of c is reserved for the length */
   case 8:
-    b += ((olsr_u32_t) k[7] << 24);
+    b += ((uint32_t) k[7] << 24);
   case 7:
-    b += ((olsr_u32_t) k[6] << 16);
+    b += ((uint32_t) k[6] << 16);
   case 6:
-    b += ((olsr_u32_t) k[5] << 8);
+    b += ((uint32_t) k[5] << 8);
   case 5:
     b += k[4];
   case 4:
-    a += ((olsr_u32_t) k[3] << 24);
+    a += ((uint32_t) k[3] << 24);
   case 3:
-    a += ((olsr_u32_t) k[2] << 16);
+    a += ((uint32_t) k[2] << 16);
   case 2:
-    a += ((olsr_u32_t) k[1] << 8);
+    a += ((uint32_t) k[1] << 8);
   case 1:
     a += k[0];
   }
@@ -126,17 +126,17 @@
  * @param address the address to hash
  * @return the hash(a value in the (0 to HASHMASK-1) range)
  */
-olsr_u32_t
+uint32_t
 olsr_ip_hashing(const union olsr_ip_addr * address)
 {
-  olsr_u32_t hash;
+  uint32_t hash;
 
   switch (olsr_cnf->ip_version) {
   case AF_INET:
-    hash = jenkins_hash((const olsr_u8_t *)&address->v4, sizeof(olsr_u32_t));
+    hash = jenkins_hash((const uint8_t *)&address->v4, sizeof(uint32_t));
     break;
   case AF_INET6:
-    hash = jenkins_hash((const olsr_u8_t *)&address->v6, sizeof(struct in6_addr));
+    hash = jenkins_hash((const uint8_t *)&address->v6, sizeof(struct in6_addr));
     break;
   default:
     hash = 0;
diff -r feb3d7883ff0 -r d73e73400732 src/hashing.h
--- a/src/hashing.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hashing.h	Fri Mar 13 19:16:23 2009 +0100
@@ -47,7 +47,7 @@
 
 #include "olsr_types.h"
 
-olsr_u32_t olsr_ip_hashing(const union olsr_ip_addr *);
+uint32_t olsr_ip_hashing(const union olsr_ip_addr *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/hna_set.c
--- a/src/hna_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hna_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -85,7 +85,7 @@
  * @return the localized entry or NULL of not found
  */
 struct hna_net *
-olsr_lookup_hna_net(const struct hna_net *nets, const union olsr_ip_addr *net, olsr_u8_t prefixlen)
+olsr_lookup_hna_net(const struct hna_net *nets, const union olsr_ip_addr *net, uint8_t prefixlen)
 {
   struct hna_net *tmp;
 
@@ -110,7 +110,7 @@
 olsr_lookup_hna_gw(const union olsr_ip_addr *gw)
 {
   struct hna_entry *tmp_hna;
-  olsr_u32_t hash = olsr_ip_hashing(gw);
+  uint32_t hash = olsr_ip_hashing(gw);
 
 #if 0
   OLSR_PRINTF(5, "HNA: lookup entry\n");
@@ -138,7 +138,7 @@
 olsr_add_hna_entry(const union olsr_ip_addr *addr)
 {
   struct hna_entry *new_entry;
-  olsr_u32_t hash;
+  uint32_t hash;
 
   new_entry = olsr_cookie_malloc(hna_entry_mem_cookie);
 
@@ -170,7 +170,7 @@
  * @return the newly created entry
  */
 struct hna_net *
-olsr_add_hna_net(struct hna_entry *hna_gw, const union olsr_ip_addr *net, olsr_u8_t prefixlen)
+olsr_add_hna_net(struct hna_entry *hna_gw, const union olsr_ip_addr *net, uint8_t prefixlen)
 {
   /* Add the net */
   struct hna_net *new_net = olsr_cookie_malloc(hna_net_mem_cookie);
@@ -242,7 +242,7 @@
  *@return nada
  */
 void
-olsr_update_hna_entry(const union olsr_ip_addr *gw, const union olsr_ip_addr *net, olsr_u8_t prefixlen, olsr_reltime vtime)
+olsr_update_hna_entry(const union olsr_ip_addr *gw, const union olsr_ip_addr *net, uint8_t prefixlen, olsr_reltime vtime)
 {
   struct hna_entry *gw_entry;
   struct hna_net *net_entry;
@@ -259,7 +259,7 @@
 
     /* Need to add the net */
     net_entry = olsr_add_hna_net(gw_entry, net, prefixlen);
-    changes_hna = OLSR_TRUE;
+    changes_hna = true;
   }
 
   /*
@@ -330,19 +330,19 @@
  *@return 1 on success
  */
 
-olsr_bool
+bool
 olsr_input_hna(union olsr_message *m, struct interface *in_if __attribute__ ((unused)), union olsr_ip_addr *from_addr)
 {
 
-  olsr_u8_t olsr_msgtype;
+  uint8_t olsr_msgtype;
   olsr_reltime vtime;
-  olsr_u16_t olsr_msgsize;
+  uint16_t olsr_msgsize;
   union olsr_ip_addr originator;
-  olsr_u8_t hop_count;
-  olsr_u16_t packet_seq_number;
+  uint8_t hop_count;
+  uint16_t packet_seq_number;
 
   int hnasize;
-  const olsr_u8_t *curr, *curr_end;
+  const uint8_t *curr, *curr_end;
 
 #ifdef DEBUG
   OLSR_PRINTF(5, "Processing HNA\n");
@@ -350,15 +350,15 @@
 
   /* Check if everyting is ok */
   if (!m) {
-    return OLSR_FALSE;
+    return false;
   }
-  curr = (const olsr_u8_t *)m;
+  curr = (const uint8_t *)m;
 
   /* olsr_msgtype */
   pkt_get_u8(&curr, &olsr_msgtype);
   if (olsr_msgtype != HNA_MESSAGE) {
     OLSR_PRINTF(0, "not a HNA message!\n");
-    return OLSR_FALSE;
+    return false;
   }
   /* Get vtime */
   pkt_get_reltime(&curr, &vtime);
@@ -371,13 +371,13 @@
     OLSR_PRINTF(0, "message size %d too small (at least %lu)!\n", olsr_msgsize,
                 (unsigned long)(olsr_cnf->ip_version ==
                                 AF_INET ? offsetof(struct olsrmsg, message) : offsetof(struct olsrmsg6, message)));
-    return OLSR_FALSE;
+    return false;
   }
   if ((hnasize % (2 * olsr_cnf->ipsize)) != 0) {
     OLSR_PRINTF(0, "Illegal message size %d!\n", olsr_msgsize);
-    return OLSR_FALSE;
+    return false;
   }
-  curr_end = (const olsr_u8_t *)m + olsr_msgsize;
+  curr_end = (const uint8_t *)m + olsr_msgsize;
 
   /* validate originator */
   pkt_get_ipaddress(&curr, &originator);
@@ -400,12 +400,12 @@
   if (check_neighbor_link(from_addr) != SYM_LINK) {
     struct ipaddr_str buf;
     OLSR_PRINTF(2, "Received HNA from NON SYM neighbor %s\n", olsr_ip_to_string(&buf, from_addr));
-    return OLSR_FALSE;
+    return false;
   }
 #if 1
   while (curr < curr_end) {
     union olsr_ip_addr net;
-    olsr_u8_t prefixlen;
+    uint8_t prefixlen;
     struct ip_prefix_list *entry;
 
     pkt_get_ipaddress(&curr, &net);
@@ -425,7 +425,7 @@
   }
 #endif
   /* Forward the message */
-  return OLSR_TRUE;
+  return true;
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/hna_set.h
--- a/src/hna_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hna_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -53,7 +53,7 @@
 
 struct hna_net {
   union olsr_ip_addr A_network_addr;
-  olsr_u8_t prefixlen;
+  uint8_t prefixlen;
   struct timer_entry *hna_net_timer;
   struct hna_entry *hna_gw;            /* backpointer to the owning HNA entry */
   struct hna_net *next;
@@ -82,19 +82,19 @@
 
 int olsr_init_hna_set(void);
 
-struct hna_net *olsr_lookup_hna_net(const struct hna_net *, const union olsr_ip_addr *, olsr_u8_t);
+struct hna_net *olsr_lookup_hna_net(const struct hna_net *, const union olsr_ip_addr *, uint8_t);
 
 struct hna_entry *olsr_lookup_hna_gw(const union olsr_ip_addr *);
 
 struct hna_entry *olsr_add_hna_entry(const union olsr_ip_addr *);
 
-struct hna_net *olsr_add_hna_net(struct hna_entry *, const union olsr_ip_addr *, olsr_u8_t);
+struct hna_net *olsr_add_hna_net(struct hna_entry *, const union olsr_ip_addr *, uint8_t);
 
-void olsr_update_hna_entry(const union olsr_ip_addr *, const union olsr_ip_addr *, olsr_u8_t, olsr_reltime);
+void olsr_update_hna_entry(const union olsr_ip_addr *, const union olsr_ip_addr *, uint8_t, olsr_reltime);
 
 void olsr_print_hna_set(void);
 
-olsr_bool olsr_input_hna(union olsr_message *, struct interface *, union olsr_ip_addr *);
+bool olsr_input_hna(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/hysteresis.c
--- a/src/hysteresis.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hysteresis.c	Fri Mar 13 19:16:23 2009 +0100
@@ -73,14 +73,14 @@
     if (entry->L_link_pending == 1) {
       struct ipaddr_str buf;
       OLSR_PRINTF(1, "HYST[%s] link set to NOT pending!\n", olsr_ip_to_string(&buf, &entry->neighbor_iface_addr));
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
     }
 
     /* Pending = false */
     entry->L_link_pending = 0;
 
     if (!TIMED_OUT(entry->L_LOST_LINK_time))
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
 
     /* time = now -1 */
     entry->L_LOST_LINK_time = now_times - 1;
@@ -92,14 +92,14 @@
     if (entry->L_link_pending == 0) {
       struct ipaddr_str buf;
       OLSR_PRINTF(1, "HYST[%s] link set to pending!\n", olsr_ip_to_string(&buf, &entry->neighbor_iface_addr));
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
     }
 
     /* Pending = true */
     entry->L_link_pending = 1;
 
     if (TIMED_OUT(entry->L_LOST_LINK_time))
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
 
     /* Timer = min (L_time, current time + NEIGHB_HOLD_TIME) */
     entry->L_LOST_LINK_time = MIN(GET_TIMESTAMP(NEIGHB_HOLD_TIME * MSEC_PER_SEC), entry->link_timer->timer_clock);
@@ -143,7 +143,7 @@
 }
 
 void
-update_hysteresis_incoming(union olsr_ip_addr *remote, struct interface *local, olsr_u16_t seqno)
+update_hysteresis_incoming(union olsr_ip_addr *remote, struct interface *local, uint16_t seqno)
 {
   struct link_entry *lnk = lookup_link_entry(remote, NULL, local);
 
@@ -177,7 +177,7 @@
       }
 
     lnk->olsr_seqno = seqno + 1;
-    lnk->olsr_seqno_valid = OLSR_TRUE;
+    lnk->olsr_seqno_valid = true;
 
     //printf("Updating seqno to: %d\n", lnk->olsr_seqno);
   }
diff -r feb3d7883ff0 -r d73e73400732 src/hysteresis.h
--- a/src/hysteresis.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/hysteresis.h	Fri Mar 13 19:16:23 2009 +0100
@@ -52,7 +52,7 @@
 
 void olsr_update_hysteresis_hello(struct link_entry *, olsr_reltime);
 
-void update_hysteresis_incoming(union olsr_ip_addr *, struct interface *, olsr_u16_t);
+void update_hysteresis_incoming(union olsr_ip_addr *, struct interface *, uint16_t);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/interfaces.c
--- a/src/interfaces.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/interfaces.c	Fri Mar 13 19:16:23 2009 +0100
@@ -268,7 +268,7 @@
   interf_n->interf = NULL;
   interf_n->configured = 0;
 
-  interf_n->host_emul = hemu ? OLSR_TRUE : OLSR_FALSE;
+  interf_n->host_emul = hemu ? true : false;
 
   strscpy(interf_n->name, name, name_size);
   interf_n->next = olsr_cnf->interfaces;
diff -r feb3d7883ff0 -r d73e73400732 src/interfaces.h
--- a/src/interfaces.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/interfaces.h	Fri Mar 13 19:16:23 2009 +0100
@@ -92,22 +92,22 @@
 #define WEIGHT_HIGHEST          8192    /* Really high          */
 
 struct if_gen_property {
-  olsr_u32_t owner_id;
+  uint32_t owner_id;
   void *data;
   struct if_gen_property *next;
 };
 
 struct vtimes {
-  olsr_u8_t hello;
-  olsr_u8_t tc;
-  olsr_u8_t mid;
-  olsr_u8_t hna;
+  uint8_t hello;
+  uint8_t tc;
+  uint8_t mid;
+  uint8_t hna;
 };
 
 /* Output buffer structure. This should actually be in net_olsr.h but we have circular references then.
  */
 struct olsr_netbuf {
-  olsr_u8_t *buff;                     /* Pointer to the allocated buffer */
+  uint8_t *buff;                       /* Pointer to the allocated buffer */
   int bufsize;                         /* Size of the buffer */
   int maxsize;                         /* Max bytes of payload that can be added to the buffer */
   int pending;                         /* How much data is currently pending in the buffer */
@@ -138,7 +138,7 @@
   int if_index;                        /* Kernels index of this interface */
   int is_wireless;                     /* wireless interface or not */
   char *int_name;                      /* from kernel if structure */
-  olsr_u16_t olsr_seqnum;              /* Olsr message seqno */
+  uint16_t olsr_seqnum;                /* Olsr message seqno */
 
   /* Periodic message generation timers */
   struct timer_entry *hello_gen_timer;
@@ -166,7 +166,7 @@
 
   int ttl_index;                       /* index in TTL array for fish-eye */
 
-  olsr_bool immediate_send_tc;         /* Hello's are sent immediately normally, this flag prefers to send TC's */
+  bool immediate_send_tc;              /* Hello's are sent immediately normally, this flag prefers to send TC's */
 
   struct interface *int_next;
 };
diff -r feb3d7883ff0 -r d73e73400732 src/ipc_frontend.c
--- a/src/ipc_frontend.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/ipc_frontend.c	Fri Mar 13 19:16:23 2009 +0100
@@ -67,7 +67,7 @@
 
 static int ipc_sock = -1;
 static int ipc_conn = -1;
-static int ipc_active = OLSR_FALSE;
+static int ipc_active = false;
 
 static int ipc_send_all_routes(int fd);
 
@@ -146,7 +146,7 @@
     OLSR_PRINTF(1, "Front end connected\n");
     addr = inet_ntoa(pin.sin_addr);
     if (ipc_check_allowed_ip((union olsr_ip_addr *)&pin.sin_addr.s_addr)) {
-      ipc_active = OLSR_TRUE;
+      ipc_active = true;
       ipc_send_net_info(ipc_conn);
       ipc_send_all_routes(ipc_conn);
       OLSR_PRINTF(1, "Connection from %s\n", addr);
@@ -159,23 +159,23 @@
 
 }
 
-olsr_bool
+bool
 ipc_check_allowed_ip(const union olsr_ip_addr *addr)
 {
   struct ip_prefix_list *ipcn;
 
   if (addr->v4.s_addr == ntohl(INADDR_LOOPBACK)) {
-    return OLSR_TRUE;
+    return true;
   }
 
   /* check nets */
   for (ipcn = olsr_cnf->ipc_nets; ipcn != NULL; ipcn = ipcn->next) {
     if (ip_in_net(addr, &ipcn->net)) {
-      return OLSR_TRUE;
+      return true;
     }
   }
 
-  return OLSR_FALSE;
+  return false;
 }
 
 #if 0
@@ -210,14 +210,14 @@
  *
  *@return true for not preventing forwarding
  */
-olsr_bool
+bool
 frontend_msgparser(union olsr_message * msg, struct interface * in_if __attribute__ ((unused)), union olsr_ip_addr * from_addr
                    __attribute__ ((unused)))
 {
   int size;
 
   if (!ipc_active)
-    return OLSR_TRUE;
+    return true;
 
   if (olsr_cnf->ip_version == AF_INET)
     size = ntohs(msg->v4.olsr_msgsize);
@@ -227,9 +227,9 @@
   if (send(ipc_conn, (void *)msg, size, MSG_NOSIGNAL) < 0) {
     OLSR_PRINTF(1, "(OUTPUT)IPC connection lost!\n");
     CLOSE(ipc_conn);
-    ipc_active = OLSR_FALSE;
+    ipc_active = false;
   }
-  return OLSR_TRUE;
+  return true;
 }
 
 /**
@@ -293,7 +293,7 @@
     OLSR_PRINTF(1, "(RT_ENTRY)IPC connection lost!\n");
     CLOSE(ipc_conn);
 
-    ipc_active = OLSR_FALSE;
+    ipc_active = false;
     return -1;
   }
 
@@ -319,7 +319,7 @@
     packet.target_addr = rt->rt_dst.prefix;
 
     packet.add = 1;
-    packet.metric = (olsr_u8_t) (rt->rt_best->rtp_metric.hops);
+    packet.metric = (uint8_t) (rt->rt_best->rtp_metric.hops);
 
     packet.gateway_addr = rt->rt_nexthop.gateway;
 
@@ -331,7 +331,7 @@
     if (send(fd, tmp, IPC_PACK_SIZE, MSG_NOSIGNAL) < 0) {
       OLSR_PRINTF(1, "(RT_ENTRY)IPC connection lost!\n");
       CLOSE(ipc_conn);
-      ipc_active = OLSR_FALSE;
+      ipc_active = false;
       return -1;
     }
   }
@@ -376,11 +376,11 @@
   /* Different values */
   /* Temporary fixes */
   /* XXX fix IPC intervals */
-  net_msg->hello_int = 0;       //htons((olsr_u16_t)hello_int);
-  net_msg->hello_lan_int = 0;   //htons((olsr_u16_t)hello_int_nw);
-  net_msg->tc_int = 0;          //htons((olsr_u16_t)tc_int);
-  net_msg->neigh_hold = 0;      //htons((olsr_u16_t)neighbor_hold_time);
-  net_msg->topology_hold = 0;   //htons((olsr_u16_t)topology_hold_time);
+  net_msg->hello_int = 0;       //htons((uint16_t)hello_int);
+  net_msg->hello_lan_int = 0;   //htons((uint16_t)hello_int_nw);
+  net_msg->tc_int = 0;          //htons((uint16_t)tc_int);
+  net_msg->neigh_hold = 0;      //htons((uint16_t)neighbor_hold_time);
+  net_msg->topology_hold = 0;   //htons((uint16_t)topology_hold_time);
 
   net_msg->ipv6 = olsr_cnf->ip_version == AF_INET ? 0 : 1;
 
diff -r feb3d7883ff0 -r d73e73400732 src/ipc_frontend.h
--- a/src/ipc_frontend.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/ipc_frontend.h	Fri Mar 13 19:16:23 2009 +0100
@@ -70,35 +70,35 @@
  */
 
 struct ipcmsg {
-  olsr_u8_t msgtype;
-  olsr_u16_t size;
-  olsr_u8_t metric;
-  olsr_u8_t add;
+  uint8_t msgtype;
+  uint16_t size;
+  uint8_t metric;
+  uint8_t add;
   union olsr_ip_addr target_addr;
   union olsr_ip_addr gateway_addr;
   char device[4];
 };
 
 struct ipc_net_msg {
-  olsr_u8_t msgtype;
-  olsr_u16_t size;
-  olsr_u8_t mids;                      /* No. of extra interfaces */
-  olsr_u8_t hnas;                      /* No. of HNA nets */
-  olsr_u8_t unused1;
-  olsr_u16_t hello_int;
-  olsr_u16_t hello_lan_int;
-  olsr_u16_t tc_int;
-  olsr_u16_t neigh_hold;
-  olsr_u16_t topology_hold;
-  olsr_u8_t ipv6;
+  uint8_t msgtype;
+  uint16_t size;
+  uint8_t mids;                        /* No. of extra interfaces */
+  uint8_t hnas;                        /* No. of HNA nets */
+  uint8_t unused1;
+  uint16_t hello_int;
+  uint16_t hello_lan_int;
+  uint16_t tc_int;
+  uint16_t neigh_hold;
+  uint16_t topology_hold;
+  uint8_t ipv6;
   union olsr_ip_addr main_addr;
 };
 
-olsr_bool ipc_check_allowed_ip(const union olsr_ip_addr *);
+bool ipc_check_allowed_ip(const union olsr_ip_addr *);
 
 void ipc_accept(int);
 
-olsr_bool frontend_msgparser(union olsr_message *, struct interface *, union olsr_ip_addr *);
+bool frontend_msgparser(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 int ipc_route_send_rtentry(const union olsr_ip_addr *, const union olsr_ip_addr *, int, int, const char *);
 
diff -r feb3d7883ff0 -r d73e73400732 src/ipcalc.c
--- a/src/ipcalc.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/ipcalc.c	Fri Mar 13 19:16:23 2009 +0100
@@ -42,14 +42,14 @@
 #include "ipcalc.h"
 
 int
-prefix_to_netmask(olsr_u8_t * a, int len, olsr_u8_t prefixlen)
+prefix_to_netmask(uint8_t * a, int len, uint8_t prefixlen)
 {
 #if !defined(NODEBUG) && defined(DEBUG)
   struct ipaddr_str buf;
-  const olsr_u8_t *a_start = a;
+  const uint8_t *a_start = a;
 #endif
   int p;
-  const olsr_u8_t *a_end;
+  const uint8_t *a_end;
 
   a_end = a + len;
   for (p = prefixlen; a < a_end && p > 8; p -= 8) {
@@ -69,13 +69,13 @@
   return 1;
 }
 
-olsr_u8_t
-netmask_to_prefix(const olsr_u8_t * adr, int len)
+uint8_t
+netmask_to_prefix(const uint8_t * adr, int len)
 {
   struct ipaddr_str buf;
-  const olsr_u8_t *const a_end = adr + len;
-  olsr_u16_t prefix = 0;
-  const olsr_u8_t *a;
+  const uint8_t *const a_end = adr + len;
+  uint16_t prefix = 0;
+  const uint8_t *a;
   for (a = adr; a < a_end && *a == 0xff; a++) {
     prefix += 8;
   }
@@ -157,18 +157,18 @@
 {
   int rv;
   if (olsr_cnf->ip_version == AF_INET) {
-    olsr_u32_t netmask = prefix_to_netmask4(net->prefix_len);
+    uint32_t netmask = prefix_to_netmask4(net->prefix_len);
     rv = (ipaddr->v4.s_addr & netmask) == (net->prefix.v4.s_addr & netmask);
   } else {
     /* IPv6 */
-    olsr_u32_t netmask;
-    const olsr_u32_t *i = (const olsr_u32_t *)&ipaddr->v6;
-    const olsr_u32_t *n = (const olsr_u32_t *)&net->prefix.v6;
+    uint32_t netmask;
+    const uint32_t *i = (const uint32_t *)&ipaddr->v6;
+    const uint32_t *n = (const uint32_t *)&net->prefix.v6;
     unsigned int prefix_len;
     /* First we compare whole unsigned int's */
     for (prefix_len = net->prefix_len; prefix_len > 32; prefix_len -= 32) {
       if (*i != *n) {
-        return OLSR_FALSE;
+        return false;
       }
       i++;
       n++;
diff -r feb3d7883ff0 -r d73e73400732 src/ipcalc.h
--- a/src/ipcalc.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/ipcalc.h	Fri Mar 13 19:16:23 2009 +0100
@@ -101,31 +101,31 @@
 
 int ip_in_net(const union olsr_ip_addr *ipaddr, const struct olsr_ip_prefix *net);
 
-int prefix_to_netmask(olsr_u8_t *, int, olsr_u8_t);
+int prefix_to_netmask(uint8_t *, int, uint8_t);
 
 static INLINE int
-olsr_prefix_to_netmask(union olsr_ip_addr *adr, olsr_u8_t prefixlen)
+olsr_prefix_to_netmask(union olsr_ip_addr *adr, uint8_t prefixlen)
 {
   return prefix_to_netmask(adr->v6.s6_addr, olsr_cnf->ipsize, prefixlen);
 }
 
-olsr_u8_t netmask_to_prefix(const olsr_u8_t *, int);
+uint8_t netmask_to_prefix(const uint8_t *, int);
 
-static INLINE olsr_u8_t
+static INLINE uint8_t
 olsr_netmask_to_prefix(const union olsr_ip_addr *adr)
 {
   return netmask_to_prefix(adr->v6.s6_addr, olsr_cnf->ipsize);
 }
 
-static INLINE olsr_u8_t
-olsr_netmask4_to_prefix(const olsr_u32_t * a)
+static INLINE uint8_t
+olsr_netmask4_to_prefix(const uint32_t * a)
 {
-  return netmask_to_prefix((const olsr_u8_t *)a, sizeof(*a));
+  return netmask_to_prefix((const uint8_t *)a, sizeof(*a));
 }
-static INLINE olsr_u8_t
+static INLINE uint8_t
 olsr_netmask6_to_prefix(const struct in6_addr *a)
 {
-  return netmask_to_prefix((const olsr_u8_t *)a, sizeof(*a));
+  return netmask_to_prefix((const uint8_t *)a, sizeof(*a));
 }
 
 static INLINE const char *
@@ -158,8 +158,8 @@
 /* we need to handle one value specifically since shifting 32 bits of a 32 bit integer is the same as shifting 0 bits.
  * The result is in host-byte-order.
  */
-static INLINE olsr_u32_t
-prefix_to_netmask4(olsr_u8_t prefixlen)
+static INLINE uint32_t
+prefix_to_netmask4(uint8_t prefixlen)
 {
   return prefixlen == 0 ? 0 : (~0U << (32 - prefixlen));
 }
diff -r feb3d7883ff0 -r d73e73400732 src/link_set.c
--- a/src/link_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/link_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -59,10 +59,10 @@
 /* head node for all link sets */
 struct list_node link_entry_head;
 
-olsr_bool link_changes;                /* is set if changes occur in MPRS set */
+bool link_changes;                     /* is set if changes occur in MPRS set */
 
 void
-signal_link_changes(olsr_bool val)
+signal_link_changes(bool val)
 {                               /* XXX ugly */
   link_changes = val;
 }
@@ -284,7 +284,7 @@
   struct interface *inter;
   struct olsr_if *cfg_inter;
   struct olsr_lq_mult *mult;
-  olsr_u32_t val = 0;
+  uint32_t val = 0;
   union olsr_ip_addr null_addr;
 
   /* find the interface for the link */
@@ -327,6 +327,14 @@
 static void
 olsr_delete_link_entry(struct link_entry *link)
 {
+  struct tc_edge_entry *tc_edge;
+
+  /* delete tc edges we made for SPF */
+  tc_edge = olsr_lookup_tc_edge(tc_myself, &link->neighbor_iface_addr);
+  if (tc_edge != NULL) {
+    olsr_delete_tc_edge_entry(tc_edge);
+  }
+
 
   /* Delete neighbor entry */
   if (link->neighbor->linkcount == 1) {
@@ -350,9 +358,12 @@
   free(link->if_name);
   free(link);
 
-  changes_neighborhood = OLSR_TRUE;
+  changes_neighborhood = true;
 }
 
+/**
+ * Delete all link entries matching a given interface address.
+ */
 void
 olsr_delete_link_entry_by_ip(const union olsr_ip_addr *int_addr)
 {
@@ -365,7 +376,6 @@
   OLSR_FOR_ALL_LINK_ENTRIES(link) {
     if (ipequal(int_addr, &link->local_iface_addr)) {
       olsr_delete_link_entry(link);
-      break;
     }
   }
   OLSR_FOR_ALL_LINK_ENTRIES_END(link);
@@ -382,7 +392,7 @@
   link = (struct link_entry *)context;
 
   /* count the lost packet */
-  olsr_update_packet_loss_worker(link, OLSR_TRUE);
+  olsr_update_packet_loss_worker(link, true);
 
   /* next timeout in 1.0 x htime */
   olsr_change_timer(link->link_loss_timer, link->loss_helloint, OLSR_LINK_LOSS_JITTER, OLSR_TIMER_PERIODIC);
@@ -405,7 +415,7 @@
 
   link->prev_status = lookup_link_status(link);
   update_neighbor_status(link->neighbor, get_neighbor_status(&link->neighbor_iface_addr));
-  changes_neighborhood = OLSR_TRUE;
+  changes_neighborhood = true;
 }
 
 /**
@@ -456,6 +466,11 @@
 void
 olsr_set_link_timer(struct link_entry *link, unsigned int rel_timer)
 {
+  struct ipaddr_str buf;
+
+  fprintf(stderr, "reset link timer: %s = %u\n",
+    olsr_ip_to_string(&buf, &link->neighbor_iface_addr),
+    (unsigned int)(olsr_times() + rel_timer/1000));
   olsr_set_timer(&link->link_timer, rel_timer, OLSR_LINK_JITTER, OLSR_TIMER_ONESHOT, &olsr_expire_link_entry, link, 0);
 }
 
@@ -531,7 +546,7 @@
     olsr_update_hysteresis_hello(new_link, htime);
     new_link->last_htime = htime;
     new_link->olsr_seqno = 0;
-    new_link->olsr_seqno_valid = OLSR_FALSE;
+    new_link->olsr_seqno_valid = false;
   }
 
   new_link->L_link_quality = 0.0;
@@ -763,7 +778,7 @@
     struct lqtextbuffer lqbuffer1, lqbuffer2;
     OLSR_PRINTF(1, "%-*s  %5.3f  %-14s %s\n", addrsize, olsr_ip_to_string(&buf, &walker->neighbor_iface_addr),
                 walker->L_link_quality, get_link_entry_text(walker, '/', &lqbuffer1), get_linkcost_text(walker->linkcost,
-                                                                                                        OLSR_FALSE, &lqbuffer2));
+                                                                                                        false, &lqbuffer2));
   } OLSR_FOR_ALL_LINK_ENTRIES_END(walker);
 #endif
 }
@@ -781,7 +796,7 @@
 void
 olsr_update_packet_loss(struct link_entry *entry)
 {
-  olsr_update_packet_loss_worker(entry, OLSR_FALSE);
+  olsr_update_packet_loss_worker(entry, false);
 
   /* timeout for the first lost packet is 1.5 x htime */
   olsr_set_timer(&entry->link_loss_timer, entry->loss_helloint + entry->loss_helloint / 2, OLSR_LINK_LOSS_JITTER,
diff -r feb3d7883ff0 -r d73e73400732 src/link_set.h
--- a/src/link_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/link_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -65,7 +65,7 @@
   clock_t ASYM_time;
   olsr_reltime vtime;
   struct neighbor_entry *neighbor;
-  olsr_u8_t prev_status;
+  uint8_t prev_status;
 
   /*
    * Hysteresis
@@ -75,8 +75,8 @@
   clock_t L_LOST_LINK_time;
   struct timer_entry *link_hello_timer; /* When we should receive a new HELLO */
   olsr_reltime last_htime;
-  olsr_bool olsr_seqno_valid;
-  olsr_u16_t olsr_seqno;
+  bool olsr_seqno_valid;
+  uint16_t olsr_seqno;
 
   /*
    * packet loss
@@ -85,13 +85,13 @@
   struct timer_entry *link_loss_timer;
 
   /* user defined multiplies for link quality, multiplied with 65536 */
-  olsr_u32_t loss_link_multiplier;
+  uint32_t loss_link_multiplier;
 
   /* cost of this link */
   olsr_linkcost linkcost;
 
   struct list_node link_list;          /* double linked list of all link entries */
-  olsr_u32_t linkquality[0];
+  uint32_t linkquality[0];
 };
 
 /* inline to recast from link_list back to link_entry */
@@ -115,7 +115,7 @@
 
 /* Externals */
 extern struct list_node link_entry_head;
-extern olsr_bool link_changes;
+extern bool link_changes;
 
 /* Function prototypes */
 
@@ -123,8 +123,8 @@
 void olsr_init_link_set(void);
 void olsr_delete_link_entry_by_ip(const union olsr_ip_addr *);
 void olsr_expire_link_hello_timer(void *);
-void olsr_update_packet_loss_worker(struct link_entry *, olsr_bool);
-void signal_link_changes(olsr_bool);   /* XXX ugly */
+void olsr_update_packet_loss_worker(struct link_entry *, bool);
+void signal_link_changes(bool);        /* XXX ugly */
 
 struct link_entry *get_best_link_to_neighbor(const union olsr_ip_addr *);
 
diff -r feb3d7883ff0 -r d73e73400732 src/linux/kernel_routes.c
--- a/src/linux/kernel_routes.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/linux/kernel_routes.c	Fri Mar 13 19:16:23 2009 +0100
@@ -42,9 +42,18 @@
 
 #include "kernel_routes.h"
 #include "ipc_frontend.h"
+#include "log.h"
+
+/*flags for recursive route corrections (specified here as they are currently only used in linux specific kernel_routes.c)*/
+
+#define RT_ORIG_REQUEST 0
+#define RT_RETRY_AFTER_ADD_GATEWAY 1
+#define RT_RETRY_AFTER_DELETE_SIMILAR 2
+#define RT_DELETE_SIMILAR_ROUTE 3
+#define RT_AUTO_ADD_GATEWAY_ROUTE 4
+#define RT_DELETE_SIMILAR_AUTO_ROUTE 5
 
 #if !LINUX_POLICY_ROUTING
-#include "log.h"
 
 static int delete_all_inet_gws(void);
 
@@ -71,10 +80,18 @@
   memcpy(RTA_DATA(rta), data, len);
 }
 
+/* returns
+ * -1 on unrecoverable error (calling function will handle it)
+ * 0 on unexpected but recoverable behaviour like (no such process, file existsm, network unreachable)
+ *   but the implemented recovery methods only cure the symptoms, not the cause, which still wansn`t found/fixed
+ *   but ignoring this errors and just logging them into syslog without any recover mechanisms may cause significatn ressource usage and missing routes in kernel
+ *   to ensure that this problems are fixed at proper place in future, recovery process logs warnings into syslog!
+ * 1 on success */
 static int
-olsr_netlink_route(const struct rt_entry *rt, olsr_u8_t family, olsr_u8_t rttable, __u16 cmd)
+olsr_netlink_route_int(const struct rt_entry *rt, uint8_t family, uint8_t rttable, __u16 cmd, uint8_t flag)
 {
-  int ret = 0;
+  int ret = 1; //helper variable for rtnetlink_message processing
+  int rt_ret = -2;  //if no response from rtnetlink it must be considered as failed!!!
   struct olsr_rtreq req;
   struct iovec iov;
   struct sockaddr_nl nladdr;
@@ -87,9 +104,10 @@
     0,
     0
   };
-  olsr_u32_t metric =
-    FIBM_FLAT != olsr_cnf->fib_metric ? (RTM_NEWROUTE ==
-                                         cmd ? rt->rt_best->rtp_metric.hops : rt->rt_metric.hops) : RT_METRIC_DEFAULT;
+  uint32_t metric =
+    FIBM_FLAT != olsr_cnf->fib_metric ? 
+      ((RTM_NEWROUTE == cmd) ? rt->rt_best->rtp_metric.hops : rt->rt_metric.hops) 
+      : RT_METRIC_DEFAULT;
   const struct rt_nexthop *nexthop = (RTM_NEWROUTE == cmd) ? &rt->rt_best->rtp_nexthop : &rt->rt_nexthop;
 
   memset(&req, 0, sizeof(req));
@@ -98,28 +116,50 @@
   req.n.nlmsg_type = cmd;
   req.r.rtm_family = family;
   req.r.rtm_table = rttable;
-  req.r.rtm_protocol = RTPROT_BOOT;
-  req.r.rtm_scope = RT_SCOPE_LINK;
-  req.r.rtm_type = RTN_UNICAST;
   req.r.rtm_dst_len = rt->rt_dst.prefix_len;
+  req.r.rtm_type = RTN_UNICAST; /*different rtm_type will not conflict, but of course if there a blackhole routes they will do what they do,..*/
+  req.r.rtm_protocol = RTPROT_UNSPEC;//wildcard to delete routes of all protos if no simlar-delete correct proto will get set below
+  req.r.rtm_scope = RT_SCOPE_NOWHERE;//as wildcard for deletion
 
+  /*do not specify much if we wanna delete similar routes*/
+  /*this currently works for different interfaces, src-ips metrics, gateways, protos*/
+  if ((flag != RT_DELETE_SIMILAR_ROUTE) & (flag != RT_DELETE_SIMILAR_AUTO_ROUTE)) {
+    req.r.rtm_protocol = RTPROT_BOOT;
+    req.r.rtm_scope = RT_SCOPE_LINK;
+
+    /*metric*/
+    if (FIBM_APPROX != olsr_cnf->fib_metric || (RTM_NEWROUTE == cmd) ) {
+      olsr_netlink_addreq(&req, RTA_PRIORITY, &metric, sizeof(metric));
+    }
+
+    /*interface*/
+    olsr_netlink_addreq(&req, RTA_OIF, &nexthop->iif_index, sizeof(nexthop->iif_index));
+  }
+
+  //make sure that netmask = /32 as this is an autogenarated route
+  if (( flag == RT_AUTO_ADD_GATEWAY_ROUTE ) | (flag == RT_DELETE_SIMILAR_AUTO_ROUTE) ) req.r.rtm_dst_len = 32;
+
+  /* for ipv4 or ipv6 we add gateway if one is specified, 
+  * or leave gateway away if we want to delete similar routes aswell, 
+  * or even use the gateway as target if we add a autogenrated route (or do an delete_sim to make insertion of autogen route possible)*/
   if (AF_INET == family) {
-    if (rt->rt_dst.prefix.v4.s_addr != nexthop->gateway.v4.s_addr) {
+    if ( ( flag != RT_AUTO_ADD_GATEWAY_ROUTE ) & (flag != RT_DELETE_SIMILAR_ROUTE) & 
+         ( flag != RT_DELETE_SIMILAR_AUTO_ROUTE) & (rt->rt_dst.prefix.v4.s_addr != nexthop->gateway.v4.s_addr) ) {
       olsr_netlink_addreq(&req, RTA_GATEWAY, &nexthop->gateway.v4, sizeof(nexthop->gateway.v4));
       req.r.rtm_scope = RT_SCOPE_UNIVERSE;
     }
-    olsr_netlink_addreq(&req, RTA_DST, &rt->rt_dst.prefix.v4, sizeof(rt->rt_dst.prefix.v4));
+    olsr_netlink_addreq(&req, RTA_DST, ( (flag == RT_AUTO_ADD_GATEWAY_ROUTE) | (flag == RT_DELETE_SIMILAR_AUTO_ROUTE) ) ? 
+                                      &nexthop->gateway.v4 : &rt->rt_dst.prefix.v4, sizeof(rt->rt_dst.prefix.v4));
   } else {
-    if (0 != memcmp(&rt->rt_dst.prefix.v6, &nexthop->gateway.v6, sizeof(nexthop->gateway.v6))) {
+    if ( ( flag != RT_AUTO_ADD_GATEWAY_ROUTE ) & (flag != RT_DELETE_SIMILAR_ROUTE ) & 
+         ( flag != RT_DELETE_SIMILAR_AUTO_ROUTE) & (0 != memcmp(&rt->rt_dst.prefix.v6, &nexthop->gateway.v6, sizeof(nexthop->gateway.v6))) ) {
       olsr_netlink_addreq(&req, RTA_GATEWAY, &nexthop->gateway.v6, sizeof(nexthop->gateway.v6));
       req.r.rtm_scope = RT_SCOPE_UNIVERSE;
     }
-    olsr_netlink_addreq(&req, RTA_DST, &rt->rt_dst.prefix.v6, sizeof(rt->rt_dst.prefix.v6));
+    olsr_netlink_addreq(&req, RTA_DST, ( (flag == RT_AUTO_ADD_GATEWAY_ROUTE) | (flag == RT_DELETE_SIMILAR_AUTO_ROUTE) ) ? 
+                                      &nexthop->gateway.v6 : &rt->rt_dst.prefix.v6, sizeof(rt->rt_dst.prefix.v6));
   }
-  if (FIBM_APPROX != olsr_cnf->fib_metric || RTM_NEWROUTE == cmd) {
-    olsr_netlink_addreq(&req, RTA_PRIORITY, &metric, sizeof(metric));
-  }
-  olsr_netlink_addreq(&req, RTA_OIF, &nexthop->iif_index, sizeof(nexthop->iif_index));
+
   iov.iov_base = &req.n;
   iov.iov_len = req.n.nlmsg_len;
   memset(&nladdr, 0, sizeof(nladdr));
@@ -130,27 +170,128 @@
     if (0 < (ret = recvmsg(olsr_cnf->rtnl_s, &msg, 0))) {
       struct nlmsghdr *h = (struct nlmsghdr *)req.buf;
       while (NLMSG_OK(h, (unsigned int)ret)) {
-        if (NLMSG_DONE == h->nlmsg_type)
+        if (NLMSG_DONE == h->nlmsg_type) {
+          //seems to reached never
+          olsr_syslog(OLSR_LOG_INFO, "_received NLMSG_DONE");
           break;
+        }
         if (NLMSG_ERROR == h->nlmsg_type) {
           if (NLMSG_LENGTH(sizeof(struct nlmsgerr) <= h->nlmsg_len)) {
+            struct ipaddr_str ibuf;
+            struct ipaddr_str gbuf;
             struct nlmsgerr *l_err = (struct nlmsgerr *)NLMSG_DATA(h);
             errno = -l_err->error;
-            if (0 != errno)
-              ret = -1;
+	    if (0 != errno) {
+	      const char *const err_msg = strerror(errno);
+              struct ipaddr_str buf;
+              rt_ret = -1;
+              /*debug output for original and retry attempts*/
+              if ( flag <= RT_RETRY_AFTER_DELETE_SIMILAR ) {
+                if (rt->rt_dst.prefix.v4.s_addr!=nexthop->gateway.v4.s_addr)
+                  olsr_syslog(OLSR_LOG_ERR, "error %d %s %s route to %s/%d via %s dev %d", errno, err_msg, (cmd == RTM_NEWROUTE) ? "add" : "del",
+                             olsr_ip_to_string(&ibuf,&rt->rt_dst.prefix),
+                             req.r.rtm_dst_len,
+                             olsr_ip_to_string(&gbuf,&nexthop->gateway), nexthop->iif_index); 
+                else olsr_syslog(OLSR_LOG_ERR, "error %d %s %s route to %s/%d dev %d", errno, err_msg, (cmd == RTM_NEWROUTE) ? "add" : "del",
+                                olsr_ip_to_string(&ibuf,&rt->rt_dst.prefix),
+                                req.r.rtm_dst_len, nexthop->iif_index);
+              }
+	      //deug output for autogen routes
+              else if (flag == RT_AUTO_ADD_GATEWAY_ROUTE) olsr_syslog(OLSR_LOG_ERR, ". error %d %s auto-add route to %s dev %d", errno, err_msg,
+                               olsr_ip_to_string(&ibuf,&nexthop->gateway), nexthop->iif_index);
+              //debug output for auto-delete similar
+              else if (flag == RT_DELETE_SIMILAR_ROUTE) olsr_syslog(OLSR_LOG_ERR, ". error %d %s auto-delete route to %s", errno, err_msg,
+                                             olsr_ip_to_string(&ibuf,&rt->rt_dst.prefix));
+              //debug output for auto-delete similar
+              else if (flag == RT_DELETE_SIMILAR_AUTO_ROUTE) olsr_syslog(OLSR_LOG_ERR, ". . error %d %s auto-del-similar route to %s", errno, err_msg,
+                                                             olsr_ip_to_string(&ibuf,&rt->rt_dst.prefix));
+	      //should never happen
+	      else {
+                olsr_syslog(OLSR_LOG_ERR, "# invalid internal route delete/add flag (%d) used!", flag);
+              }
+            }
+            else {
+              //netlink acks rquests with an errno=0 NLMSG_ERROR response!
+              //olsr_syslog(OLSR_LOG_INFO, "# RTNETLINK ACK!");
+              rt_ret = 1;
+            }
+
+            //olsr_syslog(OLSR_LOG_ERR
+            /* resolve "File exist" (17) propblems (on orig and autogen routes)*/	
+	    if ((errno == 17) & ((flag == RT_ORIG_REQUEST) | (flag == RT_AUTO_ADD_GATEWAY_ROUTE)) & (cmd == RTM_NEWROUTE)) {
+              /*a simlar route going over another gateway may be present, which should be deleted*/
+              olsr_syslog(OLSR_LOG_ERR, ". auto-deleting similar routes to resolve '17 - File exists' while adding route!");
+              rt_ret = RT_DELETE_SIMILAR_ROUTE;/*processing will contiune after this loop is finished as otherwise the rtnetlink is still blocked*/
+            }
+            /* report success on "No such process" (3) */
+            else if ((errno == 3) & (cmd == RTM_DELROUTE) & (flag == RT_ORIG_REQUEST)) {
+              /*another similar (but different) route may be present, but as we don not have a better route, nothing to think about*/
+              olsr_syslog(OLSR_LOG_ERR, ". ignoring '3 - No such process' while deleting route!");
+              rt_ret = 0;
+            }
+            /* insert route to gateway on the fly if "Network unreachable" (128) 
+             * is issued by rtnetlink when adding route via gateway!
+             * do this only with flat metric, as using metric values inherited from 
+             * a target behind the gateway is really strange, and could lead to multiple routes!
+             * anyways if invalid gateways ips may happen we are f*cked up!!
+             * but if not, these on the fly generated routes are no problem*/
+            else if ((errno == 128) & (flag == RT_ORIG_REQUEST) & (FIBM_FLAT == olsr_cnf->fib_metric) & (cmd == RTM_NEWROUTE) & (rt->rt_dst.prefix.v4.s_addr!=nexthop->gateway.v4.s_addr)) {
+              olsr_syslog(OLSR_LOG_ERR, ". autogenerating route to handle '128 - Network unreachable' while adding route!");
+              rt_ret = RT_AUTO_ADD_GATEWAY_ROUTE;/*processing will contiune after this loop is finished as otherwise the rtnetlink is still blocked*/
+            }
           }
-          break;
+          // report invalid message size
+	  else olsr_syslog(OLSR_LOG_INFO,"_received invalid netlink message size %u != %u",sizeof(struct nlmsgerr), h->nlmsg_len);
+          //break;
         }
+        //log all other messages
+	else olsr_syslog(OLSR_LOG_INFO,"_received %u Byte rtnetlink response of type %u with seqnr %u and flags %u from %u (%u)",
+                         h->nlmsg_len, h->nlmsg_type, h->nlmsg_seq, h->nlmsg_flags, h->nlmsg_pid, NLMSG_ERROR);
         h = NLMSG_NEXT(h, ret);
       }
     }
-    if (0 <= ret && olsr_cnf->ipc_connections > 0) {
-      ipc_route_send_rtentry(&rt->rt_dst.prefix, &nexthop->gateway, metric, RTM_NEWROUTE == cmd,
-                             if_ifwithindex_name(nexthop->iif_index));
+  }
+  if ( rt_ret == RT_DELETE_SIMILAR_ROUTE ) {//delete all routes that may collide
+    /* recursive call to delete simlar routes, using flag 2 to invoke deletion of similar, not only exact matches*/
+    rt_ret = olsr_netlink_route_int(rt, family, rttable, RTM_DELROUTE, flag == RT_AUTO_ADD_GATEWAY_ROUTE ? RT_DELETE_SIMILAR_AUTO_ROUTE : RT_DELETE_SIMILAR_ROUTE);
+    /* retry insert original route, if deleting similar succeeded, using flag=1 to prevent recursions*/
+    if (rt_ret > 0) rt_ret = olsr_netlink_route_int(rt, family, rttable, RTM_NEWROUTE, RT_RETRY_AFTER_DELETE_SIMILAR);
+    else olsr_syslog(OLSR_LOG_ERR, ". failed on auto-deleting similar route conflicting with above route!");
+
+    /* set appropriate return code for original request , while returning simple -1/1 if called from within an AUTO_ADD_ROUTE*/
+    if (flag != RT_AUTO_ADD_GATEWAY_ROUTE) {
+      if (rt_ret > 0) rt_ret = 0;//0 means successful recovery
+      else rt_ret = -1;//unrecoverable error
     }
   }
-  return ret;
+  if ( rt_ret == RT_AUTO_ADD_GATEWAY_ROUTE ) {//autoadd route via gateway
+    /* recursive call with flag==2 to invoke gateway route*/
+    rt_ret = olsr_netlink_route_int(rt, family, rttable, RTM_NEWROUTE, RT_AUTO_ADD_GATEWAY_ROUTE);
+    /* retry insert original route, if above succeeded (really) using flag 1 to prevent recursions*/
+    if (rt_ret > 0) rt_ret = olsr_netlink_route_int(rt, family, rttable, RTM_NEWROUTE, RT_RETRY_AFTER_ADD_GATEWAY);
+    else olsr_syslog(OLSR_LOG_ERR, ". failed on inserting auto-generated route to gateway of above route!");
+
+    /* set appropriate return code for original request*/
+    if (rt_ret > 0) rt_ret = 0;//0 means successful recovery
+    else rt_ret = -1;//unrecoverable error
+  }
+  //send ipc update on success
+  if ((flag = RT_ORIG_REQUEST) & (0 <= rt_ret && olsr_cnf->ipc_connections > 0)) {
+    ipc_route_send_rtentry(&rt->rt_dst.prefix, &nexthop->gateway, metric, RTM_NEWROUTE == cmd,
+                             if_ifwithindex_name(nexthop->iif_index));
+  }
+  if ((rt_ret < 0 ) & (flag == RT_ORIG_REQUEST)) olsr_syslog(OLSR_LOG_INFO,"_returning %i", rt_ret);
+  if (rt_ret == -2) olsr_syslog(OLSR_LOG_ERR,"no rtnetlink response was received! (everything may happen now ...)");
+  return rt_ret;
 }
+
+/*external wrapper function for above patched function*/
+static int
+olsr_netlink_route(const struct rt_entry *rt, uint8_t family, uint8_t rttable, __u16 cmd)
+{
+  return olsr_netlink_route_int(rt, family, rttable, cmd, RT_ORIG_REQUEST);
+}
+
 #endif /* LINUX_POLICY_ROUTING */
 
 /**
@@ -200,7 +341,7 @@
   /* delete existing default route before ? */
   if ((olsr_cnf->del_gws) && (rt->rt_dst.prefix.v4.s_addr == INADDR_ANY) && (rt->rt_dst.prefix_len == INADDR_ANY)) {
     delete_all_inet_gws();
-    olsr_cnf->del_gws = OLSR_FALSE;
+    olsr_cnf->del_gws = false;
   }
 
   if ((rslt = ioctl(olsr_cnf->ioctl_s, SIOCADDRT, &kernel_route)) >= 0) {
diff -r feb3d7883ff0 -r d73e73400732 src/linux/net.c
--- a/src/linux/net.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/linux/net.c	Fri Mar 13 19:16:23 2009 +0100
@@ -753,12 +753,12 @@
   }
 }
 
-olsr_bool
+bool
 is_if_link_up(char *ifname)
 {
   if (check_wireless_interface(ifname)) {
     /* No link checking on wireless devices */
-    return OLSR_TRUE;
+    return true;
   } else {
     /* Mii wizardry */
     struct ifreq ifr;
diff -r feb3d7883ff0 -r d73e73400732 src/lq_mpr.c
--- a/src/lq_mpr.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_mpr.c	Fri Mar 13 19:16:23 2009 +0100
@@ -55,7 +55,7 @@
   int i, k;
   struct neighbor_entry *neigh;
   olsr_linkcost best, best_1hop;
-  olsr_bool mpr_changes = OLSR_FALSE;
+  bool mpr_changes = false;
 
   OLSR_FOR_ALL_NBR_ENTRIES(neigh) {
 
@@ -65,7 +65,7 @@
 
     /* Clear current MPR status. */
 
-    neigh->is_mpr = OLSR_FALSE;
+    neigh->is_mpr = false;
 
     /* In this pass we are only interested in WILL_ALWAYS neighbours */
 
@@ -73,10 +73,10 @@
       continue;
     }
 
-    neigh->is_mpr = OLSR_TRUE;
+    neigh->is_mpr = true;
 
     if (neigh->is_mpr != neigh->was_mpr) {
-      mpr_changes = OLSR_TRUE;
+      mpr_changes = true;
     }
 
   }
@@ -129,7 +129,7 @@
       /* mark all 1-hop neighbours as not selected */
 
       for (walker = neigh2->neighbor_2_nblist.next; walker != &neigh2->neighbor_2_nblist; walker = walker->next)
-        walker->neighbor->skip = OLSR_FALSE;
+        walker->neighbor->skip = false;
 
       for (k = 0; k < olsr_cnf->mpr_coverage; k++) {
         /* look for the best 1-hop neighbour that we haven't
@@ -148,11 +148,11 @@
          * Use it as MPR only when the 2-hop path through it is better than
          * any existing 1-hop path. */
         if ((neigh != NULL) && (best < best_1hop)) {
-          neigh->is_mpr = OLSR_TRUE;
-          neigh->skip = OLSR_TRUE;
+          neigh->is_mpr = true;
+          neigh->skip = true;
 
           if (neigh->is_mpr != neigh->was_mpr)
-            mpr_changes = OLSR_TRUE;
+            mpr_changes = true;
         }
 
         /* no neighbour found => the requested MPR coverage cannot
@@ -165,7 +165,7 @@
   }
 
   if (mpr_changes && olsr_cnf->tc_redundancy > 0)
-    signal_link_changes(OLSR_TRUE);
+    signal_link_changes(true);
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/lq_packet.c
--- a/src/lq_packet.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_packet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -59,7 +59,7 @@
 #include "net_olsr.h"
 #include "lq_plugin.h"
 
-olsr_bool lq_tc_pending = OLSR_FALSE;
+bool lq_tc_pending = false;
 
 static unsigned char msg_buffer[MAXMESSAGESIZE - OLSR_HEADERSIZE];
 
@@ -157,7 +157,7 @@
   // remember that we have generated an LQ TC message; this is
   // checked in net_output()
 
-  lq_tc_pending = OLSR_TRUE;
+  lq_tc_pending = true;
 
   // initialize the static fields
 
@@ -326,7 +326,7 @@
   struct lq_hello_info_header *info_head;
   struct lq_hello_neighbor *neigh;
   unsigned char *buff;
-  olsr_bool is_first;
+  bool is_first;
   int i;
 
   // leave space for the OLSR header
@@ -364,14 +364,14 @@
     for (i = 0; i <= MAX_NEIGH; i++) {
       unsigned int j;
       for (j = 0; j < sizeof(LINK_ORDER) / sizeof(LINK_ORDER[0]); j++) {
-        is_first = OLSR_TRUE;
+        is_first = true;
         for (neigh = lq_hello->neigh; neigh != NULL; neigh = neigh->next) {
           if (0 == i && 0 == j)
             expected_size += olsr_cnf->ipsize + 4;
           if (neigh->neigh_type == i && neigh->link_type == LINK_ORDER[j]) {
             if (is_first) {
               expected_size += sizeof(struct lq_hello_info_header);
-              is_first = OLSR_FALSE;
+              is_first = false;
             }
           }
         }
@@ -391,7 +391,7 @@
   for (i = 0; i <= MAX_NEIGH; i++) {
     unsigned int j;
     for (j = 0; j < sizeof(LINK_ORDER) / sizeof(LINK_ORDER[0]); j++) {
-      is_first = OLSR_TRUE;
+      is_first = true;
 
       // loop through neighbors
 
@@ -438,7 +438,7 @@
 
           // we need a new info header
 
-          is_first = OLSR_TRUE;
+          is_first = true;
         }
         // create a new info header
 
@@ -457,7 +457,7 @@
         // add the corresponding link quality
         size += olsr_serialize_hello_lq_pair(&buff[size], neigh);
 
-        is_first = OLSR_FALSE;
+        is_first = false;
       }
 
       // finalize the info header, if there are any neighbors with the
@@ -479,13 +479,13 @@
   net_outbuffer_push(outif, msg_buffer, size + off);
 }
 
-static olsr_u8_t
+static uint8_t
 calculate_border_flag(void *lower_border, void *higher_border)
 {
-  olsr_u8_t *lower = lower_border;
-  olsr_u8_t *higher = higher_border;
-  olsr_u8_t bitmask;
-  olsr_u8_t part, bitpos;
+  uint8_t *lower = lower_border;
+  uint8_t *higher = higher_border;
+  uint8_t bitmask;
+  uint8_t part, bitpos;
 
   for (part = 0; part < olsr_cnf->ipsize; part++) {
     if (lower[part] != higher[part]) {
@@ -517,7 +517,7 @@
   unsigned char *buff;
 
   union olsr_ip_addr *last_ip = NULL;
-  olsr_u8_t left_border_flag = 0xff;
+  uint8_t left_border_flag = 0xff;
 
   // leave space for the OLSR header
 
diff -r feb3d7883ff0 -r d73e73400732 src/lq_packet.h
--- a/src/lq_packet.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_packet.h	Fri Mar 13 19:16:23 2009 +0100
@@ -53,232 +53,232 @@
 /* deserialized OLSR header */
 
 struct olsr_common {
-  olsr_u8_t type;
+  uint8_t type;
   olsr_reltime vtime;
-  olsr_u16_t size;
+  uint16_t size;
   union olsr_ip_addr orig;
-  olsr_u8_t ttl;
-  olsr_u8_t hops;
-  olsr_u16_t seqno;
+  uint8_t ttl;
+  uint8_t hops;
+  uint16_t seqno;
 };
 
 /* serialized IPv4 OLSR header */
 
 struct olsr_header_v4 {
-  olsr_u8_t type;
-  olsr_u8_t vtime;
-  olsr_u16_t size;
-  olsr_u32_t orig;
-  olsr_u8_t ttl;
-  olsr_u8_t hops;
-  olsr_u16_t seqno;
+  uint8_t type;
+  uint8_t vtime;
+  uint16_t size;
+  uint32_t orig;
+  uint8_t ttl;
+  uint8_t hops;
+  uint16_t seqno;
 };
 
 /* serialized IPv6 OLSR header */
 
 struct olsr_header_v6 {
-  olsr_u8_t type;
-  olsr_u8_t vtime;
-  olsr_u16_t size;
+  uint8_t type;
+  uint8_t vtime;
+  uint16_t size;
   unsigned char orig[16];
-  olsr_u8_t ttl;
-  olsr_u8_t hops;
-  olsr_u16_t seqno;
+  uint8_t ttl;
+  uint8_t hops;
+  uint16_t seqno;
 };
 
 /* deserialized LQ_HELLO */
 
 struct lq_hello_neighbor {
-  olsr_u8_t link_type;
-  olsr_u8_t neigh_type;
+  uint8_t link_type;
+  uint8_t neigh_type;
   union olsr_ip_addr addr;
   struct lq_hello_neighbor *next;
-  olsr_u32_t linkquality[0];
+  uint32_t linkquality[0];
 };
 
 struct lq_hello_message {
   struct olsr_common comm;
   olsr_reltime htime;
-  olsr_u8_t will;
+  uint8_t will;
   struct lq_hello_neighbor *neigh;
 };
 
 /* serialized LQ_HELLO */
 
 struct lq_hello_info_header {
-  olsr_u8_t link_code;
-  olsr_u8_t reserved;
-  olsr_u16_t size;
+  uint8_t link_code;
+  uint8_t reserved;
+  uint16_t size;
 };
 
 struct lq_hello_header {
-  olsr_u16_t reserved;
-  olsr_u8_t htime;
-  olsr_u8_t will;
+  uint16_t reserved;
+  uint8_t htime;
+  uint8_t will;
 };
 
 /* deserialized LQ_TC */
 struct lq_tc_message {
   struct olsr_common comm;
   union olsr_ip_addr from;
-  olsr_u16_t ansn;
+  uint16_t ansn;
   struct tc_mpr_addr *neigh;
 };
 
 /* serialized LQ_TC */
 
 struct lq_tc_header {
-  olsr_u16_t ansn;
-  olsr_u8_t lower_border;
-  olsr_u8_t upper_border;
+  uint16_t ansn;
+  uint8_t lower_border;
+  uint8_t upper_border;
 };
 
 static INLINE void
-pkt_get_u8(const olsr_u8_t ** p, olsr_u8_t * var)
+pkt_get_u8(const uint8_t ** p, uint8_t * var)
 {
-  *var = *(const olsr_u8_t *)(*p);
-  *p += sizeof(olsr_u8_t);
+  *var = *(const uint8_t *)(*p);
+  *p += sizeof(uint8_t);
 }
 static INLINE void
-pkt_get_u16(const olsr_u8_t ** p, olsr_u16_t * var)
+pkt_get_u16(const uint8_t ** p, uint16_t * var)
 {
-  *var = ntohs(*(const olsr_u16_t *)(*p));
-  *p += sizeof(olsr_u16_t);
+  *var = ntohs(*(const uint16_t *)(*p));
+  *p += sizeof(uint16_t);
 }
 static INLINE void
-pkt_get_u32(const olsr_u8_t ** p, olsr_u32_t * var)
+pkt_get_u32(const uint8_t ** p, uint32_t * var)
 {
-  *var = ntohl(*(const olsr_u32_t *)(p));
-  *p += sizeof(olsr_u32_t);
+  *var = ntohl(*(const uint32_t *)(p));
+  *p += sizeof(uint32_t);
 }
 static INLINE void
-pkt_get_s8(const olsr_u8_t ** p, olsr_8_t * var)
+pkt_get_s8(const uint8_t ** p, int8_t * var)
 {
-  *var = *(const olsr_8_t *)(*p);
-  *p += sizeof(olsr_8_t);
+  *var = *(const int8_t *)(*p);
+  *p += sizeof(int8_t);
 }
 static INLINE void
-pkt_get_s16(const olsr_u8_t ** p, olsr_16_t * var)
+pkt_get_s16(const uint8_t ** p, int16_t * var)
 {
-  *var = ntohs(*(const olsr_16_t *)(*p));
-  *p += sizeof(olsr_16_t);
+  *var = ntohs(*(const int16_t *)(*p));
+  *p += sizeof(int16_t);
 }
 static INLINE void
-pkt_get_s32(const olsr_u8_t ** p, olsr_32_t * var)
+pkt_get_s32(const uint8_t ** p, int32_t * var)
 {
-  *var = ntohl(*(const olsr_32_t *)(*p));
-  *p += sizeof(olsr_32_t);
+  *var = ntohl(*(const int32_t *)(*p));
+  *p += sizeof(int32_t);
 }
 static INLINE void
-pkt_get_reltime(const olsr_u8_t ** p, olsr_reltime * var)
+pkt_get_reltime(const uint8_t ** p, olsr_reltime * var)
 {
   *var = me_to_reltime(**p);
-  *p += sizeof(olsr_u8_t);
+  *p += sizeof(uint8_t);
 }
 static INLINE void
-pkt_get_ipaddress(const olsr_u8_t ** p, union olsr_ip_addr *var)
+pkt_get_ipaddress(const uint8_t ** p, union olsr_ip_addr *var)
 {
   memcpy(var, *p, olsr_cnf->ipsize);
   *p += olsr_cnf->ipsize;
 }
 static INLINE void
-pkt_get_prefixlen(const olsr_u8_t ** p, olsr_u8_t * var)
+pkt_get_prefixlen(const uint8_t ** p, uint8_t * var)
 {
   *var = netmask_to_prefix(*p, olsr_cnf->ipsize);
   *p += olsr_cnf->ipsize;
 }
 
 static INLINE void
-pkt_ignore_u8(const olsr_u8_t ** p)
+pkt_ignore_u8(const uint8_t ** p)
 {
-  *p += sizeof(olsr_u8_t);
+  *p += sizeof(uint8_t);
 }
 static INLINE void
-pkt_ignore_u16(const olsr_u8_t ** p)
+pkt_ignore_u16(const uint8_t ** p)
 {
-  *p += sizeof(olsr_u16_t);
+  *p += sizeof(uint16_t);
 }
 static INLINE void
-pkt_ignore_u32(const olsr_u8_t ** p)
+pkt_ignore_u32(const uint8_t ** p)
 {
-  *p += sizeof(olsr_u32_t);
+  *p += sizeof(uint32_t);
 }
 static INLINE void
-pkt_ignore_s8(const olsr_u8_t ** p)
+pkt_ignore_s8(const uint8_t ** p)
 {
-  *p += sizeof(olsr_8_t);
+  *p += sizeof(int8_t);
 }
 static INLINE void
-pkt_ignore_s16(const olsr_u8_t ** p)
+pkt_ignore_s16(const uint8_t ** p)
 {
-  *p += sizeof(olsr_16_t);
+  *p += sizeof(int16_t);
 }
 static INLINE void
-pkt_ignore_s32(const olsr_u8_t ** p)
+pkt_ignore_s32(const uint8_t ** p)
 {
-  *p += sizeof(olsr_32_t);
+  *p += sizeof(int32_t);
 }
 static INLINE void
-pkt_ignore_ipaddress(const olsr_u8_t ** p)
+pkt_ignore_ipaddress(const uint8_t ** p)
 {
   *p += olsr_cnf->ipsize;
 }
 static INLINE void
-pkt_ignore_prefixlen(const olsr_u8_t ** p)
+pkt_ignore_prefixlen(const uint8_t ** p)
 {
   *p += olsr_cnf->ipsize;
 }
 
 static INLINE void
-pkt_put_u8(olsr_u8_t ** p, olsr_u8_t var)
+pkt_put_u8(uint8_t ** p, uint8_t var)
 {
-  *(olsr_u8_t *) (*p) = var;
-  *p += sizeof(olsr_u8_t);
+  *(uint8_t *) (*p) = var;
+  *p += sizeof(uint8_t);
 }
 static INLINE void
-pkt_put_u16(olsr_u8_t ** p, olsr_u16_t var)
+pkt_put_u16(uint8_t ** p, uint16_t var)
 {
-  *(olsr_u16_t *) (*p) = htons(var);
-  *p += sizeof(olsr_u16_t);
+  *(uint16_t *) (*p) = htons(var);
+  *p += sizeof(uint16_t);
 }
 static INLINE void
-pkt_put_u32(olsr_u8_t ** p, olsr_u32_t var)
+pkt_put_u32(uint8_t ** p, uint32_t var)
 {
-  *(olsr_u32_t *) (*p) = htonl(var);
-  *p += sizeof(olsr_u32_t);
+  *(uint32_t *) (*p) = htonl(var);
+  *p += sizeof(uint32_t);
 }
 static INLINE void
-pkt_put_s8(olsr_u8_t ** p, olsr_8_t var)
+pkt_put_s8(uint8_t ** p, int8_t var)
 {
-  *(olsr_8_t *) (*p) = var;
-  *p += sizeof(olsr_8_t);
+  *(int8_t *) (*p) = var;
+  *p += sizeof(int8_t);
 }
 static INLINE void
-pkt_put_s16(olsr_u8_t ** p, olsr_16_t var)
+pkt_put_s16(uint8_t ** p, int16_t var)
 {
-  *(olsr_16_t *) (*p) = htons(var);
-  *p += sizeof(olsr_16_t);
+  *(int16_t *) (*p) = htons(var);
+  *p += sizeof(int16_t);
 }
 static INLINE void
-pkt_put_s32(olsr_u8_t ** p, olsr_32_t var)
+pkt_put_s32(uint8_t ** p, int32_t var)
 {
-  *(olsr_32_t *) (*p) = htonl(var);
-  *p += sizeof(olsr_32_t);
+  *(int32_t *) (*p) = htonl(var);
+  *p += sizeof(int32_t);
 }
 static INLINE void
-pkt_put_reltime(olsr_u8_t ** p, olsr_reltime var)
+pkt_put_reltime(uint8_t ** p, olsr_reltime var)
 {
   **p = reltime_to_me(var);
-  *p += sizeof(olsr_u8_t);
+  *p += sizeof(uint8_t);
 }
 static INLINE void
-pkt_put_ipaddress(olsr_u8_t ** p, const union olsr_ip_addr *var)
+pkt_put_ipaddress(uint8_t ** p, const union olsr_ip_addr *var)
 {
   memcpy(*p, var, olsr_cnf->ipsize);
   *p += olsr_cnf->ipsize;
 }
 static INLINE void
-pkt_put_prefixlen(olsr_u8_t ** p, olsr_u8_t var)
+pkt_put_prefixlen(uint8_t ** p, uint8_t var)
 {
   prefix_to_netmask(*p, olsr_cnf->ipsize, var);
   *p += olsr_cnf->ipsize;
@@ -290,7 +290,7 @@
 
 void olsr_input_lq_hello(union olsr_message *ser, struct interface *inif, union olsr_ip_addr *from);
 
-extern olsr_bool lq_tc_pending;
+extern bool lq_tc_pending;
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin.c
--- a/src/lq_plugin.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin.c	Fri Mar 13 19:16:23 2009 +0100
@@ -99,7 +99,7 @@
   node->node.key = node->name;
   node->handler = handler;
 
-  avl_insert(&lq_handler_tree, &node->node, OLSR_FALSE);
+  avl_insert(&lq_handler_tree, &node->node, false);
 }
 
 int
@@ -148,7 +148,7 @@
  * @param second linkcost value
  * @return boolean
  */
-olsr_bool
+bool
 olsr_is_relevant_costchange(olsr_linkcost c1, olsr_linkcost c2)
 {
   return active_lq_handler->is_relevant_costchange(c1, c2);
@@ -181,7 +181,7 @@
  * @param pointer to hello_neighbor
  */
 void
-olsr_deserialize_hello_lq_pair(const olsr_u8_t ** curr, struct hello_neighbor *neigh)
+olsr_deserialize_hello_lq_pair(const uint8_t ** curr, struct hello_neighbor *neigh)
 {
   assert((const char *)neigh + sizeof(*neigh) == (const char *)neigh->linkquality);
   active_lq_handler->deserialize_hello_lq(curr, neigh->linkquality);
@@ -214,7 +214,7 @@
  * @param pointer to tc_edge_entry
  */
 void
-olsr_deserialize_tc_lq_pair(const olsr_u8_t ** curr, struct tc_edge_entry *edge)
+olsr_deserialize_tc_lq_pair(const uint8_t ** curr, struct tc_edge_entry *edge)
 {
   assert((const char *)edge + sizeof(*edge) == (const char *)edge->linkquality);
   active_lq_handler->deserialize_tc_lq(curr, edge->linkquality);
@@ -228,10 +228,10 @@
  * quality value.
  *
  * @param pointer to link_entry
- * @param OLSR_TRUE if hello package was lost
+ * @param true if hello package was lost
  */
 void
-olsr_update_packet_loss_worker(struct link_entry *entry, olsr_bool lost)
+olsr_update_packet_loss_worker(struct link_entry *entry, bool lost)
 {
   olsr_linkcost lq;
   assert((const char *)entry + sizeof(*entry) == (const char *)entry->linkquality);
@@ -241,15 +241,15 @@
     entry->linkcost = lq;
 
     if (olsr_cnf->lq_dlimit > 0) {
-      changes_neighborhood = OLSR_TRUE;
-      changes_topology = OLSR_TRUE;
+      changes_neighborhood = true;
+      changes_topology = true;
     }
 
     else
       OLSR_PRINTF(3, "Skipping Dijkstra (1)\n");
 
     /* XXX - we should check whether we actually announce this neighbour */
-    signal_link_changes(OLSR_TRUE);
+    signal_link_changes(true);
   }
 }
 
@@ -325,7 +325,7 @@
  * @return pointer to buffer filled with text
  */
 const char *
-get_linkcost_text(olsr_linkcost cost, olsr_bool route, struct lqtextbuffer *buffer)
+get_linkcost_text(olsr_linkcost cost, bool route, struct lqtextbuffer *buffer)
 {
   static const char *infinite = "INFINITE";
 
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin.h
--- a/src/lq_plugin.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin.h	Fri Mar 13 19:16:23 2009 +0100
@@ -69,9 +69,9 @@
     olsr_linkcost(*calc_hello_cost) (const void *lq);
     olsr_linkcost(*calc_tc_cost) (const void *lq);
 
-    olsr_bool(*is_relevant_costchange) (olsr_linkcost c1, olsr_linkcost c2);
+    bool(*is_relevant_costchange) (olsr_linkcost c1, olsr_linkcost c2);
 
-    olsr_linkcost(*packet_loss_handler) (struct link_entry * entry, void *lq, olsr_bool lost);
+    olsr_linkcost(*packet_loss_handler) (struct link_entry * entry, void *lq, bool lost);
 
   void (*memorize_foreign_hello) (void *local, void *foreign);
   void (*copy_link_lq_into_tc) (void *target, void *source);
@@ -80,8 +80,8 @@
 
   int (*serialize_hello_lq) (unsigned char *buff, void *lq);
   int (*serialize_tc_lq) (unsigned char *buff, void *lq);
-  void (*deserialize_hello_lq) (const olsr_u8_t ** curr, void *lq);
-  void (*deserialize_tc_lq) (const olsr_u8_t ** curr, void *lq);
+  void (*deserialize_hello_lq) (const uint8_t ** curr, void *lq);
+  void (*deserialize_tc_lq) (const uint8_t ** curr, void *lq);
 
   const char *(*print_hello_lq) (void *ptr, char separator, struct lqtextbuffer * buffer);
   const char *(*print_tc_lq) (void *ptr, char separator, struct lqtextbuffer * buffer);
@@ -115,19 +115,19 @@
 int activate_lq_handler(const char *name);
 
 olsr_linkcost olsr_calc_tc_cost(const struct tc_edge_entry *);
-olsr_bool olsr_is_relevant_costchange(olsr_linkcost c1, olsr_linkcost c2);
+bool olsr_is_relevant_costchange(olsr_linkcost c1, olsr_linkcost c2);
 
 int olsr_serialize_hello_lq_pair(unsigned char *buff, struct lq_hello_neighbor *neigh);
-void olsr_deserialize_hello_lq_pair(const olsr_u8_t ** curr, struct hello_neighbor *neigh);
+void olsr_deserialize_hello_lq_pair(const uint8_t ** curr, struct hello_neighbor *neigh);
 int olsr_serialize_tc_lq_pair(unsigned char *buff, struct tc_mpr_addr *neigh);
-void olsr_deserialize_tc_lq_pair(const olsr_u8_t ** curr, struct tc_edge_entry *edge);
+void olsr_deserialize_tc_lq_pair(const uint8_t ** curr, struct tc_edge_entry *edge);
 
-void olsr_update_packet_loss_worker(struct link_entry *entry, olsr_bool lost);
+void olsr_update_packet_loss_worker(struct link_entry *entry, bool lost);
 void olsr_memorize_foreign_hello_lq(struct link_entry *local, struct hello_neighbor *foreign);
 
 const char *get_link_entry_text(struct link_entry *entry, char separator, struct lqtextbuffer *buffer);
 const char *get_tc_edge_entry_text(struct tc_edge_entry *entry, char separator, struct lqtextbuffer *buffer);
-const char *get_linkcost_text(olsr_linkcost cost, olsr_bool route, struct lqtextbuffer *buffer);
+const char *get_linkcost_text(olsr_linkcost cost, bool route, struct lqtextbuffer *buffer);
 
 void olsr_copy_hello_lq(struct lq_hello_neighbor *target, struct link_entry *source);
 void olsr_copylq_link_entry_2_tc_mpr_addr(struct tc_mpr_addr *target, struct link_entry *source);
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_ff.c
--- a/src/lq_plugin_default_ff.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_ff.c	Fri Mar 13 19:16:23 2009 +0100
@@ -85,7 +85,7 @@
   const union olsr_ip_addr *main_addr;
   struct link_entry *lnk;
   struct default_lq_ff_hello *lq;
-  olsr_u32_t seq_diff;
+  uint32_t seq_diff;
 
   /* Find main address */
   main_addr = mid_lookup_main_addr(from_addr);
@@ -98,8 +98,13 @@
 
   lq = (struct default_lq_ff_hello *)lnk->linkquality;
 
+  /* ignore double package */
+  if (lq->last_seq_nr == olsr->olsr_seqno) {
+    return;
+  }
+
   if (lq->last_seq_nr > olsr->olsr_seqno) {
-    seq_diff = (olsr_u32_t) olsr->olsr_seqno + 65536 - lq->last_seq_nr;
+    seq_diff = (uint32_t) olsr->olsr_seqno + 65536 - lq->last_seq_nr;
   } else {
     seq_diff = olsr->olsr_seqno - lq->last_seq_nr;
   }
@@ -122,7 +127,7 @@
   OLSR_FOR_ALL_LINK_ENTRIES(link) {
     struct default_lq_ff_hello *tlq = (struct default_lq_ff_hello *)link->linkquality;
     fpm ratio;
-    olsr_u16_t i, received, lost;
+    uint16_t i, received, lost;
 
     received = 0;
     lost = 0;
@@ -148,7 +153,7 @@
       ratio = fpmidiv(ratio, (int)(received + lost));
       ratio = fpmmuli(ratio, 255);
 
-      tlq->lq.valueLq = (olsr_u8_t) (fpmtoi(ratio));
+      tlq->lq.valueLq = (uint8_t) (fpmtoi(ratio));
     }
     link->linkcost = default_lq_calc_cost_ff(tlq);
 
@@ -199,7 +204,7 @@
 }
 
 void
-default_lq_deserialize_hello_lq_pair_ff(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_hello_lq_pair_ff(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_ff *lq = ptr;
 
@@ -208,7 +213,7 @@
   pkt_ignore_u16(curr);
 }
 
-olsr_bool
+bool
 default_lq_is_relevant_costchange_ff(olsr_linkcost c1, olsr_linkcost c2)
 {
   if (c1 > c2) {
@@ -231,7 +236,7 @@
 }
 
 void
-default_lq_deserialize_tc_lq_pair_ff(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_tc_lq_pair_ff(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_ff *lq = ptr;
 
@@ -243,7 +248,7 @@
 olsr_linkcost
 default_lq_packet_loss_worker_ff(struct link_entry
                                  __attribute__ ((unused)) * link, void
-                                 __attribute__ ((unused)) * ptr, olsr_bool __attribute__ ((unused)) lost)
+                                 __attribute__ ((unused)) * ptr, bool __attribute__ ((unused)) lost)
 {
   return link->linkcost;
 }
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_ff.h
--- a/src/lq_plugin_default_ff.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_ff.h	Fri Mar 13 19:16:23 2009 +0100
@@ -54,30 +54,30 @@
 #define LQ_FF_QUICKSTART_INIT 4
 
 struct default_lq_ff {
-  olsr_u8_t valueLq;
-  olsr_u8_t valueNlq;
+  uint8_t valueLq;
+  uint8_t valueNlq;
 };
 
 struct default_lq_ff_hello {
   struct default_lq_ff lq;
-  olsr_u8_t windowSize, activePtr;
-  olsr_u16_t last_seq_nr;
-  olsr_u16_t received[LQ_FF_WINDOW], lost[LQ_FF_WINDOW];
+  uint8_t windowSize, activePtr;
+  uint16_t last_seq_nr;
+  uint16_t received[LQ_FF_WINDOW], lost[LQ_FF_WINDOW];
 };
 
 void default_lq_initialize_ff(void);
 
 olsr_linkcost default_lq_calc_cost_ff(const void *lq);
 
-olsr_bool default_lq_is_relevant_costchange_ff(olsr_linkcost c1, olsr_linkcost c2);
+bool default_lq_is_relevant_costchange_ff(olsr_linkcost c1, olsr_linkcost c2);
 
-olsr_linkcost default_lq_packet_loss_worker_ff(struct link_entry *link, void *lq, olsr_bool lost);
+olsr_linkcost default_lq_packet_loss_worker_ff(struct link_entry *link, void *lq, bool lost);
 void default_lq_memorize_foreign_hello_ff(void *local, void *foreign);
 
 int default_lq_serialize_hello_lq_pair_ff(unsigned char *buff, void *lq);
-void default_lq_deserialize_hello_lq_pair_ff(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_hello_lq_pair_ff(const uint8_t ** curr, void *lq);
 int default_lq_serialize_tc_lq_pair_ff(unsigned char *buff, void *lq);
-void default_lq_deserialize_tc_lq_pair_ff(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_tc_lq_pair_ff(const uint8_t ** curr, void *lq);
 
 void default_lq_copy_link2tc_ff(void *target, void *source);
 void default_lq_clear_ff(void *target);
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_float.c
--- a/src/lq_plugin_default_float.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_float.c	Fri Mar 13 19:16:23 2009 +0100
@@ -115,10 +115,10 @@
 }
 
 void
-default_lq_deserialize_hello_lq_pair_float(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_hello_lq_pair_float(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_float *lq = ptr;
-  olsr_u8_t lq_value, nlq_value;
+  uint8_t lq_value, nlq_value;
 
   pkt_get_u8(curr, &lq_value);
   pkt_get_u8(curr, &nlq_value);
@@ -128,7 +128,7 @@
   lq->nlq = (float)nlq_value / 255.0;
 }
 
-olsr_bool
+bool
 default_lq_is_relevant_costchange_float(olsr_linkcost c1, olsr_linkcost c2)
 {
   if (c1 > c2) {
@@ -151,10 +151,10 @@
 }
 
 void
-default_lq_deserialize_tc_lq_pair_float(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_tc_lq_pair_float(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_float *lq = ptr;
-  olsr_u8_t lq_value, nlq_value;
+  uint8_t lq_value, nlq_value;
 
   pkt_get_u8(curr, &lq_value);
   pkt_get_u8(curr, &nlq_value);
@@ -165,7 +165,7 @@
 }
 
 olsr_linkcost
-default_lq_packet_loss_worker_float(struct link_entry *link, void *ptr, olsr_bool lost)
+default_lq_packet_loss_worker_float(struct link_entry *link, void *ptr, bool lost)
 {
   struct default_lq_float *tlq = ptr;
   float alpha = olsr_cnf->lq_aging;
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_float.h
--- a/src/lq_plugin_default_float.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_float.h	Fri Mar 13 19:16:23 2009 +0100
@@ -51,22 +51,22 @@
 
 struct default_lq_float {
   float lq, nlq;
-  olsr_u16_t quickstart;
+  uint16_t quickstart;
 };
 
 void default_lq_initialize_float(void);
 
 olsr_linkcost default_lq_calc_cost_float(const void *lq);
 
-olsr_bool default_lq_is_relevant_costchange_float(olsr_linkcost c1, olsr_linkcost c2);
+bool default_lq_is_relevant_costchange_float(olsr_linkcost c1, olsr_linkcost c2);
 
-olsr_linkcost default_lq_packet_loss_worker_float(struct link_entry *link, void *lq, olsr_bool lost);
+olsr_linkcost default_lq_packet_loss_worker_float(struct link_entry *link, void *lq, bool lost);
 void default_lq_memorize_foreign_hello_float(void *local, void *foreign);
 
 int default_lq_serialize_hello_lq_pair_float(unsigned char *buff, void *lq);
-void default_lq_deserialize_hello_lq_pair_float(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_hello_lq_pair_float(const uint8_t ** curr, void *lq);
 int default_lq_serialize_tc_lq_pair_float(unsigned char *buff, void *lq);
-void default_lq_deserialize_tc_lq_pair_float(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_tc_lq_pair_float(const uint8_t ** curr, void *lq);
 
 void default_lq_copy_link2tc_float(void *target, void *source);
 void default_lq_clear_float(void *target);
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_fpm.c
--- a/src/lq_plugin_default_fpm.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_fpm.c	Fri Mar 13 19:16:23 2009 +0100
@@ -76,16 +76,16 @@
   sizeof(struct default_lq_fpm)
 };
 
-olsr_u32_t aging_factor_new, aging_factor_old;
-olsr_u32_t aging_quickstart_new, aging_quickstart_old;
+uint32_t aging_factor_new, aging_factor_old;
+uint32_t aging_quickstart_new, aging_quickstart_old;
 
 void
 default_lq_initialize_fpm(void)
 {
-  aging_factor_new = (olsr_u32_t) (olsr_cnf->lq_aging * LQ_FPM_INTERNAL_MULTIPLIER);
+  aging_factor_new = (uint32_t) (olsr_cnf->lq_aging * LQ_FPM_INTERNAL_MULTIPLIER);
   aging_factor_old = LQ_FPM_INTERNAL_MULTIPLIER - aging_factor_new;
 
-  aging_quickstart_new = (olsr_u32_t) (LQ_QUICKSTART_AGING * LQ_FPM_INTERNAL_MULTIPLIER);
+  aging_quickstart_new = (uint32_t) (LQ_QUICKSTART_AGING * LQ_FPM_INTERNAL_MULTIPLIER);
   aging_quickstart_old = LQ_FPM_INTERNAL_MULTIPLIER - aging_quickstart_new;
 }
 
@@ -122,7 +122,7 @@
 }
 
 void
-default_lq_deserialize_hello_lq_pair_fpm(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_hello_lq_pair_fpm(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_fpm *lq = ptr;
 
@@ -131,7 +131,7 @@
   pkt_ignore_u16(curr);
 }
 
-olsr_bool
+bool
 default_lq_is_relevant_costchange_fpm(olsr_linkcost c1, olsr_linkcost c2)
 {
   if (c1 > c2) {
@@ -154,7 +154,7 @@
 }
 
 void
-default_lq_deserialize_tc_lq_pair_fpm(const olsr_u8_t ** curr, void *ptr)
+default_lq_deserialize_tc_lq_pair_fpm(const uint8_t ** curr, void *ptr)
 {
   struct default_lq_fpm *lq = ptr;
 
@@ -164,13 +164,13 @@
 }
 
 olsr_linkcost
-default_lq_packet_loss_worker_fpm(struct link_entry *link, void *ptr, olsr_bool lost)
+default_lq_packet_loss_worker_fpm(struct link_entry *link, void *ptr, bool lost)
 {
   struct default_lq_fpm *tlq = ptr;
-  olsr_u32_t alpha_old = aging_factor_old;
-  olsr_u32_t alpha_new = aging_factor_new;
+  uint32_t alpha_old = aging_factor_old;
+  uint32_t alpha_new = aging_factor_new;
 
-  olsr_u32_t value;
+  uint32_t value;
   // fpm link_loss_factor = fpmidiv(itofpm(link->loss_link_multiplier), 65536);
 
   if (tlq->quickstart < LQ_QUICKSTART_STEPS) {
@@ -179,12 +179,12 @@
     tlq->quickstart++;
   }
   // exponential moving average
-  value = (olsr_u32_t) (tlq->valueLq) * LQ_FPM_INTERNAL_MULTIPLIER / 255;
+  value = (uint32_t) (tlq->valueLq) * LQ_FPM_INTERNAL_MULTIPLIER / 255;
 
   value = (value * alpha_old + LQ_FPM_INTERNAL_MULTIPLIER - 1) / LQ_FPM_INTERNAL_MULTIPLIER;
 
   if (!lost) {
-    olsr_u32_t ratio;
+    uint32_t ratio;
 
     ratio = (alpha_new * link->loss_link_multiplier + LINK_LOSS_MULTIPLIER - 1) / LINK_LOSS_MULTIPLIER;
     value += ratio;
diff -r feb3d7883ff0 -r d73e73400732 src/lq_plugin_default_fpm.h
--- a/src/lq_plugin_default_fpm.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/lq_plugin_default_fpm.h	Fri Mar 13 19:16:23 2009 +0100
@@ -55,24 +55,24 @@
 #define LQ_ALGORITHM_ETX_FPM_NAME "etx_fpm"
 
 struct default_lq_fpm {
-  olsr_u8_t valueLq;
-  olsr_u8_t valueNlq;
-  olsr_u16_t quickstart;
+  uint8_t valueLq;
+  uint8_t valueNlq;
+  uint16_t quickstart;
 };
 
 void default_lq_initialize_fpm(void);
 
 olsr_linkcost default_lq_calc_cost_fpm(const void *lq);
 
-olsr_bool default_lq_is_relevant_costchange_fpm(olsr_linkcost c1, olsr_linkcost c2);
+bool default_lq_is_relevant_costchange_fpm(olsr_linkcost c1, olsr_linkcost c2);
 
-olsr_linkcost default_lq_packet_loss_worker_fpm(struct link_entry *link, void *lq, olsr_bool lost);
+olsr_linkcost default_lq_packet_loss_worker_fpm(struct link_entry *link, void *lq, bool lost);
 void default_lq_memorize_foreign_hello_fpm(void *local, void *foreign);
 
 int default_lq_serialize_hello_lq_pair_fpm(unsigned char *buff, void *lq);
-void default_lq_deserialize_hello_lq_pair_fpm(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_hello_lq_pair_fpm(const uint8_t ** curr, void *lq);
 int default_lq_serialize_tc_lq_pair_fpm(unsigned char *buff, void *lq);
-void default_lq_deserialize_tc_lq_pair_fpm(const olsr_u8_t ** curr, void *lq);
+void default_lq_deserialize_tc_lq_pair_fpm(const uint8_t ** curr, void *lq);
 
 void default_lq_copy_link2tc_fpm(void *target, void *source);
 void default_lq_clear_fpm(void *target);
diff -r feb3d7883ff0 -r d73e73400732 src/main.c
--- a/src/main.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/main.c	Fri Mar 13 19:16:23 2009 +0100
@@ -69,8 +69,8 @@
 int __stdcall SignalHandler(unsigned long signal) __attribute__ ((noreturn));
 void ListInterfaces(void);
 void DisableIcmpRedirects(void);
-olsr_bool olsr_win32_end_request = OLSR_FALSE;
-olsr_bool olsr_win32_end_flag = OLSR_FALSE;
+bool olsr_win32_end_request = false;
+bool olsr_win32_end_flag = false;
 #else
 static void olsr_shutdown(int) __attribute__ ((noreturn));
 #endif
@@ -109,12 +109,12 @@
 #endif
 
   /* paranoia checks */
-  assert(sizeof(olsr_u8_t) == 1);
-  assert(sizeof(olsr_u16_t) == 2);
-  assert(sizeof(olsr_u32_t) == 4);
-  assert(sizeof(olsr_8_t) == 1);
-  assert(sizeof(olsr_16_t) == 2);
-  assert(sizeof(olsr_32_t) == 4);
+  assert(sizeof(uint8_t) == 1);
+  assert(sizeof(uint16_t) == 2);
+  assert(sizeof(uint32_t) == 4);
+  assert(sizeof(int8_t) == 1);
+  assert(sizeof(int16_t) == 2);
+  assert(sizeof(int32_t) == 4);
 
   debug_handle = stdout;
 #ifndef WIN32
@@ -143,6 +143,18 @@
 
   /* Grab initial timestamp */
   now_times = olsr_times();
+  if ((clock_t)-1 == now_times) {
+    const char * const err_msg = strerror(errno);
+    olsr_syslog(OLSR_LOG_ERR, "Error in times(): %s, sleeping for a second", err_msg);
+    OLSR_PRINTF(1, "Error in times(): %s, sleeping for a second", err_msg);
+    sleep(1);
+    now_times = olsr_times();
+    if ((clock_t)-1 == now_times) {
+      olsr_syslog(OLSR_LOG_ERR, "Shutting down because times() does not work");
+      fprintf(stderr, "Shutting down because times() does not work\n");
+      exit(EXIT_FAILURE);
+    }
+  }
 
   printf("\n *** %s ***\n Build date: %s on %s\n http://www.olsr.org\n\n", olsrd_version, build_date, build_host);
 
@@ -374,7 +386,7 @@
   /* ctrl-C and friends */
 #ifdef WIN32
 #ifndef WINCE
-  SetConsoleCtrlHandler(SignalHandler, OLSR_TRUE);
+  SetConsoleCtrlHandler(SignalHandler, true);
 #endif
 #else
   signal(SIGHUP, olsr_reconfigure);
@@ -387,7 +399,7 @@
   signal(SIGPIPE, SIG_IGN);
 #endif
 
-  link_changes = OLSR_FALSE;
+  link_changes = false;
 
   /* Starting scheduler */
   olsr_scheduler();
@@ -405,15 +417,32 @@
 void
 olsr_reconfigure(int signal __attribute__ ((unused)))
 {
-  if (!fork()) {
-    /* New process */
-    sleep(3);
-    printf("Restarting %s\n", olsr_argv[0]);
-    execv(olsr_argv[0], olsr_argv);
+  /* if we are started with -nofork, we do not weant to go into the
+   * background here. So we can simply stop on -HUP
+   */
+  olsr_syslog(OLSR_LOG_INFO, "sot: olsr_reconfigure()\n");
+  if (!olsr_cnf->no_fork) {
+    if (!fork()) {
+      int i;
+      sigset_t sigs;
+      /* New process */
+      sleep(3);
+      sigemptyset(&sigs);
+      sigaddset(&sigs, SIGHUP);
+      sigprocmask(SIG_UNBLOCK, &sigs, NULL);
+      for (i = sysconf(_SC_OPEN_MAX); --i > STDERR_FILENO; ) {
+        close(i);
+      }
+      printf("Restarting %s\n", olsr_argv[0]);
+      olsr_syslog(OLSR_LOG_INFO, "Restarting %s\n", olsr_argv[0]);
+      execv(olsr_argv[0], olsr_argv);
+      olsr_syslog(OLSR_LOG_ERR, "execv(%s) fails: %s!\n", olsr_argv[0], strerror(errno));
+    }
+    else {
+      olsr_syslog(OLSR_LOG_INFO, "RECONFIGURING!\n");
+    }
   }
   olsr_shutdown(0);
-
-  printf("RECONFIGURING!\n");
 }
 #endif
 
@@ -585,7 +614,7 @@
         printf("Invalid broadcast address! %s\nSkipping it!\n", *argv);
         continue;
       }
-      memcpy(&ifcnf->ipv4_broadcast.v4, &in.s_addr, sizeof(olsr_u32_t));
+      memcpy(&ifcnf->ipv4_broadcast.v4, &in.s_addr, sizeof(uint32_t));
       continue;
     }
 
@@ -662,12 +691,12 @@
         olsr_exit(__func__, EXIT_FAILURE);
       }
       printf("Queuing if %s\n", *argv);
-      queue_if(*argv, OLSR_FALSE);
+      queue_if(*argv, false);
 
       while ((argc - 1) && (argv[1][0] != '-')) {
         NEXT_ARG;
         printf("Queuing if %s\n", *argv);
-        queue_if(*argv, OLSR_FALSE);
+        queue_if(*argv, false);
       }
 
       continue;
@@ -734,7 +763,7 @@
      * Should we display the contents of packages beeing sent?
      */
     if (strcmp(*argv, "-dispin") == 0) {
-      parser_set_disp_pack_in(OLSR_TRUE);
+      parser_set_disp_pack_in(true);
       continue;
     }
 
@@ -742,7 +771,7 @@
      * Should we display the contents of incoming packages?
      */
     if (strcmp(*argv, "-dispout") == 0) {
-      net_set_disp_pack_out(OLSR_TRUE);
+      net_set_disp_pack_out(true);
       continue;
     }
 
@@ -786,15 +815,15 @@
       }
       /* Add hemu interface */
 
-      ifa = queue_if("hcif01", OLSR_TRUE);
+      ifa = queue_if("hcif01", true);
 
       if (!ifa)
         continue;
 
       ifa->cnf = get_default_if_config();
-      ifa->host_emul = OLSR_TRUE;
+      ifa->host_emul = true;
       memcpy(&ifa->hemu_ip, &in, sizeof(union olsr_ip_addr));
-      cnf->host_emul = OLSR_TRUE;
+      cnf->host_emul = true;
 
       continue;
     }
@@ -803,12 +832,12 @@
      * Delete possible default GWs
      */
     if (strcmp(*argv, "-delgw") == 0) {
-      olsr_cnf->del_gws = OLSR_TRUE;
+      olsr_cnf->del_gws = true;
       continue;
     }
 
     if (strcmp(*argv, "-nofork") == 0) {
-      cnf->no_fork = OLSR_TRUE;
+      cnf->no_fork = true;
       continue;
     }
 
@@ -818,18 +847,20 @@
 }
 
 /*
- * a wrapper around times(2). times(2) has the problem, that it may return -1
- * in case of an err (e.g. EFAULT on the parameter) or immediately before an
- * overrun (though it is not en error) just because the jiffies (or whatever
- * the underlying kernel calls the smallest accountable time unit) are
- * inherently "unsigned" (and always incremented).
+ * A wrapper around times(2). Note, that this function has
+ * some portability problems, e.g. different operating systems
+ * and linux kernel versions may return values counted from
+ * an arbitrary point in time (mostly uptime, some count from
+ * the epoch. The linux man page therefore recommends not to
+ * use this function. On the other hand, this function has
+ * proved it's functions but some olsrd implementations does
+ * error handling in a clumsy way - thus inducing bugs...
  */
-unsigned long
+clock_t
 olsr_times(void)
 {
   struct tms tms_buf;
-  const long t = times(&tms_buf);
-  return t < 0 ? -errno : t;
+  return times(&tms_buf);
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/mantissa.c
--- a/src/mantissa.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mantissa.c	Fri Mar 13 19:16:23 2009 +0100
@@ -55,10 +55,10 @@
  *
  *@return a 8-bit mantissa/exponent product
  */
-olsr_u8_t
+uint8_t
 reltime_to_me(const olsr_reltime interval)
 {
-  olsr_u8_t a, b;
+  uint8_t a, b;
 
   /* It is sufficent to compare the integer part since we test on >=.
    * So we have now only a floating point division and the rest of the loop
@@ -164,10 +164,10 @@
  *           = ((16 + a) * 1000) >> (8-b)
  */
 olsr_reltime
-me_to_reltime(const olsr_u8_t me)
+me_to_reltime(const uint8_t me)
 {
-  const olsr_u8_t a = me >> 4;
-  const olsr_u8_t b = me & 0x0F;
+  const uint8_t a = me >> 4;
+  const uint8_t b = me & 0x0F;
 
   if (b >= 8) {
     return ((16 + a) << (b - 8)) * 1000;
diff -r feb3d7883ff0 -r d73e73400732 src/mantissa.h
--- a/src/mantissa.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mantissa.h	Fri Mar 13 19:16:23 2009 +0100
@@ -45,7 +45,7 @@
 #include "olsr_types.h"
 
 /* olsr_reltime is a relative timestamp measured in microseconds */
-typedef olsr_u32_t olsr_reltime;
+typedef uint32_t olsr_reltime;
 
 /**
  * Macro for converting a mantissa/exponent 8bit value back
@@ -60,9 +60,9 @@
  * me is the 8 bit mantissa/exponent value
  *
  */
-olsr_reltime me_to_reltime(const olsr_u8_t);
+olsr_reltime me_to_reltime(const uint8_t);
 
-olsr_u8_t reltime_to_me(const olsr_reltime);
+uint8_t reltime_to_me(const olsr_reltime);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/mid_set.c
--- a/src/mid_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mid_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -128,7 +128,7 @@
 {
   struct mid_entry *tmp;
   struct mid_address *tmp_adr;
-  olsr_u32_t hash, alias_hash;
+  uint32_t hash, alias_hash;
   union olsr_ip_addr *registered_m_addr;
 
   hash = olsr_ip_hashing(m_addr);
@@ -198,7 +198,7 @@
 
       olsr_delete_two_hop_neighbor_table(tmp_2_neighbor);
 
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
     }
 
     /* Delete a possible neighbor entry */
@@ -215,7 +215,7 @@
       /* Delete */
       free(tmp_neigh);
 
-      changes_neighborhood = OLSR_TRUE;
+      changes_neighborhood = true;
     }
     tmp_adr = tmp_adr->next_alias;
   }
@@ -285,8 +285,8 @@
   /*
    *Recalculate topology
    */
-  changes_neighborhood = OLSR_TRUE;
-  changes_topology = OLSR_TRUE;
+  changes_neighborhood = true;
+  changes_topology = true;
 }
 
 /**
@@ -299,7 +299,7 @@
 union olsr_ip_addr *
 mid_lookup_main_addr(const union olsr_ip_addr *adr)
 {
-  olsr_u32_t hash;
+  uint32_t hash;
   struct mid_address *tmp_list;
 
   hash = olsr_ip_hashing(adr);
@@ -323,7 +323,7 @@
 mid_lookup_entry_bymain(const union olsr_ip_addr *adr)
 {
   struct mid_entry *tmp_list;
-  olsr_u32_t hash;
+  uint32_t hash;
 
   hash = olsr_ip_hashing(adr);
 
@@ -357,7 +357,7 @@
 int
 olsr_update_mid_table(const union olsr_ip_addr *adr, olsr_reltime vtime)
 {
-  olsr_u32_t hash;
+  uint32_t hash;
   struct ipaddr_str buf;
   struct mid_entry *tmp_list = mid_set;
 
@@ -387,7 +387,7 @@
 olsr_prune_aliases(const union olsr_ip_addr *m_addr, struct mid_alias *declared_aliases)
 {
   struct mid_entry *entry;
-  olsr_u32_t hash;
+  uint32_t hash;
   struct mid_address *registered_aliases;
   struct mid_address *previous_alias;
   struct mid_alias *save_declared_aliases = declared_aliases;
@@ -444,8 +444,8 @@
       /*
        *Recalculate topology
        */
-      changes_neighborhood = OLSR_TRUE;
-      changes_topology = OLSR_TRUE;
+      changes_neighborhood = true;
+      changes_topology = true;
     } else {
       previous_alias = current_alias;
     }
@@ -525,7 +525,7 @@
  *@return 1 on success
  */
 
-olsr_bool
+bool
 olsr_input_mid(union olsr_message *m, struct interface *in_if __attribute__ ((unused)), union olsr_ip_addr *from_addr)
 {
 #ifdef DEBUG
@@ -538,7 +538,7 @@
 
   if (!olsr_validate_address(&message.mid_origaddr)) {
     olsr_free_mid_packet(&message);
-    return OLSR_FALSE;
+    return false;
   }
 #ifdef DEBUG
   OLSR_PRINTF(5, "Processing MID from %s...\n", olsr_ip_to_string(&buf, &message.mid_origaddr));
@@ -555,7 +555,7 @@
     struct ipaddr_str buf;
     OLSR_PRINTF(2, "Received MID from NON SYM neighbor %s\n", olsr_ip_to_string(&buf, from_addr));
     olsr_free_mid_packet(&message);
-    return OLSR_FALSE;
+    return false;
   }
 
   /* Update the timeout of the MID */
@@ -575,7 +575,7 @@
   olsr_free_mid_packet(&message);
 
   /* Forward the message */
-  return OLSR_TRUE;
+  return true;
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/mid_set.h
--- a/src/mid_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mid_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -84,7 +84,7 @@
 void olsr_prune_aliases(const union olsr_ip_addr *, struct mid_alias *);
 int olsr_update_mid_table(const union olsr_ip_addr *, olsr_reltime);
 void olsr_delete_mid_entry(struct mid_entry *);
-olsr_bool olsr_input_mid(union olsr_message *, struct interface *, union olsr_ip_addr *);
+bool olsr_input_mid(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/mpr.c
--- a/src/mpr.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mpr.c	Fri Mar 13 19:16:23 2009 +0100
@@ -52,7 +52,7 @@
  * Prototypes for internal functions
  */
 
-static olsr_u16_t add_will_always_nodes(void);
+static uint16_t add_will_always_nodes(void);
 
 static void olsr_optimize_mpr_set(void);
 
@@ -62,11 +62,11 @@
 
 static struct neighbor_entry *olsr_find_maximum_covered(int);
 
-static olsr_u16_t olsr_calculate_two_hop_neighbors(void);
+static uint16_t olsr_calculate_two_hop_neighbors(void);
 
 static int olsr_check_mpr_changes(void);
 
-static int olsr_chosen_mpr(struct neighbor_entry *, olsr_u16_t *);
+static int olsr_chosen_mpr(struct neighbor_entry *, uint16_t *);
 
 static struct neighbor_2_list_entry *olsr_find_2_hop_neighbors_with_1_link(int);
 
@@ -87,7 +87,7 @@
 olsr_find_2_hop_neighbors_with_1_link(int willingness)
 {
 
-  olsr_u8_t index;
+  uint8_t index;
   struct neighbor_2_list_entry *two_hop_list_tmp = NULL;
   struct neighbor_2_list_entry *two_hop_list = NULL;
   struct neighbor_entry *dup_neighbor;
@@ -138,12 +138,12 @@
  *used in calculations
  */
 static int
-olsr_chosen_mpr(struct neighbor_entry *one_hop_neighbor, olsr_u16_t * two_hop_covered_count)
+olsr_chosen_mpr(struct neighbor_entry *one_hop_neighbor, uint16_t * two_hop_covered_count)
 {
   struct neighbor_list_entry *the_one_hop_list;
   struct neighbor_2_list_entry *second_hop_entries;
   struct neighbor_entry *dup_neighbor;
-  olsr_u16_t count;
+  uint16_t count;
   struct ipaddr_str buf;
   count = *two_hop_covered_count;
 
@@ -151,7 +151,7 @@
 
   //printf("PRE COUNT: %d\n\n", count);
 
-  one_hop_neighbor->is_mpr = OLSR_TRUE; //NBS_MPR;
+  one_hop_neighbor->is_mpr = true;      //NBS_MPR;
 
   for (second_hop_entries = one_hop_neighbor->neighbor_2_list.next; second_hop_entries != &one_hop_neighbor->neighbor_2_list;
        second_hop_entries = second_hop_entries->next) {
@@ -206,7 +206,7 @@
 static struct neighbor_entry *
 olsr_find_maximum_covered(int willingness)
 {
-  olsr_u16_t maximum;
+  uint16_t maximum;
   struct neighbor_entry *a_neighbor;
   struct neighbor_entry *mpr_candidate = NULL;
 
@@ -243,8 +243,8 @@
 
     /* Clear MPR selection. */
     if (a_neighbor->is_mpr) {
-      a_neighbor->was_mpr = OLSR_TRUE;
-      a_neighbor->is_mpr = OLSR_FALSE;
+      a_neighbor->was_mpr = true;
+      a_neighbor->is_mpr = false;
     }
 
     /* Clear two hop neighbors coverage count/ */
@@ -273,7 +273,7 @@
   OLSR_FOR_ALL_NBR_ENTRIES(a_neighbor) {
 
     if (a_neighbor->was_mpr) {
-      a_neighbor->was_mpr = OLSR_FALSE;
+      a_neighbor->was_mpr = false;
 
       if (!a_neighbor->is_mpr) {
         retval = 1;
@@ -307,14 +307,14 @@
 /**
  *This function calculates the number of two hop neighbors
  */
-static olsr_u16_t
+static uint16_t
 olsr_calculate_two_hop_neighbors(void)
 {
   struct neighbor_entry *a_neighbor, *dup_neighbor;
   struct neighbor_2_list_entry *twohop_neighbors;
-  olsr_u16_t count = 0;
-  olsr_u16_t n_count = 0;
-  olsr_u16_t sum = 0;
+  uint16_t count = 0;
+  uint16_t n_count = 0;
+  uint16_t sum = 0;
 
   /* Clear 2 hop neighs */
   olsr_clear_two_hop_processed();
@@ -354,11 +354,11 @@
 /**
  * Adds all nodes with willingness set to WILL_ALWAYS
  */
-static olsr_u16_t
+static uint16_t
 add_will_always_nodes(void)
 {
   struct neighbor_entry *a_neighbor;
-  olsr_u16_t count = 0;
+  uint16_t count = 0;
 
 #if 0
   printf("\nAdding WILL ALWAYS nodes....\n");
@@ -389,8 +389,8 @@
 void
 olsr_calculate_mpr(void)
 {
-  olsr_u16_t two_hop_covered_count;
-  olsr_u16_t two_hop_count;
+  uint16_t two_hop_covered_count;
+  uint16_t two_hop_count;
   int i;
 
   OLSR_PRINTF(3, "\n**RECALCULATING MPR**\n\n");
@@ -446,7 +446,7 @@
   if (olsr_check_mpr_changes()) {
     OLSR_PRINTF(3, "CHANGES IN MPR SET\n");
     if (olsr_cnf->tc_redundancy > 0)
-      signal_link_changes(OLSR_TRUE);
+      signal_link_changes(true);
   }
 
 }
@@ -500,7 +500,7 @@
         if (remove) {
           struct ipaddr_str buf;
           OLSR_PRINTF(3, "MPR OPTIMIZE: removiong mpr %s\n\n", olsr_ip_to_string(&buf, &a_neighbor->neighbor_main_addr));
-          a_neighbor->is_mpr = OLSR_FALSE;
+          a_neighbor->is_mpr = false;
         }
       }
     } OLSR_FOR_ALL_NBR_ENTRIES_END(a_neighbor);
diff -r feb3d7883ff0 -r d73e73400732 src/mpr_selector_set.c
--- a/src/mpr_selector_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mpr_selector_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -46,7 +46,7 @@
 #include "scheduler.h"
 #include "net_olsr.h"
 
-static olsr_u16_t ansn;
+static uint16_t ansn;
 
 /* MPR selector list */
 static struct mpr_selector mprs_list;
@@ -67,7 +67,7 @@
   mprs_list.prev = &mprs_list;
 }
 
-olsr_u16_t
+uint16_t
 get_local_ansn(void)
 {
   return ansn;
@@ -85,10 +85,10 @@
  * Check if we(this node) is selected as a MPR by any
  * neighbors. If the list is empty we are not MPR.
  */
-olsr_bool
+bool
 olsr_is_mpr(void)
 {
-  return ((mprs_list.next == &mprs_list) ? OLSR_FALSE : OLSR_TRUE);
+  return ((mprs_list.next == &mprs_list) ? false : true);
 }
 #endif
 
@@ -114,7 +114,7 @@
 
   /* Delete entry */
   free(mpr_sel);
-  signal_link_changes(OLSR_TRUE);
+  signal_link_changes(true);
 }
 
 /**
@@ -207,7 +207,7 @@
 
   if (mprs == NULL) {
     olsr_add_mpr_selector(addr, vtime);
-    signal_link_changes(OLSR_TRUE);
+    signal_link_changes(true);
     return 1;
   }
   olsr_set_mpr_sel_timer(mprs, vtime);
diff -r feb3d7883ff0 -r d73e73400732 src/mpr_selector_set.h
--- a/src/mpr_selector_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/mpr_selector_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -54,10 +54,10 @@
 #define OLSR_MPR_SEL_JITTER 5   /* percent */
 
 #if 0
-olsr_bool olsr_is_mpr(void);
+bool olsr_is_mpr(void);
 #endif
 
-olsr_u16_t get_local_ansn(void);
+uint16_t get_local_ansn(void);
 
 void increase_local_ansn(void);
 
diff -r feb3d7883ff0 -r d73e73400732 src/neighbor_table.c
--- a/src/neighbor_table.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/neighbor_table.c	Fri Mar 13 19:16:23 2009 +0100
@@ -93,8 +93,8 @@
   free(nbr2_list);
 
   /* Set flags to recalculate the MPR set and the routing table */
-  changes_neighborhood = OLSR_TRUE;
-  changes_topology = OLSR_TRUE;
+  changes_neighborhood = true;
+  changes_topology = true;
 }
 
 /**
@@ -161,7 +161,7 @@
 olsr_delete_neighbor_table(const union olsr_ip_addr *neighbor_addr)
 {
   struct neighbor_2_list_entry *two_hop_list, *two_hop_to_delete;
-  olsr_u32_t hash;
+  uint32_t hash;
   struct neighbor_entry *entry;
 
   //printf("inserting neighbor\n");
@@ -200,7 +200,7 @@
 
   free(entry);
 
-  changes_neighborhood = OLSR_TRUE;
+  changes_neighborhood = true;
   return 1;
 
 }
@@ -215,7 +215,7 @@
 struct neighbor_entry *
 olsr_insert_neighbor_table(const union olsr_ip_addr *main_addr)
 {
-  olsr_u32_t hash;
+  uint32_t hash;
   struct neighbor_entry *new_neigh;
 
   hash = olsr_ip_hashing(main_addr);
@@ -240,8 +240,8 @@
   new_neigh->neighbor_2_list.prev = &new_neigh->neighbor_2_list;
 
   new_neigh->linkcount = 0;
-  new_neigh->is_mpr = OLSR_FALSE;
-  new_neigh->was_mpr = OLSR_FALSE;
+  new_neigh->is_mpr = false;
+  new_neigh->was_mpr = false;
 
   /* Queue */
   QUEUE_ELEM(neighbortable[hash], new_neigh);
@@ -281,7 +281,7 @@
 olsr_lookup_neighbor_table_alias(const union olsr_ip_addr *dst)
 {
   struct neighbor_entry *entry;
-  olsr_u32_t hash = olsr_ip_hashing(dst);
+  uint32_t hash = olsr_ip_hashing(dst);
 
   //printf("\nLookup %s\n", olsr_ip_to_string(&buf, dst));
   for (entry = neighbortable[hash].next; entry != &neighbortable[hash]; entry = entry->next) {
@@ -313,18 +313,18 @@
         olsr_delete_two_hop_neighbor_table(two_hop_neighbor);
       }
 
-      changes_neighborhood = OLSR_TRUE;
-      changes_topology = OLSR_TRUE;
+      changes_neighborhood = true;
+      changes_topology = true;
       if (olsr_cnf->tc_redundancy > 1)
-        signal_link_changes(OLSR_TRUE);
+        signal_link_changes(true);
     }
     entry->status = SYM;
   } else {
     if (entry->status == SYM) {
-      changes_neighborhood = OLSR_TRUE;
-      changes_topology = OLSR_TRUE;
+      changes_neighborhood = true;
+      changes_topology = true;
       if (olsr_cnf->tc_redundancy > 1)
-        signal_link_changes(OLSR_TRUE);
+        signal_link_changes(true);
     }
     /* else N_status is set to NOT_SYM */
     entry->status = NOT_SYM;
diff -r feb3d7883ff0 -r d73e73400732 src/neighbor_table.h
--- a/src/neighbor_table.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/neighbor_table.h	Fri Mar 13 19:16:23 2009 +0100
@@ -57,11 +57,11 @@
 
 struct neighbor_entry {
   union olsr_ip_addr neighbor_main_addr;
-  olsr_u8_t status;
-  olsr_u8_t willingness;
-  olsr_bool is_mpr;
-  olsr_bool was_mpr;                   /* Used to detect changes in MPR */
-  olsr_bool skip;
+  uint8_t status;
+  uint8_t willingness;
+  bool is_mpr;
+  bool was_mpr;                        /* Used to detect changes in MPR */
+  bool skip;
   int neighbor_2_nocov;
   int linkcount;
   struct neighbor_2_list_entry neighbor_2_list;
diff -r feb3d7883ff0 -r d73e73400732 src/net_olsr.c
--- a/src/net_olsr.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/net_olsr.c	Fri Mar 13 19:16:23 2009 +0100
@@ -52,7 +52,7 @@
 #include <assert.h>
 #include <limits.h>
 
-static olsr_bool disp_pack_out = OLSR_FALSE;
+static bool disp_pack_out = false;
 
 #ifdef WIN32
 #define perror(x) WinSockPError(x)
@@ -88,7 +88,7 @@
 };
 
 void
-net_set_disp_pack_out(olsr_bool val)
+net_set_disp_pack_out(bool val)
 {
   disp_pack_out = val;
 }
@@ -204,7 +204,7 @@
  *
  * @return the number of bytes currently pending
  */
-olsr_u16_t
+uint16_t
 net_output_pending(const struct interface * ifp)
 {
   return ifp->netbuf.pending;
@@ -222,7 +222,7 @@
  *  success
  */
 int
-net_outbuffer_push(struct interface *ifp, const void *data, const olsr_u16_t size)
+net_outbuffer_push(struct interface *ifp, const void *data, const uint16_t size)
 {
   if ((ifp->netbuf.pending + size) > ifp->netbuf.maxsize)
     return 0;
@@ -245,7 +245,7 @@
  *  success
  */
 int
-net_outbuffer_push_reserved(struct interface *ifp, const void *data, const olsr_u16_t size)
+net_outbuffer_push_reserved(struct interface *ifp, const void *data, const uint16_t size)
 {
   if ((ifp->netbuf.pending + size) > (ifp->netbuf.maxsize + ifp->netbuf.reserved))
     return 0;
@@ -416,7 +416,7 @@
    * link qualities for the links to our neighbours
    */
 
-  lq_tc_pending = OLSR_FALSE;
+  lq_tc_pending = false;
 
   return retval;
 }
@@ -436,7 +436,7 @@
   OLSR_PRINTF(1, "Added %s to IP deny set\n", olsr_ip_to_string(&buf, &new_entry->addr));
 }
 
-olsr_bool
+bool
 olsr_validate_address(const union olsr_ip_addr *adr)
 {
   const struct deny_address_entry *deny_entry;
@@ -445,12 +445,12 @@
     if (ipequal(adr, &deny_entry->addr)) {
       struct ipaddr_str buf;
       OLSR_PRINTF(1, "Validation of address %s failed!\n", olsr_ip_to_string(&buf, adr));
-      return OLSR_FALSE;
+      return false;
     }
     if (deny_entry == (struct deny_address_entry *)&olsr_cnf->main_addr)
       break;
   }
-  return OLSR_TRUE;
+  return true;
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/net_olsr.h
--- a/src/net_olsr.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/net_olsr.h	Fri Mar 13 19:16:23 2009 +0100
@@ -49,9 +49,9 @@
 #include <arpa/inet.h>
 #include <net/if.h>
 
-typedef int (*packet_transform_function) (olsr_u8_t *, int *);
+typedef int (*packet_transform_function) (uint8_t *, int *);
 
-void net_set_disp_pack_out(olsr_bool);
+void net_set_disp_pack_out(bool);
 
 void init_net(void);
 
@@ -61,13 +61,13 @@
 
 int net_outbuffer_bytes_left(const struct interface *);
 
-olsr_u16_t net_output_pending(const struct interface *);
+uint16_t net_output_pending(const struct interface *);
 
 int net_reserve_bufspace(struct interface *, int);
 
-int net_outbuffer_push(struct interface *, const void *, const olsr_u16_t);
+int net_outbuffer_push(struct interface *, const void *, const uint16_t);
 
-int net_outbuffer_push_reserved(struct interface *, const void *, const olsr_u16_t);
+int net_outbuffer_push_reserved(struct interface *, const void *, const uint16_t);
 
 int net_output(struct interface *);
 
@@ -77,7 +77,7 @@
 
 int del_ptf(packet_transform_function);
 
-olsr_bool olsr_validate_address(const union olsr_ip_addr *);
+bool olsr_validate_address(const union olsr_ip_addr *);
 
 void olsr_add_invalid_address(const union olsr_ip_addr *);
 
diff -r feb3d7883ff0 -r d73e73400732 src/net_os.h
--- a/src/net_os.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/net_os.h	Fri Mar 13 19:16:23 2009 +0100
@@ -85,7 +85,7 @@
 
 int check_wireless_interface(char *);
 
-olsr_bool is_if_link_up(char *);
+bool is_if_link_up(char *);
 
 int join_mcast(struct interface *, int);
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr.c
--- a/src/olsr.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr.c	Fri Mar 13 19:16:23 2009 +0100
@@ -67,10 +67,10 @@
 #include <stdarg.h>
 #include <signal.h>
 
-olsr_bool changes_topology;
-olsr_bool changes_neighborhood;
-olsr_bool changes_hna;
-olsr_bool changes_force;
+bool changes_topology;
+bool changes_neighborhood;
+bool changes_hna;
+bool changes_force;
 
 /**
  * Process changes functions
@@ -83,7 +83,7 @@
 
 static struct pcf *pcf_list;
 
-static olsr_u16_t message_seqno;
+static uint16_t message_seqno;
 union olsr_ip_addr all_zero;
 
 /**
@@ -100,7 +100,7 @@
  *
  *@return the seqno
  */
-olsr_u16_t
+uint16_t
 get_msg_seqno(void)
 {
   return message_seqno++;
@@ -189,10 +189,10 @@
     tmp_pc_list->function(changes_neighborhood, changes_topology, changes_hna);
   }
 
-  changes_neighborhood = OLSR_FALSE;
-  changes_topology = OLSR_FALSE;
-  changes_hna = OLSR_FALSE;
-  changes_force = OLSR_FALSE;
+  changes_neighborhood = false;
+  changes_topology = false;
+  changes_hna = false;
+  changes_force = false;
 }
 
 /*
@@ -202,10 +202,10 @@
 olsr_trigger_forced_update(void *unused __attribute__ ((unused)))
 {
 
-  changes_force = OLSR_TRUE;
-  changes_neighborhood = OLSR_TRUE;
-  changes_topology = OLSR_TRUE;
-  changes_hna = OLSR_TRUE;
+  changes_force = true;
+  changes_neighborhood = true;
+  changes_topology = true;
+  changes_hna = true;
 
   olsr_process_changes();
 }
@@ -218,9 +218,9 @@
 void
 olsr_init_tables(void)
 {
-  changes_topology = OLSR_FALSE;
-  changes_neighborhood = OLSR_FALSE;
-  changes_hna = OLSR_FALSE;
+  changes_topology = false;
+  changes_neighborhood = false;
+  changes_hna = false;
 
   /* Set avl tree comparator */
   if (olsr_cnf->ipsize == 4) {
@@ -412,7 +412,7 @@
  *@return a 8bit value from 0-7 representing the willingness
  */
 
-olsr_u8_t
+uint8_t
 olsr_calculate_willingness(void)
 {
   struct olsr_apm_info ainfo;
@@ -440,7 +440,7 @@
 }
 
 const char *
-olsr_msgtype_to_string(olsr_u8_t msgtype)
+olsr_msgtype_to_string(uint8_t msgtype)
 {
   static char type[20];
 
@@ -466,7 +466,7 @@
 }
 
 const char *
-olsr_link_to_string(olsr_u8_t linktype)
+olsr_link_to_string(uint8_t linktype)
 {
   static char type[20];
 
@@ -490,7 +490,7 @@
 }
 
 const char *
-olsr_status_to_string(olsr_u8_t status)
+olsr_status_to_string(uint8_t status)
 {
   static char type[20];
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr.h
--- a/src/olsr.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr.h	Fri Mar 13 19:16:23 2009 +0100
@@ -45,10 +45,10 @@
 #include "olsr_protocol.h"
 #include "interfaces.h"
 
-extern olsr_bool changes_topology;
-extern olsr_bool changes_neighborhood;
-extern olsr_bool changes_hna;
-extern olsr_bool changes_force;
+extern bool changes_topology;
+extern bool changes_neighborhood;
+extern bool changes_hna;
+extern bool changes_force;
 
 extern union olsr_ip_addr all_zero;
 
@@ -58,7 +58,7 @@
 
 void init_msg_seqno(void);
 
-olsr_u16_t get_msg_seqno(void);
+uint16_t get_msg_seqno(void);
 
 int olsr_forward_message(union olsr_message *, union olsr_ip_addr *);
 
@@ -70,13 +70,13 @@
 
 void olsr_update_willingness(void *);
 
-olsr_u8_t olsr_calculate_willingness(void);
+uint8_t olsr_calculate_willingness(void);
 
-const char *olsr_msgtype_to_string(olsr_u8_t);
+const char *olsr_msgtype_to_string(uint8_t);
 
-const char *olsr_link_to_string(olsr_u8_t);
+const char *olsr_link_to_string(uint8_t);
 
-const char *olsr_status_to_string(olsr_u8_t);
+const char *olsr_status_to_string(uint8_t);
 
 void olsr_exit(const char *, int);
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_cfg.h
--- a/src/olsr_cfg.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_cfg.h	Fri Mar 13 19:16:23 2009 +0100
@@ -55,12 +55,12 @@
 /* Default values not declared in olsr_protocol.h */
 #define DEF_POLLRATE        0.05
 #define DEF_NICCHGPOLLRT    2.5
-#define DEF_WILL_AUTO       OLSR_TRUE
-#define DEF_ALLOW_NO_INTS   OLSR_TRUE
+#define DEF_WILL_AUTO       true
+#define DEF_ALLOW_NO_INTS   true
 #define DEF_TOS             16
 #define DEF_DEBUGLVL        1
 #define DEF_IPC_CONNECTIONS 0
-#define DEF_USE_HYST        OLSR_FALSE
+#define DEF_USE_HYST        false
 #define DEF_FIB_METRIC      FIBM_FLAT
 #define DEF_LQ_LEVEL        2
 #define DEF_LQ_FISH         0
@@ -68,7 +68,7 @@
 #define DEF_LQ_DIJK_INTER   0.0
 #define DEF_LQ_NAT_THRESH   1.0
 #define DEF_LQ_AGING        0.1
-#define DEF_CLEAR_SCREEN    OLSR_FALSE
+#define DEF_CLEAR_SCREEN    false
 
 /* Bounds */
 
@@ -113,13 +113,13 @@
 
 struct olsr_lq_mult {
   union olsr_ip_addr addr;
-  olsr_u32_t value;
+  uint32_t value;
   struct olsr_lq_mult *next;
 };
 
 struct olsr_if_weight {
   int value;
-  olsr_bool fixed;
+  bool fixed;
 };
 
 struct if_config_options {
@@ -133,14 +133,14 @@
   struct olsr_msg_params mid_params;
   struct olsr_msg_params hna_params;
   struct olsr_lq_mult *lq_mult;
-  olsr_bool autodetect_chg;
+  bool autodetect_chg;
 };
 
 struct olsr_if {
   char *name;
   char *config;
-  olsr_bool configured;
-  olsr_bool host_emul;
+  bool configured;
+  bool host_emul;
   union olsr_ip_addr hemu_ip;
   struct interface *interf;
   struct if_config_options *cnf;
@@ -182,17 +182,17 @@
 
 struct olsrd_config {
   int debug_level;
-  olsr_bool no_fork;
-  olsr_bool host_emul;
+  bool no_fork;
+  bool host_emul;
   int ip_version;
-  olsr_bool allow_no_interfaces;
-  olsr_u16_t tos;
-  olsr_u8_t rttable;
-  olsr_u8_t rttable_default;
-  olsr_u8_t willingness;
-  olsr_bool willingness_auto;
+  bool allow_no_interfaces;
+  uint16_t tos;
+  uint8_t rttable;
+  uint8_t rttable_default;
+  uint8_t willingness;
+  bool willingness_auto;
   int ipc_connections;
-  olsr_bool use_hysteresis;
+  bool use_hysteresis;
   olsr_fib_metric_options fib_metric;
   struct hyst_param hysteresis_param;
   struct plugin_entry *plugins;
@@ -201,21 +201,21 @@
   struct olsr_if *interfaces;
   float pollrate;
   float nic_chgs_pollrate;
-  olsr_bool clear_screen;
-  olsr_u8_t tc_redundancy;
-  olsr_u8_t mpr_coverage;
-  olsr_u8_t lq_level;
-  olsr_u8_t lq_fish;
+  bool clear_screen;
+  uint8_t tc_redundancy;
+  uint8_t mpr_coverage;
+  uint8_t lq_level;
+  uint8_t lq_fish;
   float lq_dinter;
   float lq_aging;
   char *lq_algorithm;
-  olsr_u8_t lq_dlimit;
+  uint8_t lq_dlimit;
 
   /* Stuff set by olsrd */
-  olsr_u16_t system_tick_divider;      /* Tick resolution */
-  olsr_u8_t maxplen;                   /* maximum prefix len */
+  uint16_t system_tick_divider;        /* Tick resolution */
+  uint8_t maxplen;                     /* maximum prefix len */
   size_t ipsize;                       /* Size of address */
-  olsr_bool del_gws;                   /* Delete InternetGWs at startup */
+  bool del_gws;                        /* Delete InternetGWs at startup */
   union olsr_ip_addr main_addr;        /* Main address of this node */
   float will_int;
   float max_jitter;
@@ -241,11 +241,11 @@
  * List functions
  */
 
-  void ip_prefix_list_add(struct ip_prefix_list **, const union olsr_ip_addr *, olsr_u8_t);
+  void ip_prefix_list_add(struct ip_prefix_list **, const union olsr_ip_addr *, uint8_t);
 
-  int ip_prefix_list_remove(struct ip_prefix_list **, const union olsr_ip_addr *, olsr_u8_t);
+  int ip_prefix_list_remove(struct ip_prefix_list **, const union olsr_ip_addr *, uint8_t);
 
-  struct ip_prefix_list *ip_prefix_list_find(struct ip_prefix_list *, const union olsr_ip_addr *net, olsr_u8_t prefix_len);
+  struct ip_prefix_list *ip_prefix_list_find(struct ip_prefix_list *, const union olsr_ip_addr *net, uint8_t prefix_len);
 
 /*
  * Interface to parser
@@ -261,7 +261,7 @@
 
   int olsrd_write_cnf(struct olsrd_config *, const char *);
 
-  int olsrd_write_cnf_buf(struct olsrd_config *, char *, olsr_u32_t);
+  int olsrd_write_cnf_buf(struct olsrd_config *, char *, uint32_t);
 
   struct if_config_options *get_default_if_config(void);
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_cookie.c
--- a/src/olsr_cookie.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_cookie.c	Fri Mar 13 19:16:23 2009 +0100
@@ -152,13 +152,13 @@
 /*
  * Basic sanity checking for a passed-in cookie-id.
  */
-static olsr_bool
+static bool
 olsr_cookie_valid(olsr_cookie_t cookie_id)
 {
   if ((cookie_id < COOKIE_ID_MAX) && cookies[cookie_id]) {
-    return OLSR_TRUE;
+    return true;
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /*
@@ -210,7 +210,7 @@
   void *ptr;
   struct olsr_cookie_mem_brand *branding;
   struct list_node *free_list_node;
-  olsr_bool reuse = OLSR_FALSE;
+  bool reuse = false;
 
   /*
    * Check first if we have reusable memory.
@@ -239,7 +239,7 @@
     ptr = (void *)free_list_node;
     memset(ptr, 0, ci->ci_size);
     ci->ci_free_list_usage--;
-    reuse = OLSR_TRUE;
+    reuse = true;
   }
 
   /*
@@ -270,7 +270,7 @@
 {
   struct olsr_cookie_mem_brand *branding;
   struct list_node *free_list_node;
-  olsr_bool reuse = OLSR_FALSE;
+  bool reuse = false;
 
   branding = (struct olsr_cookie_mem_brand *)((unsigned char *)ptr + ci->ci_size);
 
@@ -294,7 +294,7 @@
     list_node_init(free_list_node);
     list_add_before(&ci->ci_free_list, free_list_node);
     ci->ci_free_list_usage++;
-    reuse = OLSR_TRUE;
+    reuse = true;
 
   } else {
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_protocol.h
--- a/src/olsr_protocol.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_protocol.h	Fri Mar 13 19:16:23 2009 +0100
@@ -61,7 +61,7 @@
 #define OLSR_IPV6_MCAST_SITE_LOCAL "ff05::15"
 #define OLSR_IPV6_MCAST_GLOBAL     "ff0e::1"
 
-#define OLSR_HEADERSIZE (sizeof(olsr_u16_t) + sizeof(olsr_u16_t))
+#define OLSR_HEADERSIZE (sizeof(uint16_t) + sizeof(uint16_t))
 
 #define OLSR_MSGHDRSZ_IPV4 12
 #define OLSR_MSGHDRSZ_IPV6 24
@@ -196,16 +196,16 @@
  *Hello info
  */
 struct hellinfo {
-  olsr_u8_t link_code;
-  olsr_u8_t reserved;
-  olsr_u16_t size;
-  olsr_u32_t neigh_addr[1];            /* neighbor IP address(es) */
+  uint8_t link_code;
+  uint8_t reserved;
+  uint16_t size;
+  uint32_t neigh_addr[1];              /* neighbor IP address(es) */
 } __attribute__ ((packed));
 
 struct hellomsg {
-  olsr_u16_t reserved;
-  olsr_u8_t htime;
-  olsr_u8_t willingness;
+  uint16_t reserved;
+  uint8_t htime;
+  uint8_t willingness;
   struct hellinfo hell_info[1];
 } __attribute__ ((packed));
 
@@ -214,16 +214,16 @@
  */
 
 struct hellinfo6 {
-  olsr_u8_t link_code;
-  olsr_u8_t reserved;
-  olsr_u16_t size;
+  uint8_t link_code;
+  uint8_t reserved;
+  uint16_t size;
   struct in6_addr neigh_addr[1];       /* neighbor IP address(es) */
 } __attribute__ ((packed));
 
 struct hellomsg6 {
-  olsr_u16_t reserved;
-  olsr_u8_t htime;
-  olsr_u8_t willingness;
+  uint16_t reserved;
+  uint8_t htime;
+  uint8_t willingness;
   struct hellinfo6 hell_info[1];
 } __attribute__ ((packed));
 
@@ -232,12 +232,12 @@
  */
 
 struct neigh_info {
-  olsr_u32_t addr;
+  uint32_t addr;
 } __attribute__ ((packed));
 
 struct olsr_tcmsg {
-  olsr_u16_t ansn;
-  olsr_u16_t reserved;
+  uint16_t ansn;
+  uint16_t reserved;
   struct neigh_info neigh[1];
 } __attribute__ ((packed));
 
@@ -250,8 +250,8 @@
 } __attribute__ ((packed));
 
 struct olsr_tcmsg6 {
-  olsr_u16_t ansn;
-  olsr_u16_t reserved;
+  uint16_t ansn;
+  uint16_t reserved;
   struct neigh_info6 neigh[1];
 } __attribute__ ((packed));
 
@@ -265,7 +265,7 @@
  * is associated whit each address?
  */
 struct midaddr {
-  olsr_u32_t addr;
+  uint32_t addr;
 } __attribute__ ((packed));
 
 struct midmsg {
@@ -287,8 +287,8 @@
  * Host and Network Association message
  */
 struct hnapair {
-  olsr_u32_t addr;
-  olsr_u32_t netmask;
+  uint32_t addr;
+  uint32_t netmask;
 } __attribute__ ((packed));
 
 struct hnamsg {
@@ -313,13 +313,13 @@
  */
 
 struct olsrmsg {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
-  olsr_u32_t originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
+  uint32_t originator;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
   union {
     struct hellomsg hello;
@@ -335,13 +335,13 @@
  */
 
 struct olsrmsg6 {
-  olsr_u8_t olsr_msgtype;
-  olsr_u8_t olsr_vtime;
-  olsr_u16_t olsr_msgsize;
+  uint8_t olsr_msgtype;
+  uint8_t olsr_vtime;
+  uint16_t olsr_msgsize;
   struct in6_addr originator;
-  olsr_u8_t ttl;
-  olsr_u8_t hopcnt;
-  olsr_u16_t seqno;
+  uint8_t ttl;
+  uint8_t hopcnt;
+  uint16_t seqno;
 
   union {
     struct hellomsg6 hello;
@@ -357,14 +357,14 @@
  */
 
 struct olsr {
-  olsr_u16_t olsr_packlen;             /* packet length */
-  olsr_u16_t olsr_seqno;
+  uint16_t olsr_packlen;               /* packet length */
+  uint16_t olsr_seqno;
   struct olsrmsg olsr_msg[1];          /* variable messages */
 } __attribute__ ((packed));
 
 struct olsr6 {
-  olsr_u16_t olsr_packlen;             /* packet length */
-  olsr_u16_t olsr_seqno;
+  uint16_t olsr_packlen;               /* packet length */
+  uint16_t olsr_seqno;
   struct olsrmsg6 olsr_msg[1];         /* variable messages */
 } __attribute__ ((packed));
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_spf.c
--- a/src/olsr_spf.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_spf.c	Fri Mar 13 19:16:23 2009 +0100
@@ -108,7 +108,7 @@
 
 #ifdef DEBUG
   OLSR_PRINTF(2, "SPF: insert candidate %s, cost %s\n", olsr_ip_to_string(&buf, &tc->addr),
-              get_linkcost_text(tc->path_cost, OLSR_FALSE, &lqbuffer));
+              get_linkcost_text(tc->path_cost, false, &lqbuffer));
 #endif
 
   avl_insert(tree, &tc->cand_tree_node, AVL_DUP);
@@ -129,7 +129,7 @@
   struct lqtextbuffer lqbuffer;
 #endif
   OLSR_PRINTF(2, "SPF: delete candidate %s, cost %s\n", olsr_ip_to_string(&buf, &tc->addr),
-              get_linkcost_text(tc->path_cost, OLSR_FALSE, &lqbuffer));
+              get_linkcost_text(tc->path_cost, false, &lqbuffer));
 #endif
 
   avl_delete(tree, &tc->cand_tree_node);
@@ -150,9 +150,9 @@
 
 #ifdef DEBUG
   OLSR_PRINTF(2, "SPF: append path %s, cost %s, via %s\n", olsr_ip_to_string(&pathbuf, &tc->addr),
-              get_linkcost_text(tc->path_cost, OLSR_FALSE, &lqbuffer), tc->next_hop ? olsr_ip_to_string(&nbuf,
-                                                                                                        &tc->next_hop->
-                                                                                                        neighbor_iface_addr) : "-");
+              get_linkcost_text(tc->path_cost, false, &lqbuffer), tc->next_hop ? olsr_ip_to_string(&nbuf,
+                                                                                                   &tc->next_hop->
+                                                                                                   neighbor_iface_addr) : "-");
 #endif
 
   list_add_before(head, &tc->path_list_node);
@@ -191,7 +191,7 @@
   struct lqtextbuffer lqbuffer;
 #endif
   OLSR_PRINTF(2, "SPF: exploring node %s, cost %s\n", olsr_ip_to_string(&buf, &tc->addr),
-              get_linkcost_text(tc->path_cost, OLSR_FALSE, &lqbuffer));
+              get_linkcost_text(tc->path_cost, false, &lqbuffer));
 #endif
 
   /*
@@ -223,7 +223,7 @@
 
 #ifdef DEBUG
     OLSR_PRINTF(2, "SPF:   exploring edge %s, cost %s\n", olsr_ip_to_string(&buf, &tc_edge->T_dest_addr),
-                get_linkcost_text(new_cost, OLSR_TRUE, &lqbuffer));
+                get_linkcost_text(new_cost, true, &lqbuffer));
 #endif
 
     /*
@@ -251,9 +251,8 @@
 
 #ifdef DEBUG
       OLSR_PRINTF(2, "SPF:   better path to %s, cost %s, via %s, hops %u\n", olsr_ip_to_string(&buf, &new_tc->addr),
-                  get_linkcost_text(new_cost, OLSR_TRUE, &lqbuffer), tc->next_hop ? olsr_ip_to_string(&nbuf,
-                                                                                                      &tc->next_hop->
-                                                                                                      neighbor_iface_addr)
+                  get_linkcost_text(new_cost, true, &lqbuffer), tc->next_hop ? olsr_ip_to_string(&nbuf,
+                                                                                                 &tc->next_hop->neighbor_iface_addr)
                   : "<none>", new_tc->hops);
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_switch/main.c
--- a/src/olsr_switch/main.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_switch/main.c	Fri Mar 13 19:16:23 2009 +0100
@@ -71,7 +71,7 @@
 static int srv_socket;
 
 #define OHS_BUFSIZE 1500
-static olsr_u8_t data_buffer[OHS_BUFSIZE];
+static uint8_t data_buffer[OHS_BUFSIZE];
 
 struct ohs_connection *ohs_conns;
 
@@ -80,7 +80,7 @@
 static struct olsrd_config olsr_cnf_data;
 struct olsrd_config *olsr_cnf = &olsr_cnf_data;
 
-olsr_u32_t logbits;
+uint32_t logbits;
 
 /* local functions */
 static int ohs_init_new_connection(int);
@@ -267,7 +267,7 @@
 static int
 ohs_init_connect_sockets(void)
 {
-  olsr_u32_t yes = 1;
+  uint32_t yes = 1;
   struct sockaddr_in sin;
 
   printf("Initiating socket TCP port %d\n", OHS_TCP_PORT);
@@ -480,7 +480,7 @@
     exit(EXIT_FAILURE);
   }
 
-  SetConsoleCtrlHandler(ohs_close, OLSR_TRUE);
+  SetConsoleCtrlHandler(ohs_close, true);
 
 #else
   signal(SIGINT, ohs_close);
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_switch/ohs_cmd.c
--- a/src/olsr_switch/ohs_cmd.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_switch/ohs_cmd.c	Fri Mar 13 19:16:23 2009 +0100
@@ -94,7 +94,7 @@
 
 #ifdef WIN32
 int
-ohs_cmd_olsrd(char *args __attribute__ ((unused)))
+ohs_cmd_olsrd(const char *args __attribute__ ((unused)))
 {
   printf("olsrd command not available in windows version\nStart instances manually\n");
   return 0;
@@ -221,7 +221,7 @@
 int
 ohs_cmd_link(const char *args)
 {
-  olsr_u8_t bi = 0, wildc_src = 0, wildc_dst = 0;
+  uint8_t bi = 0, wildc_src = 0, wildc_dst = 0;
   struct ohs_connection *src, *dst;
   struct in_addr iaddr;
   int qual;
@@ -416,12 +416,12 @@
 int
 ohs_cmd_log(const char *args)
 {
-  olsr_u8_t set = 0;
+  uint8_t set = 0;
 
   args += get_next_token(args, tok_buf, TOK_BUF_SIZE);
 
   if (strlen(tok_buf) && ((set = !strncmp(tok_buf, "set", strlen("set"))) || !strncmp(tok_buf, "unset", strlen("unset")))) {
-    olsr_u32_t new_bit = 0;
+    uint32_t new_bit = 0;
 
     args += get_next_token(args, tok_buf, TOK_BUF_SIZE);
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_switch/olsr_host_switch.h
--- a/src/olsr_switch/olsr_host_switch.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_switch/olsr_host_switch.h	Fri Mar 13 19:16:23 2009 +0100
@@ -61,21 +61,21 @@
 
 struct ohs_ip_link {
   union olsr_ip_addr dst;
-  olsr_u8_t quality;                   /* 0 - 100 */
+  uint8_t quality;                     /* 0 - 100 */
   struct ohs_ip_link *next;
 };
 
 struct ohs_connection {
   union olsr_ip_addr ip_addr;
   int socket;
-  olsr_u32_t rx;
-  olsr_u32_t tx;
-  olsr_u32_t linkcnt;
+  uint32_t rx;
+  uint32_t tx;
+  uint32_t linkcnt;
   struct ohs_ip_link *links;
   struct ohs_connection *next;
 };
 
-extern olsr_u32_t logbits;
+extern uint32_t logbits;
 
 extern struct ohs_connection *ohs_conns;
 
diff -r feb3d7883ff0 -r d73e73400732 src/olsr_types.h
--- a/src/olsr_types.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/olsr_types.h	Fri Mar 13 19:16:23 2009 +0100
@@ -47,39 +47,45 @@
 #ifndef _OLSR_TYPES_H
 #define	_OLSR_TYPES_H
 
+#if !defined linux && !defined __MacOSX__ && !defined WIN32 && !defined __FreeBSD__ && !defined __NetBSD__ && !defined __OpenBSD__
+#       error "Unsupported system"
+#endif
+
 /* types */
 #ifdef _MSC_VER
 typedef unsigned char uint8_t;
 typedef unsigned short uint16_t;
 typedef unsigned int uint32_t;
-typedef char int8_t;
-typedef short int16_t;
-typedef int int32_t;
+typedef signed char int8_t;
+typedef signed short int16_t;
+typedef signed int int32_t;
 #else
 #include <inttypes.h>
 #endif
 
-typedef enum {
-  OLSR_FALSE = 0,
-  OLSR_TRUE
-} olsr_bool;
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+
+/* we have a C99 environment */
+#include <stdbool.h>
+#elif defined __GNUC__
+
+/* we simulate a C99 environment */
+#define bool _Bool
+#define true 1
+#define false 0
+#define __bool_true_false_are_defined 1
+#endif
+
+/* add some safe-gaurds */
+#ifndef _MSC_VER
+#if !defined bool || !defined true || !defined false || !defined __bool_true_false_are_defined
+#error You have no C99-like boolean types. Please extend src/olsr_type.h!
+#endif
+#endif
 
 /* user defined cookies */
 typedef uint16_t olsr_cookie_t;
 
-#if defined linux || defined __MacOSX__ || defined WIN32 || defined __FreeBSD__ || defined __NetBSD__ || defined __OpenBSD__
-
-typedef uint8_t olsr_u8_t;
-typedef uint16_t olsr_u16_t;
-typedef uint32_t olsr_u32_t;
-typedef int8_t olsr_8_t;
-typedef int16_t olsr_16_t;
-typedef int32_t olsr_32_t;
-
-#else
-#       error "Unsupported system"
-#endif
-
 /* OpenBSD wants this here */
 #include <sys/types.h>
 
@@ -95,10 +101,10 @@
 
 struct olsr_ip_prefix {
   union olsr_ip_addr prefix;
-  olsr_u8_t prefix_len;
+  uint8_t prefix_len;
 };
 
-typedef olsr_u32_t olsr_linkcost;
+typedef uint32_t olsr_linkcost;
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/packet.c
--- a/src/packet.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/packet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -50,7 +50,7 @@
 #include "net_olsr.h"
 #include "lq_plugin.h"
 
-static olsr_bool sending_tc = OLSR_FALSE;
+static bool sending_tc = false;
 
 /**
  *Free the memory allocated for a HELLO packet.
@@ -318,7 +318,7 @@
 {
   struct tc_mpr_addr *message_mpr;
   struct neighbor_entry *entry;
-  olsr_bool entry_added = OLSR_FALSE;
+  bool entry_added = false;
 
   message->multipoint_relay_selector_address = NULL;
   message->packet_seq_number = 0;
@@ -346,7 +346,7 @@
         message_mpr->address = entry->neighbor_main_addr;
         message_mpr->next = message->multipoint_relay_selector_address;
         message->multipoint_relay_selector_address = message_mpr;
-        entry_added = OLSR_TRUE;
+        entry_added = true;
         break;
       }
     case (1):
@@ -359,7 +359,7 @@
           message_mpr->address = entry->neighbor_main_addr;
           message_mpr->next = message->multipoint_relay_selector_address;
           message->multipoint_relay_selector_address = message_mpr;
-          entry_added = OLSR_TRUE;
+          entry_added = true;
         }
         break;
       }
@@ -373,7 +373,7 @@
           message_mpr->address = entry->neighbor_main_addr;
           message_mpr->next = message->multipoint_relay_selector_address;
           message->multipoint_relay_selector_address = message_mpr;
-          entry_added = OLSR_TRUE;
+          entry_added = true;
         }
         break;
       }
@@ -383,13 +383,13 @@
   OLSR_FOR_ALL_NBR_ENTRIES_END(entry);
 
   if (entry_added) {
-    sending_tc = OLSR_TRUE;
+    sending_tc = true;
   } else {
     if (sending_tc) {
       /* Send empty TC */
       OLSR_PRINTF(3, "No more MPR selectors - will send empty TCs\n");
       set_empty_tc_timer(GET_TIMESTAMP((olsr_cnf->max_tc_vtime * 3) * MSEC_PER_SEC));
-      sending_tc = OLSR_FALSE;
+      sending_tc = false;
     }
   }
 
diff -r feb3d7883ff0 -r d73e73400732 src/packet.h
--- a/src/packet.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/packet.h	Fri Mar 13 19:16:23 2009 +0100
@@ -47,23 +47,23 @@
 #include "mantissa.h"
 
 struct hello_neighbor {
-  olsr_u8_t status;
-  olsr_u8_t link;
+  uint8_t status;
+  uint8_t link;
   union olsr_ip_addr main_address;
   union olsr_ip_addr address;
   struct hello_neighbor *next;
   olsr_linkcost cost;
-  olsr_u32_t linkquality[0];
+  uint32_t linkquality[0];
 };
 
 struct hello_message {
   olsr_reltime vtime;
   olsr_reltime htime;
   union olsr_ip_addr source_addr;
-  olsr_u16_t packet_seq_number;
-  olsr_u8_t hop_count;
-  olsr_u8_t ttl;
-  olsr_u8_t willingness;
+  uint16_t packet_seq_number;
+  uint8_t hop_count;
+  uint8_t ttl;
+  uint8_t willingness;
   struct hello_neighbor *neighbors;
 
 };
@@ -71,17 +71,17 @@
 struct tc_mpr_addr {
   union olsr_ip_addr address;
   struct tc_mpr_addr *next;
-  olsr_u32_t linkquality[0];
+  uint32_t linkquality[0];
 };
 
 struct tc_message {
   olsr_reltime vtime;
   union olsr_ip_addr source_addr;
   union olsr_ip_addr originator;
-  olsr_u16_t packet_seq_number;
-  olsr_u8_t hop_count;
-  olsr_u8_t ttl;
-  olsr_u16_t ansn;
+  uint16_t packet_seq_number;
+  uint8_t hop_count;
+  uint8_t ttl;
+  uint16_t ansn;
   struct tc_mpr_addr *multipoint_relay_selector_address;
 };
 
@@ -102,17 +102,17 @@
 struct mid_message {
   olsr_reltime vtime;
   union olsr_ip_addr mid_origaddr;     /* originator's address */
-  olsr_u8_t mid_hopcnt;                /* number of hops to destination */
-  olsr_u8_t mid_ttl;                   /* ttl */
-  olsr_u16_t mid_seqno;                /* sequence number */
+  uint8_t mid_hopcnt;                  /* number of hops to destination */
+  uint8_t mid_ttl;                     /* ttl */
+  uint16_t mid_seqno;                  /* sequence number */
   union olsr_ip_addr addr;             /* main address */
   struct mid_alias *mid_addr;          /* variable length */
 };
 
 struct unknown_message {
-  olsr_u16_t seqno;
+  uint16_t seqno;
   union olsr_ip_addr originator;
-  olsr_u8_t type;
+  uint8_t type;
 };
 
 void olsr_free_hello_packet(struct hello_message *);
diff -r feb3d7883ff0 -r d73e73400732 src/parser.c
--- a/src/parser.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/parser.c	Fri Mar 13 19:16:23 2009 +0100
@@ -77,10 +77,10 @@
 
 static char inbuf[MAXMESSAGESIZE + 1];
 
-static olsr_bool disp_pack_in = OLSR_FALSE;
+static bool disp_pack_in = false;
 
 void
-parser_set_disp_pack_in(olsr_bool val)
+parser_set_disp_pack_in(bool val)
 {
   disp_pack_in = val;
 }
@@ -101,7 +101,7 @@
 }
 
 void
-olsr_parser_add_function(parse_function * function, olsr_u32_t type)
+olsr_parser_add_function(parse_function * function, uint32_t type)
 {
   struct parse_function_entry *new_entry;
 
@@ -121,7 +121,7 @@
 }
 
 int
-olsr_parser_remove_function(parse_function * function, olsr_u32_t type)
+olsr_parser_remove_function(parse_function * function, uint32_t type)
 {
   struct parse_function_entry *entry, *prev;
 
@@ -302,7 +302,7 @@
   }
 
   for (; count > 0; m = (union olsr_message *)((char *)m + (msgsize))) {
-    olsr_bool forward = OLSR_TRUE;
+    bool forward = true;
 
     if (count < MIN_PACKET_SIZE(olsr_cnf->ip_version))
       break;
@@ -351,7 +351,7 @@
       /* Promiscuous or exact match */
       if ((entry->type == PROMISCUOUS) || (entry->type == m->v4.olsr_msgtype)) {
         if (!entry->function(m, in_if, from_addr))
-          forward = OLSR_FALSE;
+          forward = false;
       }
       entry = entry->next;
     }
@@ -472,7 +472,7 @@
   socklen_t fromlen;
   struct interface *olsr_in_if;
   union olsr_ip_addr from_addr;
-  olsr_u16_t pcklen;
+  uint16_t pcklen;
   struct preprocessor_function_entry *entry;
   char *packet;
 
diff -r feb3d7883ff0 -r d73e73400732 src/parser.h
--- a/src/parser.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/parser.h	Fri Mar 13 19:16:23 2009 +0100
@@ -48,10 +48,10 @@
 #define PROMISCUOUS 0xffffffff
 
 /* Function returns false if the message should not be forwarded */
-typedef olsr_bool parse_function(union olsr_message *, struct interface *, union olsr_ip_addr *);
+typedef bool parse_function(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 struct parse_function_entry {
-  olsr_u32_t type;                     /* If set to PROMISCUOUS all messages will be received */
+  uint32_t type;                       /* If set to PROMISCUOUS all messages will be received */
   parse_function *function;
   struct parse_function_entry *next;
 };
@@ -70,7 +70,7 @@
   struct packetparser_function_entry *next;
 };
 
-void parser_set_disp_pack_in(olsr_bool);
+void parser_set_disp_pack_in(bool);
 
 void olsr_init_parser(void);
 
@@ -78,9 +78,9 @@
 
 void olsr_input_hostemu(int);
 
-void olsr_parser_add_function(parse_function, olsr_u32_t);
+void olsr_parser_add_function(parse_function, uint32_t);
 
-int olsr_parser_remove_function(parse_function, olsr_u32_t);
+int olsr_parser_remove_function(parse_function, uint32_t);
 
 void olsr_preprocessor_add_function(preprocessor_function);
 
diff -r feb3d7883ff0 -r d73e73400732 src/print_packet.c
--- a/src/print_packet.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/print_packet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -47,25 +47,25 @@
 #include "lq_packet.h"
 #include "net_olsr.h"
 
-static void print_messagedump(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_messagedump(FILE *, uint8_t *, int16_t);
 
-static void print_midmsg(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_midmsg(FILE *, uint8_t *, int16_t);
 
-static void print_hnamsg(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_hnamsg(FILE *, uint8_t *, int16_t);
 
-static void print_olsr_tcmsg(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_olsr_tcmsg(FILE *, uint8_t *, int16_t);
 
-static void print_olsr_tcmsg_lq(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_olsr_tcmsg_lq(FILE *, uint8_t *, int16_t);
 
-static void print_hellomsg(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_hellomsg(FILE *, uint8_t *, int16_t);
 
-static void print_hellomsg_lq(FILE *, olsr_u8_t *, olsr_16_t);
+static void print_hellomsg_lq(FILE *, uint8_t *, int16_t);
 
 /* Entire packet */
-olsr_8_t
-print_olsr_serialized_packet(FILE * handle, union olsr_packet *pkt, olsr_u16_t size, union olsr_ip_addr *from_addr)
+int8_t
+print_olsr_serialized_packet(FILE * handle, union olsr_packet *pkt, uint16_t size, union olsr_ip_addr *from_addr)
 {
-  olsr_16_t remainsize = size - OLSR_HEADERSIZE;
+  int16_t remainsize = size - OLSR_HEADERSIZE;
   union olsr_message *msg;
   struct ipaddr_str buf;
 
@@ -92,7 +92,7 @@
 }
 
 /* Single message */
-olsr_8_t
+int8_t
 print_olsr_serialized_message(FILE * handle, union olsr_message * msg)
 {
   struct ipaddr_str buf;
@@ -108,32 +108,32 @@
   switch (msg->v4.olsr_msgtype) {
     /* Print functions for individual messagetypes */
   case (MID_MESSAGE):
-    print_midmsg(handle, (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+    print_midmsg(handle, (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                  ntohs(msg->v4.olsr_msgsize));
     break;
   case (HNA_MESSAGE):
-    print_hnamsg(handle, (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+    print_hnamsg(handle, (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                  ntohs(msg->v4.olsr_msgsize));
     break;
   case (TC_MESSAGE):
-    print_olsr_tcmsg(handle, (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+    print_olsr_tcmsg(handle, (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                      ntohs(msg->v4.olsr_msgsize));
     break;
   case (LQ_TC_MESSAGE):
     print_olsr_tcmsg_lq(handle,
-                        (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+                        (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                         ntohs(msg->v4.olsr_msgsize));
     break;
   case (HELLO_MESSAGE):
-    print_hellomsg(handle, (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+    print_hellomsg(handle, (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                    ntohs(msg->v4.olsr_msgsize));
     break;
   case (LQ_HELLO_MESSAGE):
-    print_hellomsg_lq(handle, (olsr_cnf->ip_version == AF_INET) ? (olsr_u8_t *) & msg->v4.message : (olsr_u8_t *) & msg->v6.message,
+    print_hellomsg_lq(handle, (olsr_cnf->ip_version == AF_INET) ? (uint8_t *) & msg->v4.message : (uint8_t *) & msg->v6.message,
                       ntohs(msg->v4.olsr_msgsize));
     break;
   default:
-    print_messagedump(handle, (olsr_u8_t *) msg, ntohs(msg->v4.olsr_msgsize));
+    print_messagedump(handle, (uint8_t *) msg, ntohs(msg->v4.olsr_msgsize));
   }
 
   fprintf(handle, "   --------------------------------------\n\n");
@@ -141,7 +141,7 @@
 }
 
 static void
-print_messagedump(FILE * handle, olsr_u8_t * msg, olsr_16_t size)
+print_messagedump(FILE * handle, uint8_t * msg, int16_t size)
 {
   int i, x = 0;
 
@@ -161,7 +161,7 @@
 }
 
 static void
-print_hellomsg(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_hellomsg(FILE * handle, uint8_t * data, int16_t totsize)
 {
   union olsr_ip_addr *haddr;
   int hellosize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
@@ -213,7 +213,7 @@
 }
 
 static void
-print_hellomsg_lq(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_hellomsg_lq(FILE * handle, uint8_t * data, int16_t totsize)
 {
   union olsr_ip_addr *haddr;
   int hellosize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
@@ -238,7 +238,7 @@
       for (haddr = (union olsr_ip_addr *)&hinf->neigh_addr; (char *)haddr < (char *)hinf + ntohs(hinf->size);
            haddr = (union olsr_ip_addr *)&haddr->v6.s6_addr[8]) {
         struct ipaddr_str buf;
-        olsr_u8_t *quality = (olsr_u8_t *) haddr + olsr_cnf->ipsize;
+        uint8_t *quality = (uint8_t *) haddr + olsr_cnf->ipsize;
         fprintf(handle, "    ++ %s\n", olsr_ip_to_string(&buf, haddr));
         fprintf(handle, "    ++ LQ = %d, RLQ = %d\n", quality[0], quality[1]);
       }
@@ -258,7 +258,7 @@
 
       for (haddr = (union olsr_ip_addr *)hinf6->neigh_addr; (char *)haddr < (char *)hinf6 + ntohs(hinf6->size) + 4; haddr++) {
         struct ipaddr_str buf;
-        olsr_u8_t *quality = (olsr_u8_t *) haddr + olsr_cnf->ipsize;
+        uint8_t *quality = (uint8_t *) haddr + olsr_cnf->ipsize;
         fprintf(handle, "    ++ %s\n", olsr_ip_to_string(&buf, haddr));
         fprintf(handle, "    ++ LQ = %d, RLQ = %d\n", quality[0], quality[1]);
       }
@@ -268,7 +268,7 @@
 }
 
 static void
-print_olsr_tcmsg_lq(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_olsr_tcmsg_lq(FILE * handle, uint8_t * data, int16_t totsize)
 {
   int remsize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
 
@@ -291,7 +291,7 @@
 }
 
 static void
-print_olsr_tcmsg(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_olsr_tcmsg(FILE * handle, uint8_t * data, int16_t totsize)
 {
   int remsize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
 
@@ -311,7 +311,7 @@
 }
 
 static void
-print_hnamsg(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_hnamsg(FILE * handle, uint8_t * data, int16_t totsize)
 {
   int remsize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
 
@@ -328,7 +328,7 @@
 }
 
 static void
-print_midmsg(FILE * handle, olsr_u8_t * data, olsr_16_t totsize)
+print_midmsg(FILE * handle, uint8_t * data, int16_t totsize)
 {
   int remsize = totsize - ((olsr_cnf->ip_version == AF_INET) ? OLSR_MSGHDRSZ_IPV4 : OLSR_MSGHDRSZ_IPV6);
 
diff -r feb3d7883ff0 -r d73e73400732 src/print_packet.h
--- a/src/print_packet.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/print_packet.h	Fri Mar 13 19:16:23 2009 +0100
@@ -46,9 +46,9 @@
 #include "olsr_protocol.h"
 #include <stdio.h>
 
-olsr_8_t print_olsr_serialized_packet(FILE *, union olsr_packet *, olsr_u16_t, union olsr_ip_addr *);
+int8_t print_olsr_serialized_packet(FILE *, union olsr_packet *, uint16_t, union olsr_ip_addr *);
 
-olsr_8_t print_olsr_serialized_message(FILE *, union olsr_message *);
+int8_t print_olsr_serialized_message(FILE *, union olsr_message *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/process_package.c
--- a/src/process_package.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/process_package.c	Fri Mar 13 19:16:23 2009 +0100
@@ -61,7 +61,7 @@
 
 static void linking_this_2_entries(struct neighbor_entry *, struct neighbor_2_entry *, olsr_reltime);
 
-static olsr_bool lookup_mpr_status(const struct hello_message *, const struct interface *);
+static bool lookup_mpr_status(const struct hello_message *, const struct interface *);
 
 /**
  *Processes an list of neighbors from an incoming HELLO message.
@@ -140,8 +140,8 @@
 #ifdef DEBUG
           OLSR_PRINTF(5, "Adding 2 hop neighbor %s\n\n", olsr_ip_to_string(&buf, &message_neighbors->address));
 #endif
-          changes_neighborhood = OLSR_TRUE;
-          changes_topology = OLSR_TRUE;
+          changes_neighborhood = true;
+          changes_topology = true;
 
           two_hop_neighbor = olsr_malloc(sizeof(struct neighbor_2_entry), "Process HELLO");
 
@@ -160,8 +160,8 @@
           /*
              linking to this two_hop_neighbor entry
            */
-          changes_neighborhood = OLSR_TRUE;
-          changes_topology = OLSR_TRUE;
+          changes_neighborhood = true;
+          changes_topology = true;
 
           linking_this_2_entries(neighbor, two_hop_neighbor, message->vtime);
         }
@@ -240,8 +240,8 @@
                 walker->saved_path_linkcost = new_path_linkcost;
 
                 if (olsr_cnf->lq_dlimit > 0) {
-                  changes_neighborhood = OLSR_TRUE;
-                  changes_topology = OLSR_TRUE;
+                  changes_neighborhood = true;
+                  changes_topology = true;
                 }
 
                 else
@@ -303,7 +303,7 @@
  *
  *@return 1 if we are selected as MPR 0 if not
  */
-static olsr_bool
+static bool
 lookup_mpr_status(const struct hello_message *message, const struct interface *in_if)
 {
   struct hello_neighbor *neighbors;
@@ -314,21 +314,21 @@
                                                                                   &in_if->int6_addr.sin6_addr)) {
 
       if (neighbors->link == SYM_LINK && neighbors->status == MPR_NEIGH) {
-        return OLSR_TRUE;
+        return true;
       }
       break;
     }
   }
   /* Not found */
-  return OLSR_FALSE;
+  return false;
 }
 
 static int
 deserialize_hello(struct hello_message *hello, const void *ser)
 {
   const unsigned char *limit;
-  olsr_u8_t type;
-  olsr_u16_t size;
+  uint8_t type;
+  uint16_t size;
 
   const unsigned char *curr = ser;
   pkt_get_u8(&curr, &type);
@@ -372,21 +372,21 @@
   return 0;
 }
 
-olsr_bool
+bool
 olsr_input_hello(union olsr_message * ser, struct interface * inif, union olsr_ip_addr * from)
 {
   struct hello_message hello;
 
   if (ser == NULL) {
-    return OLSR_FALSE;
+    return false;
   }
   if (deserialize_hello(&hello, ser) != 0) {
-    return OLSR_FALSE;
+    return false;
   }
   olsr_hello_tap(&hello, inif, from);
 
   /* Do not forward hello messages */
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -460,8 +460,8 @@
      *If willingness changed - recalculate
      */
     neighbor->willingness = message->willingness;
-    changes_neighborhood = OLSR_TRUE;
-    changes_topology = OLSR_TRUE;
+    changes_neighborhood = true;
+    changes_topology = true;
   }
 
   /* Don't register neighbors of neighbors that announces WILL_NEVER */
diff -r feb3d7883ff0 -r d73e73400732 src/process_package.h
--- a/src/process_package.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/process_package.h	Fri Mar 13 19:16:23 2009 +0100
@@ -46,7 +46,7 @@
 #include "packet.h"
 #include "neighbor_table.h"
 
-olsr_bool olsr_input_hello(union olsr_message *, struct interface *, union olsr_ip_addr *);
+bool olsr_input_hello(union olsr_message *, struct interface *, union olsr_ip_addr *);
 
 void olsr_init_package_process(void);
 
diff -r feb3d7883ff0 -r d73e73400732 src/process_routes.c
--- a/src/process_routes.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/process_routes.c	Fri Mar 13 19:16:23 2009 +0100
@@ -68,11 +68,11 @@
  * Called before enqueuing a change/delete operation
  *
  */
-olsr_u8_t
+uint8_t
 olsr_rt_flags(const struct rt_entry *rt)
 {
   const struct rt_nexthop *nh;
-  olsr_u8_t flags = RTF_UP;
+  uint8_t flags = RTF_UP;
 
   /* destination is host */
   if (rt->rt_dst.prefix_len == olsr_cnf->maxplen) {
@@ -160,7 +160,7 @@
 olsr_delete_kernel_route(struct rt_entry *rt)
 {
   if (!olsr_cnf->host_emul) {
-    olsr_16_t error = olsr_cnf->ip_version == AF_INET ? olsr_delroute_function(rt) : olsr_delroute6_function(rt);
+    int16_t error = olsr_cnf->ip_version == AF_INET ? olsr_delroute_function(rt) : olsr_delroute6_function(rt);
 
     if (error < 0) {
       const char *const err_msg = strerror(errno);
@@ -182,7 +182,7 @@
 {
 
   if (!olsr_cnf->host_emul) {
-    olsr_16_t error = (olsr_cnf->ip_version == AF_INET) ? olsr_addroute_function(rt) : olsr_addroute6_function(rt);
+    int16_t error = (olsr_cnf->ip_version == AF_INET) ? olsr_addroute_function(rt) : olsr_addroute6_function(rt);
 
     if (error < 0) {
       const char *const err_msg = strerror(errno);
diff -r feb3d7883ff0 -r d73e73400732 src/process_routes.h
--- a/src/process_routes.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/process_routes.h	Fri Mar 13 19:16:23 2009 +0100
@@ -56,7 +56,7 @@
 void olsr_update_rib_routes(void);
 void olsr_update_kernel_routes(void);
 void olsr_delete_all_kernel_routes(void);
-olsr_u8_t olsr_rt_flags(const struct rt_entry *);
+uint8_t olsr_rt_flags(const struct rt_entry *);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/routing_table.c
--- a/src/routing_table.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/routing_table.c	Fri Mar 13 19:16:23 2009 +0100
@@ -106,8 +106,8 @@
 {
   const struct olsr_ip_prefix *pfx1 = prefix1;
   const struct olsr_ip_prefix *pfx2 = prefix2;
-  const olsr_u32_t addr1 = ntohl(pfx1->prefix.v4.s_addr);
-  const olsr_u32_t addr2 = ntohl(pfx2->prefix.v4.s_addr);
+  const uint32_t addr1 = ntohl(pfx1->prefix.v4.s_addr);
+  const uint32_t addr2 = ntohl(pfx2->prefix.v4.s_addr);
 
   /* prefix */
   if (addr1 < addr2) {
@@ -257,7 +257,7 @@
  * Alloc and key a new rt_path.
  */
 static struct rt_path *
-olsr_alloc_rt_path(struct tc_entry *tc, struct olsr_ip_prefix *prefix, olsr_u8_t origin)
+olsr_alloc_rt_path(struct tc_entry *tc, struct olsr_ip_prefix *prefix, uint8_t origin)
 {
   struct rt_path *rtp = olsr_cookie_malloc(rtp_mem_cookie);
 
@@ -374,19 +374,19 @@
 /**
  * Check if there is an interface or gateway change.
  */
-olsr_bool
+bool
 olsr_nh_change(const struct rt_nexthop *nh1, const struct rt_nexthop *nh2)
 {
   if (!ipequal(&nh1->gateway, &nh2->gateway) || (nh1->iif_index != nh2->iif_index)) {
-    return OLSR_TRUE;
+    return true;
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
  * Check if there is a hopcount change.
  */
-olsr_bool
+bool
 olsr_hopcount_change(const struct rt_metric * met1, const struct rt_metric * met2)
 {
   return (met1->hops != met2->hops);
@@ -399,7 +399,7 @@
  * for deletes this is the metric of the route that got stored in the rt_entry,
  * during route installation.
  */
-olsr_u8_t
+uint8_t
 olsr_fib_metric(const struct rt_metric * met)
 {
   if (FIBM_CORRECT == olsr_cnf->fib_metric) {
@@ -432,7 +432,7 @@
  * returns TRUE if the first path is better
  * than the second one, FALSE otherwise.
  */
-static olsr_bool
+static bool
 olsr_cmp_rtp(const struct rt_path *rtp1, const struct rt_path *rtp2, const struct rt_path *inetgw)
 {
   olsr_linkcost etx1 = rtp1->rtp_metric.cost;
@@ -444,21 +444,21 @@
 
   /* etx comes first */
   if (etx1 < etx2) {
-    return OLSR_TRUE;
+    return true;
   }
 
   /* hopcount is next tie breaker */
   if ((etx1 == etx2) && (rtp1->rtp_metric.hops < rtp2->rtp_metric.hops)) {
-    return OLSR_TRUE;
+    return true;
   }
 
   /* originator (which is guaranteed to be unique) is final tie breaker */
   if ((rtp1->rtp_metric.hops == rtp2->rtp_metric.hops)
       && (memcmp(&rtp1->rtp_originator, &rtp2->rtp_originator, olsr_cnf->ipsize) == -1)) {
-    return OLSR_TRUE;
+    return true;
   }
 
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -467,7 +467,7 @@
  * returns TRUE if the first entry is better
  * than the second one, FALSE otherwise.
  */
-olsr_bool
+bool
 olsr_cmp_rt(const struct rt_entry * rt1, const struct rt_entry * rt2)
 {
   return olsr_cmp_rtp(rt1->rt_best, rt2->rt_best, NULL);
@@ -562,7 +562,7 @@
 #endif
 
     /* overload the hna change bit for flagging a prefix change */
-    changes_hna = OLSR_TRUE;
+    changes_hna = true;
 
   } else {
     rtp = rtp_prefix_tree2rtp(node);
@@ -616,7 +616,7 @@
 #endif
 
     /* overload the hna change bit for flagging a prefix change */
-    changes_hna = OLSR_TRUE;
+    changes_hna = true;
   }
 }
 
@@ -649,7 +649,7 @@
   snprintf(buff, sizeof(buff), "%s/%u from %s via %s, " "cost %s, metric %u, v %u",
            olsr_ip_to_string(&prefixstr, &rt->rt_dst.prefix), rt->rt_dst.prefix_len, olsr_ip_to_string(&origstr,
                                                                                                        &rtp->rtp_originator),
-           olsr_ip_to_string(&gwstr, &rtp->rtp_nexthop.gateway), get_linkcost_text(rtp->rtp_metric.cost, OLSR_TRUE, &lqbuffer),
+           olsr_ip_to_string(&gwstr, &rtp->rtp_nexthop.gateway), get_linkcost_text(rtp->rtp_metric.cost, true, &lqbuffer),
            rtp->rtp_metric.hops, rtp->rtp_version);
 
   return buff;
@@ -682,10 +682,10 @@
     for (rtp_tree_node = avl_walk_first(&rt->rt_path_tree); rtp_tree_node != NULL; rtp_tree_node = avl_walk_next(rtp_tree_node)) {
       struct rt_path *rtp = rtp_tree2rtp(rtp_tree_node);
       OLSR_PRINTF(6, "\tfrom %s, cost %s, metric %u, via %s, %s, v %u\n", olsr_ip_to_string(&origstr, &rtp->rtp_originator),
-                  get_linkcost_text(rtp->rtp_metric.cost, OLSR_TRUE, &lqbuffer), rtp->rtp_metric.hops, olsr_ip_to_string(&gwstr,
-                                                                                                                         &rtp->
-                                                                                                                         rtp_nexthop.
-                                                                                                                         gateway),
+                  get_linkcost_text(rtp->rtp_metric.cost, true, &lqbuffer), rtp->rtp_metric.hops, olsr_ip_to_string(&gwstr,
+                                                                                                                    &rtp->
+                                                                                                                    rtp_nexthop.
+                                                                                                                    gateway),
                   if_ifwithindex_name(rt->rt_nexthop.iif_index), rtp->rtp_version);
     }
   }
diff -r feb3d7883ff0 -r d73e73400732 src/routing_table.h
--- a/src/routing_table.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/routing_table.h	Fri Mar 13 19:16:23 2009 +0100
@@ -66,7 +66,7 @@
 /* a composite metric is used for path selection */
 struct rt_metric {
   olsr_linkcost cost;
-  olsr_u32_t hops;
+  uint32_t hops;
 };
 
 /* a nexthop is a pointer to a gateway router plus an interface */
@@ -112,8 +112,8 @@
   union olsr_ip_addr rtp_originator;   /* originator of the route */
   struct avl_node rtp_prefix_tree_node; /* tc entry rtp node */
   struct olsr_ip_prefix rtp_dst;       /* the prefix */
-  olsr_u32_t rtp_version;              /* for detection of outdated rt_paths */
-  olsr_u8_t rtp_origin;                /* internal, MID or HNA */
+  uint32_t rtp_version;                /* for detection of outdated rt_paths */
+  uint8_t rtp_origin;                  /* internal, MID or HNA */
 };
 
 AVLNODE2STRUCT(rtp_tree2rtp, struct rt_path, rtp_tree_node);
@@ -183,13 +183,13 @@
   struct {
     struct sockaddr rt_dst;
     struct sockaddr rt_gateway;
-    olsr_u32_t metric;
+    uint32_t metric;
   } v4;
 
   struct {
     struct in6_addr rtmsg_dst;
     struct in6_addr rtmsg_gateway;
-    olsr_u32_t rtmsg_metric;
+    uint32_t rtmsg_metric;
   } v6;
 };
 
@@ -205,10 +205,10 @@
 int avl_comp_ipv6_prefix(const void *, const void *);
 
 void olsr_rt_best(struct rt_entry *);
-olsr_bool olsr_nh_change(const struct rt_nexthop *, const struct rt_nexthop *);
-olsr_bool olsr_hopcount_change(const struct rt_metric *, const struct rt_metric *);
-olsr_bool olsr_cmp_rt(const struct rt_entry *, const struct rt_entry *);
-olsr_u8_t olsr_fib_metric(const struct rt_metric *);
+bool olsr_nh_change(const struct rt_nexthop *, const struct rt_nexthop *);
+bool olsr_hopcount_change(const struct rt_metric *, const struct rt_metric *);
+bool olsr_cmp_rt(const struct rt_entry *, const struct rt_entry *);
+uint8_t olsr_fib_metric(const struct rt_metric *);
 
 char *olsr_rt_to_string(const struct rt_entry *);
 char *olsr_rtp_to_string(const struct rt_path *);
diff -r feb3d7883ff0 -r d73e73400732 src/scheduler.c
--- a/src/scheduler.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/scheduler.c	Fri Mar 13 19:16:23 2009 +0100
@@ -81,7 +81,7 @@
 {
   struct timespec remainder_spec, sleeptime_spec;
   struct timeval sleeptime_val, time_used, next_interval;
-  olsr_u32_t next_interval_usec;
+  uint32_t next_interval_usec;
   unsigned long milliseconds_used;
 
   /* Calculate next planned scheduler invocation */
@@ -144,7 +144,7 @@
     if (link_changes) {
       OLSR_PRINTF(3, "ANSN UPDATED %d\n\n", get_local_ansn());
       increase_local_ansn();
-      link_changes = OLSR_FALSE;
+      link_changes = false;
     }
 
     /* looping trough interfaces and emmitting pending data */
@@ -188,7 +188,7 @@
  * @return the absolute timer in system clock tick units
  */
 static clock_t
-olsr_jitter(unsigned int rel_time, olsr_u8_t jitter_pct, unsigned int random)
+olsr_jitter(unsigned int rel_time, uint8_t jitter_pct, unsigned int random)
 {
   unsigned int jitter_time;
 
@@ -521,7 +521,7 @@
  * @return a pointer to the created entry
  */
 struct timer_entry *
-olsr_start_timer(unsigned int rel_time, olsr_u8_t jitter_pct, olsr_bool periodical, void (*timer_cb_function) (void *),
+olsr_start_timer(unsigned int rel_time, uint8_t jitter_pct, bool periodical, void (*timer_cb_function) (void *),
                  void *context, olsr_cookie_t cookie)
 {
   struct timer_entry *timer;
@@ -598,7 +598,7 @@
  * @return nada
  */
 void
-olsr_change_timer(struct timer_entry *timer, unsigned int rel_time, olsr_u8_t jitter_pct, olsr_bool periodical)
+olsr_change_timer(struct timer_entry *timer, unsigned int rel_time, uint8_t jitter_pct, bool periodical)
 {
 
   /* Sanity check. */
@@ -636,7 +636,7 @@
  * terminated.
  */
 void
-olsr_set_timer(struct timer_entry **timer_ptr, unsigned int rel_time, olsr_u8_t jitter_pct, olsr_bool periodical,
+olsr_set_timer(struct timer_entry **timer_ptr, unsigned int rel_time, uint8_t jitter_pct, bool periodical,
                void (*timer_cb_function) (void *), void *context, olsr_cookie_t cookie)
 {
 
diff -r feb3d7883ff0 -r d73e73400732 src/scheduler.h
--- a/src/scheduler.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/scheduler.h	Fri Mar 13 19:16:23 2009 +0100
@@ -69,8 +69,8 @@
   clock_t timer_clock;                 /* when timer shall fire (absolute time) */
   unsigned int timer_period;           /* set for periodical timers (relative time) */
   olsr_cookie_t timer_cookie;          /* used for diag stuff */
-  olsr_u8_t timer_jitter_pct;          /* the jitter expressed in percent */
-  olsr_u8_t timer_flags;               /* misc flags */
+  uint8_t timer_jitter_pct;            /* the jitter expressed in percent */
+  uint8_t timer_flags;                 /* misc flags */
   unsigned int timer_random;           /* cache random() result for performance reasons */
   void (*timer_cb) (void *);           /* callback function */
   void *timer_cb_context;              /* context pointer */
@@ -91,9 +91,9 @@
 /* Timers */
 void olsr_init_timers(void);
 void olsr_walk_timers(clock_t *);
-void olsr_set_timer(struct timer_entry **, unsigned int, olsr_u8_t, olsr_bool, void (*)(void *), void *, olsr_cookie_t);
-struct timer_entry *olsr_start_timer(unsigned int, olsr_u8_t, olsr_bool, void (*)(void *), void *, olsr_cookie_t);
-void olsr_change_timer(struct timer_entry *, unsigned int, olsr_u8_t, olsr_bool);
+void olsr_set_timer(struct timer_entry **, unsigned int, uint8_t, bool, void (*)(void *), void *, olsr_cookie_t);
+struct timer_entry *olsr_start_timer(unsigned int, uint8_t, bool, void (*)(void *), void *, olsr_cookie_t);
+void olsr_change_timer(struct timer_entry *, unsigned int, uint8_t, bool);
 void olsr_stop_timer(struct timer_entry *);
 
 /* Printing timestamps */
diff -r feb3d7883ff0 -r d73e73400732 src/tc_set.c
--- a/src/tc_set.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/tc_set.c	Fri Mar 13 19:16:23 2009 +0100
@@ -89,38 +89,38 @@
 /* Enlarges the value window for upcoming ansn/seqno to be accepted */
 #define TC_SEQNO_WINDOW_MULT 8
 
-static olsr_bool
-olsr_seq_inrange_low(int beg, int end, olsr_u16_t seq)
+static bool
+olsr_seq_inrange_low(int beg, int end, uint16_t seq)
 {
   if (beg < 0) {
-    if (seq >= (olsr_u16_t) beg || seq < end) {
-      return OLSR_TRUE;
+    if (seq >= (uint16_t) beg || seq < end) {
+      return true;
     }
   } else if (end >= 0x10000) {
-    if (seq >= beg || seq < (olsr_u16_t) end) {
-      return OLSR_TRUE;
+    if (seq >= beg || seq < (uint16_t) end) {
+      return true;
     }
   } else if (seq >= beg && seq < end) {
-    return OLSR_TRUE;
+    return true;
   }
-  return OLSR_FALSE;
+  return false;
 }
 
-static olsr_bool
-olsr_seq_inrange_high(int beg, int end, olsr_u16_t seq)
+static bool
+olsr_seq_inrange_high(int beg, int end, uint16_t seq)
 {
   if (beg < 0) {
-    if (seq > (olsr_u16_t) beg || seq <= end) {
-      return OLSR_TRUE;
+    if (seq > (uint16_t) beg || seq <= end) {
+      return true;
     }
   } else if (end >= 0x10000) {
-    if (seq > beg || seq <= (olsr_u16_t) end) {
-      return OLSR_TRUE;
+    if (seq > beg || seq <= (uint16_t) end) {
+      return true;
     }
   } else if (seq > beg && seq <= end) {
-    return OLSR_TRUE;
+    return true;
   }
-  return OLSR_FALSE;
+  return false;
 }
 
 /**
@@ -231,7 +231,7 @@
    * The old entry for ourselves is gone, generate a new one and trigger SPF.
    */
   tc_myself = olsr_add_tc_entry(&olsr_cnf->main_addr);
-  changes_topology = OLSR_TRUE;
+  changes_topology = true;
 }
 
 /*
@@ -346,7 +346,7 @@
 
   snprintf(buf, sizeof(buf), "%s > %s, cost (%6s) %s", olsr_ip_to_string(&addrbuf, &tc->addr),
            olsr_ip_to_string(&dstbuf, &tc_edge->T_dest_addr), get_tc_edge_entry_text(tc_edge, '/', &lqbuffer1),
-           get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer2));
+           get_linkcost_text(tc_edge->cost, false, &lqbuffer2));
 
   return buf;
 }
@@ -365,7 +365,7 @@
   tc->validity_timer = NULL;
 
   olsr_delete_tc_entry(tc);
-  changes_topology = OLSR_TRUE;
+  changes_topology = true;
 }
 
 /**
@@ -382,7 +382,7 @@
   tc->edge_gc_timer = NULL;
 
   if (olsr_delete_outdated_tc_edges(tc)) {
-    changes_topology = OLSR_TRUE;
+    changes_topology = true;
   }
 }
 
@@ -393,7 +393,7 @@
  *
  * @return 1 if the change of the etx value was relevant
  */
-olsr_bool
+bool
 olsr_calc_tc_edge_entry_etx(struct tc_edge_entry *tc_edge)
 {
   olsr_linkcost old;
@@ -418,7 +418,7 @@
  * @return a pointer to the created entry
  */
 struct tc_edge_entry *
-olsr_add_tc_edge_entry(struct tc_entry *tc, union olsr_ip_addr *addr, olsr_u16_t ansn)
+olsr_add_tc_edge_entry(struct tc_entry *tc, union olsr_ip_addr *addr, uint16_t ansn)
 {
 #ifdef DEBUG
   struct ipaddr_str buf;
@@ -521,11 +521,11 @@
  * @param tc the entry to delete edges from
  * @return TRUE if any destinations were deleted, FALSE if not
  */
-olsr_bool
+bool
 olsr_delete_outdated_tc_edges(struct tc_entry *tc)
 {
   struct tc_edge_entry *tc_edge;
-  olsr_bool retval = OLSR_FALSE;
+  bool retval = false;
 
 #if 0
   OLSR_PRINTF(5, "TC: deleting outdated TC-edge entries\n");
@@ -534,7 +534,7 @@
   OLSR_FOR_ALL_TC_EDGE_ENTRIES(tc, tc_edge) {
     if (SEQNO_GREATER_THAN(tc->ansn, tc_edge->ansn)) {
       olsr_delete_tc_edge_entry(tc_edge);
-      retval = OLSR_TRUE;
+      retval = true;
     }
   }
   OLSR_FOR_ALL_TC_EDGE_ENTRIES_END(tc, tc_edge);
@@ -551,8 +551,7 @@
  * @return 1 if any destinations were deleted 0 if not
  */
 static int
-olsr_delete_revoked_tc_edges(struct tc_entry *tc, olsr_u16_t ansn, union olsr_ip_addr *lower_border,
-                             union olsr_ip_addr *upper_border)
+olsr_delete_revoked_tc_edges(struct tc_entry *tc, uint16_t ansn, union olsr_ip_addr *lower_border, union olsr_ip_addr *upper_border)
 {
   struct tc_edge_entry *tc_edge;
   int retval = 0;
@@ -561,12 +560,12 @@
   OLSR_PRINTF(5, "TC: deleting MPRS\n");
 #endif
 
-  olsr_bool passedLowerBorder = OLSR_FALSE;
+  bool passedLowerBorder = false;
 
   OLSR_FOR_ALL_TC_EDGE_ENTRIES(tc, tc_edge) {
     if (!passedLowerBorder) {
       if (avl_comp_default(lower_border, &tc_edge->T_dest_addr) <= 0) {
-        passedLowerBorder = OLSR_TRUE;
+        passedLowerBorder = true;
       } else {
         continue;
       }
@@ -585,6 +584,8 @@
   }
   OLSR_FOR_ALL_TC_EDGE_ENTRIES_END(tc, tc_edge);
 
+  if (retval)
+    changes_topology = true;
   return retval;
 }
 
@@ -598,7 +599,7 @@
  * @return 1 if entries are added 0 if not
  */
 static int
-olsr_tc_update_edge(struct tc_entry *tc, olsr_u16_t ansn, const unsigned char **curr, union olsr_ip_addr *neighbor)
+olsr_tc_update_edge(struct tc_entry *tc, uint16_t ansn, const unsigned char **curr, union olsr_ip_addr *neighbor)
 {
   struct tc_edge_entry *tc_edge;
   int edge_change;
@@ -704,7 +705,7 @@
 
       OLSR_PRINTF(1, "%-*s %-*s %-14s %s\n", ipwidth, olsr_ip_to_string(&addrbuf, &tc->addr), ipwidth,
                   olsr_ip_to_string(&dstaddrbuf, &tc_edge->T_dest_addr), get_tc_edge_entry_text(tc_edge, '/', &lqbuffer1),
-                  get_linkcost_text(tc_edge->cost, OLSR_FALSE, &lqbuffer2));
+                  get_linkcost_text(tc_edge->cost, false, &lqbuffer2));
 
     } OLSR_FOR_ALL_TC_EDGE_ENTRIES_END(tc, tc_edge);
   } OLSR_FOR_ALL_TC_ENTRIES_END(tc);
@@ -721,14 +722,14 @@
  * @result 1 if lower/upper border ip have been set
  */
 static int
-olsr_calculate_tc_border(olsr_u8_t lower_border, union olsr_ip_addr *lower_border_ip, olsr_u8_t upper_border,
+olsr_calculate_tc_border(uint8_t lower_border, union olsr_ip_addr *lower_border_ip, uint8_t upper_border,
                          union olsr_ip_addr *upper_border_ip)
 {
   if (lower_border == 0 && upper_border == 0) {
     return 0;
   }
   if (lower_border == 0xff) {
-    memset(&lower_border_ip, 0, sizeof(lower_border_ip));
+    memset(lower_border_ip, 0, sizeof(lower_border_ip));
   } else {
     int i;
 
@@ -741,7 +742,7 @@
   }
 
   if (upper_border == 0xff) {
-    memset(&upper_border_ip, 0xff, sizeof(upper_border_ip));
+    memset(upper_border_ip, 0xff, sizeof(upper_border_ip));
   } else {
     int i;
 
@@ -766,12 +767,12 @@
  * as every call to pkt_get increases the packet offset and
  * hence the spot we are looking at.
  */
-olsr_bool
+bool
 olsr_input_tc(union olsr_message * msg, struct interface * input_if __attribute__ ((unused)), union olsr_ip_addr * from_addr)
 {
   struct ipaddr_str buf;
-  olsr_u16_t size, msg_seq, ansn;
-  olsr_u8_t type, ttl, msg_hops, lower_border, upper_border;
+  uint16_t size, msg_seq, ansn;
+  uint8_t type, ttl, msg_hops, lower_border, upper_border;
   olsr_reltime vtime;
   union olsr_ip_addr originator;
   const unsigned char *limit, *curr;
@@ -782,13 +783,13 @@
 
   curr = (void *)msg;
   if (!msg) {
-    return OLSR_FALSE;
+    return false;
   }
 
   /* We are only interested in TC message types. */
   pkt_get_u8(&curr, &type);
   if ((type != LQ_TC_MESSAGE) && (type != TC_MESSAGE)) {
-    return OLSR_FALSE;
+    return false;
   }
 
   pkt_get_reltime(&curr, &vtime);
@@ -816,7 +817,7 @@
        * Ignore already seen seq/ansn values (small window for mesh memory)
        */
       if ((tc->msg_seq == msg_seq) || (tc->ignored++ < 32)) {
-        return OLSR_FALSE;
+        return false;
       }
 
       OLSR_PRINTF(1, "Ignored to much LQTC's for %s, restarting\n", olsr_ip_to_string(&buf, &originator));
@@ -830,10 +831,10 @@
        */
       if (!tc->err_seq_valid) {
         tc->err_seq = msg_seq;
-        tc->err_seq_valid = OLSR_TRUE;
+        tc->err_seq_valid = true;
       }
       if (tc->err_seq == msg_seq) {
-        return OLSR_FALSE;
+        return false;
       }
 
       OLSR_PRINTF(2, "Detected node restart for %s\n", olsr_ip_to_string(&buf, &originator));
@@ -854,7 +855,7 @@
   tc->msg_seq = msg_seq;
   tc->ansn = ansn;
   tc->ignored = 0;
-  tc->err_seq_valid = OLSR_FALSE;
+  tc->err_seq_valid = false;
 
   /*
    * If the sender interface (NB: not originator) of this message
@@ -863,7 +864,7 @@
    */
   if (check_neighbor_link(from_addr) != SYM_LINK) {
     OLSR_PRINTF(2, "Received TC from NON SYM neighbor %s\n", olsr_ip_to_string(&buf, from_addr));
-    return OLSR_FALSE;
+    return false;
   }
 
   OLSR_PRINTF(1, "Processing TC from %s, seq 0x%04x\n", olsr_ip_to_string(&buf, &originator), tc->msg_seq);
@@ -876,7 +877,7 @@
   borderSet = 0;
   while (curr < limit) {
     if (olsr_tc_update_edge(tc, ansn, &curr, &upper_border_ip)) {
-      changes_topology = OLSR_TRUE;
+      changes_topology = true;
     }
 
     if (!borderSet) {
@@ -915,7 +916,7 @@
   }
 
   /* Forward the message */
-  return OLSR_TRUE;
+  return true;
 }
 
 /*
diff -r feb3d7883ff0 -r d73e73400732 src/tc_set.h
--- a/src/tc_set.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/tc_set.h	Fri Mar 13 19:16:23 2009 +0100
@@ -62,8 +62,8 @@
   struct tc_edge_entry *edge_inv;      /* shortcut, used during SPF calculation */
   struct tc_entry *tc;                 /* backpointer to owning tc entry */
   olsr_linkcost cost;                  /* metric used for SPF calculation */
-  olsr_u16_t ansn;                     /* ansn of this edge, used for multipart msgs */
-  olsr_u32_t linkquality[0];
+  uint16_t ansn;                       /* ansn of this edge, used for multipart msgs */
+  uint32_t linkquality[0];
 };
 
 AVLNODE2STRUCT(edge_tree2tc_edge, struct tc_edge_entry, edge_node);
@@ -79,15 +79,15 @@
   struct link_entry *next_hop;         /* SPF calculated link to the 1st hop neighbor */
   struct timer_entry *edge_gc_timer;   /* used for edge garbage collection */
   struct timer_entry *validity_timer;  /* tc validity time */
-  olsr_u32_t refcount;                 /* reference counter */
-  olsr_u16_t msg_seq;                  /* sequence number of the tc message */
-  olsr_u8_t msg_hops;                  /* hopcount as per the tc message */
-  olsr_u8_t hops;                      /* SPF calculated hopcount */
-  olsr_u16_t ansn;                     /* ANSN number of the tc message */
-  olsr_u16_t ignored;                  /* how many TC messages ignored in a sequence
+  uint32_t refcount;                   /* reference counter */
+  uint16_t msg_seq;                    /* sequence number of the tc message */
+  uint8_t msg_hops;                    /* hopcount as per the tc message */
+  uint8_t hops;                        /* SPF calculated hopcount */
+  uint16_t ansn;                       /* ANSN number of the tc message */
+  uint16_t ignored;                    /* how many TC messages ignored in a sequence
                                           (kindof emergency brake) */
-  olsr_u16_t err_seq;                  /* sequence number of an unplausible TC */
-  olsr_bool err_seq_valid;             /* do we have an error (unplauible seq/ansn) */
+  uint16_t err_seq;                    /* sequence number of an unplausible TC */
+  bool err_seq_valid;                  /* do we have an error (unplauible seq/ansn) */
 };
 
 /*
@@ -147,7 +147,7 @@
 void olsr_time_out_tc_set(void);
 
 /* tc msg input parser */
-olsr_bool olsr_input_tc(union olsr_message *, struct interface *, union olsr_ip_addr *from);
+bool olsr_input_tc(union olsr_message *, struct interface *, union olsr_ip_addr *from);
 
 /* tc_entry manipulation */
 struct tc_entry *olsr_lookup_tc_entry(union olsr_ip_addr *);
@@ -156,15 +156,15 @@
 void olsr_unlock_tc_entry(struct tc_entry *);
 
 /* tc_edge_entry manipulation */
-olsr_bool olsr_delete_outdated_tc_edges(struct tc_entry *);
+bool olsr_delete_outdated_tc_edges(struct tc_entry *);
 char *olsr_tc_edge_to_string(struct tc_edge_entry *);
 struct tc_edge_entry *olsr_lookup_tc_edge(struct tc_entry *, union olsr_ip_addr *);
-struct tc_edge_entry *olsr_add_tc_edge_entry(struct tc_entry *, union olsr_ip_addr *, olsr_u16_t);
+struct tc_edge_entry *olsr_add_tc_edge_entry(struct tc_entry *, union olsr_ip_addr *, uint16_t);
 void olsr_delete_tc_entry(struct tc_entry *);
 void olsr_delete_tc_edge_entry(struct tc_edge_entry *);
-olsr_bool olsr_calc_tc_edge_entry_etx(struct tc_edge_entry *);
+bool olsr_calc_tc_edge_entry_etx(struct tc_edge_entry *);
 void olsr_set_tc_edge_timer(struct tc_edge_entry *, unsigned int);
-// static olsr_bool olsr_etx_significant_change(float, float);
+// static bool olsr_etx_significant_change(float, float);
 
 #endif
 
diff -r feb3d7883ff0 -r d73e73400732 src/two_hop_neighbor_table.c
--- a/src/two_hop_neighbor_table.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/two_hop_neighbor_table.c	Fri Mar 13 19:16:23 2009 +0100
@@ -132,7 +132,7 @@
 void
 olsr_insert_two_hop_neighbor_table(struct neighbor_2_entry *two_hop_neighbor)
 {
-  olsr_u32_t hash = olsr_ip_hashing(&two_hop_neighbor->neighbor_2_addr);
+  uint32_t hash = olsr_ip_hashing(&two_hop_neighbor->neighbor_2_addr);
 
 #if 0
   printf("Adding 2 hop neighbor %s\n", olsr_ip_to_string(&buf, &two_hop_neighbor->neighbor_2_addr));
@@ -155,7 +155,7 @@
 {
 
   struct neighbor_2_entry *neighbor_2;
-  olsr_u32_t hash = olsr_ip_hashing(dest);
+  uint32_t hash = olsr_ip_hashing(dest);
 
   /* printf("LOOKING FOR %s\n", olsr_ip_to_string(&buf, dest)); */
   for (neighbor_2 = two_hop_neighbortable[hash].next; neighbor_2 != &two_hop_neighbortable[hash]; neighbor_2 = neighbor_2->next) {
@@ -190,7 +190,7 @@
 olsr_lookup_two_hop_neighbor_table_mid(const union olsr_ip_addr *dest)
 {
   struct neighbor_2_entry *neighbor_2;
-  olsr_u32_t hash;
+  uint32_t hash;
 
   /* printf("LOOKING FOR %s\n", olsr_ip_to_string(&buf, dest)); */
   hash = olsr_ip_hashing(dest);
@@ -222,19 +222,19 @@
     struct neighbor_2_entry *neigh2;
     for (neigh2 = two_hop_neighbortable[i].next; neigh2 != &two_hop_neighbortable[i]; neigh2 = neigh2->next) {
       struct neighbor_list_entry *entry;
-      olsr_bool first = OLSR_TRUE;
+      bool first = true;
 
       for (entry = neigh2->neighbor_2_nblist.next; entry != &neigh2->neighbor_2_nblist; entry = entry->next) {
         struct ipaddr_str buf;
         struct lqtextbuffer lqbuffer;
         if (first) {
           OLSR_PRINTF(1, "%-15s  ", olsr_ip_to_string(&buf, &neigh2->neighbor_2_addr));
-          first = OLSR_FALSE;
+          first = false;
         } else {
           OLSR_PRINTF(1, "                 ");
         }
         OLSR_PRINTF(1, "%-15s  %s\n", olsr_ip_to_string(&buf, &entry->neighbor->neighbor_main_addr),
-                    get_linkcost_text(entry->path_linkcost, OLSR_FALSE, &lqbuffer));
+                    get_linkcost_text(entry->path_linkcost, false, &lqbuffer));
       }
     }
   }
diff -r feb3d7883ff0 -r d73e73400732 src/two_hop_neighbor_table.h
--- a/src/two_hop_neighbor_table.h	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/two_hop_neighbor_table.h	Fri Mar 13 19:16:23 2009 +0100
@@ -59,9 +59,9 @@
 
 struct neighbor_2_entry {
   union olsr_ip_addr neighbor_2_addr;
-  olsr_u8_t mpr_covered_count;         /*used in mpr calculation */
-  olsr_u8_t processed;                 /*used in mpr calculation */
-  olsr_16_t neighbor_2_pointer;        /* Neighbor count */
+  uint8_t mpr_covered_count;           /*used in mpr calculation */
+  uint8_t processed;                   /*used in mpr calculation */
+  int16_t neighbor_2_pointer;          /* Neighbor count */
   struct neighbor_list_entry neighbor_2_nblist;
   struct neighbor_2_entry *prev;
   struct neighbor_2_entry *next;
diff -r feb3d7883ff0 -r d73e73400732 src/unix/ifnet.c
--- a/src/unix/ifnet.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/unix/ifnet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -203,7 +203,7 @@
     goto remove_interface;
   }
 
-  ifp->is_hcif = OLSR_FALSE;
+  ifp->is_hcif = false;
 
   /* trying to detect if interface is wireless. */
   ifp->is_wireless = check_wireless_interface(ifr.ifr_name);
@@ -260,12 +260,14 @@
       OLSR_PRINTF(1, "\tOld: %s\n", ip6_to_string(&buf, &ifp->int6_addr.sin6_addr));
       OLSR_PRINTF(1, "\tNew: %s\n", ip6_to_string(&buf, &tmp_saddr6.sin6_addr));
 
+      /* deactivated to prevent change of originator IP */
+#if 0
       /* Check main addr */
       if (memcmp(&olsr_cnf->main_addr, &tmp_saddr6.sin6_addr, olsr_cnf->ipsize) == 0) {
         /* Update main addr */
         memcpy(&olsr_cnf->main_addr, &tmp_saddr6.sin6_addr, olsr_cnf->ipsize);
       }
-
+#endif
       /* Update address */
       memcpy(&ifp->int6_addr.sin6_addr, &tmp_saddr6.sin6_addr, olsr_cnf->ipsize);
       memcpy(&ifp->ip_addr, &tmp_saddr6.sin6_addr, olsr_cnf->ipsize);
@@ -298,13 +300,14 @@
       OLSR_PRINTF(1, "\tNew:%s\n", sockaddr4_to_string(&buf, &ifr.ifr_addr));
 
       ifp->int_addr = *(struct sockaddr_in *)&ifr.ifr_addr;
-
+      /* deactivated to prevent change of originator IP */
+#if 0
       if (memcmp(&olsr_cnf->main_addr, &ifp->ip_addr, olsr_cnf->ipsize) == 0) {
         OLSR_PRINTF(1, "New main address: %s\n", sockaddr4_to_string(&buf, &ifr.ifr_addr));
         olsr_syslog(OLSR_LOG_INFO, "New main address: %s\n", sockaddr4_to_string(&buf, &ifr.ifr_addr));
         memcpy(&olsr_cnf->main_addr, &((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr, olsr_cnf->ipsize);
       }
-
+#endif
       memcpy(&ifp->ip_addr, &((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr, olsr_cnf->ipsize);
 
       if_changes = 1;
@@ -387,6 +390,8 @@
   net_remove_buffer(ifp);
 
   /* Check main addr */
+  /* deactivated to prevent change of originator IP */
+#if 0
   if (ipequal(&olsr_cnf->main_addr, &ifp->ip_addr)) {
     if (ifnet == NULL) {
       /* No more interfaces */
@@ -399,7 +404,7 @@
       olsr_syslog(OLSR_LOG_INFO, "New main address: %s\n", olsr_ip_to_string(&buf, &olsr_cnf->main_addr));
     }
   }
-
+#endif
   /*
    * Deregister functions for periodic message generation
    */
@@ -438,7 +443,7 @@
 {
   struct interface *ifp;
   union olsr_ip_addr null_addr;
-  olsr_u32_t addr[4];
+  uint32_t addr[4];
   struct ipaddr_str buf;
   size_t name_size;
 
@@ -449,11 +454,11 @@
 
   memset(ifp, 0, sizeof(struct interface));
 
-  iface->configured = OLSR_TRUE;
+  iface->configured = true;
   iface->interf = ifp;
 
   name_size = strlen("hcif01") + 1;
-  ifp->is_hcif = OLSR_TRUE;
+  ifp->is_hcif = true;
   ifp->int_name = olsr_malloc(name_size, "Interface update 3");
   ifp->int_metric = 0;
 
@@ -647,7 +652,7 @@
     return 0;
   }
 
-  ifs.is_hcif = OLSR_FALSE;
+  ifs.is_hcif = false;
 
   /* trying to detect if interface is wireless. */
   ifs.is_wireless = check_wireless_interface(ifr.ifr_name);
@@ -710,7 +715,7 @@
     /* Find broadcast address */
     if (iface->cnf->ipv4_broadcast.v4.s_addr) {
       /* Specified broadcast */
-      memcpy(&((struct sockaddr_in *)&ifs.int_broadaddr)->sin_addr.s_addr, &iface->cnf->ipv4_broadcast.v4, sizeof(olsr_u32_t));
+      memcpy(&((struct sockaddr_in *)&ifs.int_broadaddr)->sin_addr.s_addr, &iface->cnf->ipv4_broadcast.v4, sizeof(uint32_t));
     } else {
       /* Autodetect */
       if (ioctl(olsr_cnf->ioctl_s, SIOCGIFBRDADDR, &ifr) < 0) {
diff -r feb3d7883ff0 -r d73e73400732 src/win32/ifnet.c
--- a/src/win32/ifnet.c	Tue Dec 02 11:42:51 2008 +0100
+++ b/src/win32/ifnet.c	Fri Mar 13 19:16:23 2009 +0100
@@ -506,6 +506,8 @@
     Prev->int_next = Int->int_next;
   }
 
+  /* deactivated to prevent change of originator IP */
+#if 0
   if (ipequal(&olsr_cnf->main_addr, &Int->ip_addr)) {
     if (ifnet == NULL) {
       memset(&olsr_cnf->main_addr, 0, olsr_cnf->ipsize);
@@ -518,7 +520,7 @@
       OLSR_PRINTF(1, "New main address: %s.\n", olsr_ip_to_string(&buf, &olsr_cnf->main_addr));
     }
   }
-
+#endif
   /*
    * Deregister functions for periodic message generation
    */
@@ -550,7 +552,7 @@
 {
   struct interface *ifp;
   union olsr_ip_addr null_addr;
-  olsr_u32_t addr[4];
+  uint32_t addr[4];
   struct ipaddr_str buf;
   size_t name_size;
 
@@ -561,11 +563,11 @@
 
   memset(ifp, 0, sizeof(struct interface));
 
-  iface->configured = OLSR_TRUE;
+  iface->configured = true;
   iface->interf = ifp;
 
   name_size = strlen("hcif01") + 1;
-  ifp->is_hcif = OLSR_TRUE;
+  ifp->is_hcif = true;
   ifp->int_name = olsr_malloc(name_size, "Interface update 3");
   ifp->int_metric = 0;
 
@@ -763,12 +765,14 @@
     AddrIn->sin_port = 0;
     AddrIn->sin_addr = NewVal.v4;
 
+    /* deactivated to prevent change of originator IP */
+#if 0
     if (olsr_cnf->main_addr.v4.s_addr == OldVal.v4.s_addr) {
       OLSR_PRINTF(1, "\tMain address change.\n");
 
       olsr_cnf->main_addr.v4 = NewVal.v4;
     }
-
+#endif
     Res = 1;
   }
 
@@ -882,7 +886,7 @@
 
   New->int_flags = 0;
 
-  New->is_hcif = OLSR_FALSE;
+  New->is_hcif = false;
 
   New->int_mtu = Info.Mtu;
 
